###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        05/May/2015  09:12:24
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\core\driver\eMPL\inv_mpu.c
#    Command line =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\core\driver\eMPL\inv_mpu.c -D
#        USE_STDPERIPH_DRIVER -D USE_DMP -D MPL_LOG_NDEBUG=1 -D EMPL -D MPU9250
#        -D EMPL_TARGET_STM32F4 -lcN
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\List\ -o
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4F -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0_2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\User\inc\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\User\src\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\Peripheral\inc\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\Peripheral\src\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\DeviceSupport\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\DeviceSupport\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\include\
#        -I C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\eMPL\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\stm32l\
#        -I C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\mllite\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\mpl\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\eMPL-hal\ -Ol
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\CMSIS\Include\"
#    List file    =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\List\inv_mpu.lst
#    Object file  =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\Obj\inv_mpu.o
#
###############################################################################

C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\core\driver\eMPL\inv_mpu.c
      1          /*
      2           $License:
      3              Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
      4              See included License.txt for License information.
      5           $
      6           */
      7          /**
      8           *  @addtogroup  DRIVERS Sensor Driver Layer
      9           *  @brief       Hardware drivers to communicate with sensors via I2C.
     10           *
     11           *  @{
     12           *      @file       inv_mpu.c
     13           *      @brief      An I2C-based driver for Invensense gyroscopes.
     14           *      @details    This driver currently works for the following devices:
     15           *                  MPU6050
     16           *                  MPU6500
     17           *                  MPU9150 (or MPU6050 w/ AK8975 on the auxiliary bus)
     18           *                  MPU9250 (or MPU6500 w/ AK8963 on the auxiliary bus)
     19           */
     20          #include <stdio.h>
     21          #include <stdint.h>
     22          #include <stdlib.h>
     23          #include <string.h>
     24          #include <math.h>
     25          #include "inv_mpu.h"
     26          
     27          /* The following functions must be defined for this platform:
     28           * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
     29           *      unsigned char length, unsigned char const *data)
     30           * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
     31           *      unsigned char length, unsigned char *data)
     32           * delay_ms(unsigned long num_ms)
     33           * get_ms(unsigned long *count)
     34           * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)
     35           * labs(long x)
     36           * fabsf(float x)
     37           * min(int a, int b)
     38           */
     39          #if defined EMPL_TARGET_STM32F4
     40          #include "i2c.h"   
     41          #include "main.h"
     42          #include "log.h"
     43          #include "board-st_discovery.h"
     44             
     45          #define i2c_write   Sensors_I2C_WriteRegister
     46          #define i2c_read    Sensors_I2C_ReadRegister 
     47          #define delay_ms    mdelay
     48          #define get_ms      get_tick_count
     49          #define log_i       MPL_LOGI
     50          #define log_e       MPL_LOGE
     51          #define min(a,b) ((a<b)?a:b)
     52             
     53          #elif defined MOTION_DRIVER_TARGET_MSP430
     54          #include "msp430.h"
     55          #include "msp430_i2c.h"
     56          #include "msp430_clock.h"
     57          #include "msp430_interrupt.h"
     58          #define i2c_write   msp430_i2c_write
     59          #define i2c_read    msp430_i2c_read
     60          #define delay_ms    msp430_delay_ms
     61          #define get_ms      msp430_get_clock_ms
     62          static inline int reg_int_cb(struct int_param_s *int_param)
     63          {
     64              return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
     65                  int_param->active_low);
     66          }
     67          #define log_i(...)     do {} while (0)
     68          #define log_e(...)     do {} while (0)
     69          /* labs is already defined by TI's toolchain. */
     70          /* fabs is for doubles. fabsf is for floats. */
     71          #define fabs        fabsf
     72          #define min(a,b) ((a<b)?a:b)
     73          #elif defined EMPL_TARGET_MSP430
     74          #include "msp430.h"
     75          #include "msp430_i2c.h"
     76          #include "msp430_clock.h"
     77          #include "msp430_interrupt.h"
     78          #include "log.h"
     79          #define i2c_write   msp430_i2c_write
     80          #define i2c_read    msp430_i2c_read
     81          #define delay_ms    msp430_delay_ms
     82          #define get_ms      msp430_get_clock_ms
     83          static inline int reg_int_cb(struct int_param_s *int_param)
     84          {
     85              return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
     86                  int_param->active_low);
     87          }
     88          #define log_i       MPL_LOGI
     89          #define log_e       MPL_LOGE
     90          /* labs is already defined by TI's toolchain. */
     91          /* fabs is for doubles. fabsf is for floats. */
     92          #define fabs        fabsf
     93          #define min(a,b) ((a<b)?a:b)
     94          #elif defined EMPL_TARGET_UC3L0
     95          /* Instead of using the standard TWI driver from the ASF library, we're using
     96           * a TWI driver that follows the slave address + register address convention.
     97           */
     98          #include "twi.h"
     99          #include "delay.h"
    100          #include "sysclk.h"
    101          #include "log.h"
    102          #include "sensors_xplained.h"
    103          #include "uc3l0_clock.h"
    104          #define i2c_write(a, b, c, d)   twi_write(a, b, d, c)
    105          #define i2c_read(a, b, c, d)    twi_read(a, b, d, c)
    106          /* delay_ms is a function already defined in ASF. */
    107          #define get_ms  uc3l0_get_clock_ms
    108          static inline int reg_int_cb(struct int_param_s *int_param)
    109          {
    110              sensor_board_irq_connect(int_param->pin, int_param->cb, int_param->arg);
    111              return 0;
    112          }
    113          #define log_i       MPL_LOGI
    114          #define log_e       MPL_LOGE
    115          /* UC3 is a 32-bit processor, so abs and labs are equivalent. */
    116          #define labs        abs
    117          #define fabs(x)     (((x)>0)?(x):-(x))
    118          #else
    119          #error  Gyro driver is missing the system layer implementations.
    120          #endif
    121          
    122          #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
    123          #error  Which gyro are you using? Define MPUxxxx in your compiler options.
    124          #endif
    125          
    126          /* Time for some messy macro work. =]
    127           * #define MPU9150
    128           * is equivalent to..
    129           * #define MPU6050
    130           * #define AK8975_SECONDARY
    131           *
    132           * #define MPU9250
    133           * is equivalent to..
    134           * #define MPU6500
    135           * #define AK8963_SECONDARY
    136           */
    137          #if defined MPU9150
    138          #ifndef MPU6050
    139          #define MPU6050
    140          #endif                          /* #ifndef MPU6050 */
    141          #if defined AK8963_SECONDARY
    142          #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
    143          #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
    144          #define AK8975_SECONDARY
    145          #endif                          /* #if defined AK8963_SECONDARY */
    146          #elif defined MPU9250           /* #if defined MPU9150 */
    147          #ifndef MPU6500
    148          #define MPU6500
    149          #endif                          /* #ifndef MPU6500 */
    150          #if defined AK8975_SECONDARY
    151          #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
    152          #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
    153          #define AK8963_SECONDARY
    154          #endif                          /* #if defined AK8975_SECONDARY */
    155          #endif                          /* #if defined MPU9150 */
    156          
    157          #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
    158          #define AK89xx_SECONDARY
    159          #else
    160          /* #warning "No compass = less profit for Invensense. Lame." */
    161          #endif
    162          
    163          static int set_int_enable(unsigned char enable);
    164          
    165          /* Hardware registers needed by driver. */
    166          struct gyro_reg_s {
    167              unsigned char who_am_i;
    168              unsigned char rate_div;
    169              unsigned char lpf;
    170              unsigned char prod_id;
    171              unsigned char user_ctrl;
    172              unsigned char fifo_en;
    173              unsigned char gyro_cfg;
    174              unsigned char accel_cfg;
    175              unsigned char accel_cfg2;
    176              unsigned char lp_accel_odr;
    177              unsigned char motion_thr;
    178              unsigned char motion_dur;
    179              unsigned char fifo_count_h;
    180              unsigned char fifo_r_w;
    181              unsigned char raw_gyro;
    182              unsigned char raw_accel;
    183              unsigned char temp;
    184              unsigned char int_enable;
    185              unsigned char dmp_int_status;
    186              unsigned char int_status;
    187              unsigned char accel_intel;
    188              unsigned char pwr_mgmt_1;
    189              unsigned char pwr_mgmt_2;
    190              unsigned char int_pin_cfg;
    191              unsigned char mem_r_w;
    192              unsigned char accel_offs;
    193              unsigned char i2c_mst;
    194              unsigned char bank_sel;
    195              unsigned char mem_start_addr;
    196              unsigned char prgm_start_h;
    197          #if defined AK89xx_SECONDARY
    198              unsigned char s0_addr;
    199              unsigned char s0_reg;
    200              unsigned char s0_ctrl;
    201              unsigned char s1_addr;
    202              unsigned char s1_reg;
    203              unsigned char s1_ctrl;
    204              unsigned char s4_ctrl;
    205              unsigned char s0_do;
    206              unsigned char s1_do;
    207              unsigned char i2c_delay_ctrl;
    208              unsigned char raw_compass;
    209              /* The I2C_MST_VDDIO bit is in this register. */
    210              unsigned char yg_offs_tc;
    211          #endif
    212          };
    213          
    214          /* Information specific to a particular device. */
    215          struct hw_s {
    216              unsigned char addr;
    217              unsigned short max_fifo;
    218              unsigned char num_reg;
    219              unsigned short temp_sens;
    220              short temp_offset;
    221              unsigned short bank_size;
    222          #if defined AK89xx_SECONDARY
    223              unsigned short compass_fsr;
    224          #endif
    225          };
    226          
    227          /* When entering motion interrupt mode, the driver keeps track of the
    228           * previous state so that it can be restored at a later time.
    229           * TODO: This is tacky. Fix it.
    230           */
    231          struct motion_int_cache_s {
    232              unsigned short gyro_fsr;
    233              unsigned char accel_fsr;
    234              unsigned short lpf;
    235              unsigned short sample_rate;
    236              unsigned char sensors_on;
    237              unsigned char fifo_sensors;
    238              unsigned char dmp_on;
    239          };
    240          
    241          /* Cached chip configuration data.
    242           * TODO: A lot of these can be handled with a bitmask.
    243           */
    244          struct chip_cfg_s {
    245              /* Matches gyro_cfg >> 3 & 0x03 */
    246              unsigned char gyro_fsr;
    247              /* Matches accel_cfg >> 3 & 0x03 */
    248              unsigned char accel_fsr;
    249              /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
    250              unsigned char sensors;
    251              /* Matches config register. */
    252              unsigned char lpf;
    253              unsigned char clk_src;
    254              /* Sample rate, NOT rate divider. */
    255              unsigned short sample_rate;
    256              /* Matches fifo_en register. */
    257              unsigned char fifo_enable;
    258              /* Matches int enable register. */
    259              unsigned char int_enable;
    260              /* 1 if devices on auxiliary I2C bus appear on the primary. */
    261              unsigned char bypass_mode;
    262              /* 1 if half-sensitivity.
    263               * NOTE: This doesn't belong here, but everything else in hw_s is const,
    264               * and this allows us to save some precious RAM.
    265               */
    266              unsigned char accel_half;
    267              /* 1 if device in low-power accel-only mode. */
    268              unsigned char lp_accel_mode;
    269              /* 1 if interrupts are only triggered on motion events. */
    270              unsigned char int_motion_only;
    271              struct motion_int_cache_s cache;
    272              /* 1 for active low interrupts. */
    273              unsigned char active_low_int;
    274              /* 1 for latched interrupts. */
    275              unsigned char latched_int;
    276              /* 1 if DMP is enabled. */
    277              unsigned char dmp_on;
    278              /* Ensures that DMP will only be loaded once. */
    279              unsigned char dmp_loaded;
    280              /* Sampling rate used when DMP is enabled. */
    281              unsigned short dmp_sample_rate;
    282          #ifdef AK89xx_SECONDARY
    283              /* Compass sample rate. */
    284              unsigned short compass_sample_rate;
    285              unsigned char compass_addr;
    286              short mag_sens_adj[3];
    287          #endif
    288          };
    289          
    290          /* Information for self-test. */
    291          struct test_s {
    292              unsigned long gyro_sens;
    293              unsigned long accel_sens;
    294              unsigned char reg_rate_div;
    295              unsigned char reg_lpf;
    296              unsigned char reg_gyro_fsr;
    297              unsigned char reg_accel_fsr;
    298              unsigned short wait_ms;
    299              unsigned char packet_thresh;
    300              float min_dps;
    301              float max_dps;
    302              float max_gyro_var;
    303              float min_g;
    304              float max_g;
    305              float max_accel_var;
    306          #ifdef MPU6500
    307              float max_g_offset;
    308              unsigned short sample_wait_ms;
    309          #endif
    310          };
    311          
    312          /* Gyro driver state variables. */
    313          struct gyro_state_s {
    314              const struct gyro_reg_s *reg;
    315              const struct hw_s *hw;
    316              struct chip_cfg_s chip_cfg;
    317              const struct test_s *test;
    318          };
    319          
    320          /* Filter configurations. */
    321          enum lpf_e {
    322              INV_FILTER_256HZ_NOLPF2 = 0,
    323              INV_FILTER_188HZ,
    324              INV_FILTER_98HZ,
    325              INV_FILTER_42HZ,
    326              INV_FILTER_20HZ,
    327              INV_FILTER_10HZ,
    328              INV_FILTER_5HZ,
    329              INV_FILTER_2100HZ_NOLPF,
    330              NUM_FILTER
    331          };
    332          
    333          /* Full scale ranges. */
    334          enum gyro_fsr_e {
    335              INV_FSR_250DPS = 0,
    336              INV_FSR_500DPS,
    337              INV_FSR_1000DPS,
    338              INV_FSR_2000DPS,
    339              NUM_GYRO_FSR
    340          };
    341          
    342          /* Full scale ranges. */
    343          enum accel_fsr_e {
    344              INV_FSR_2G = 0,
    345              INV_FSR_4G,
    346              INV_FSR_8G,
    347              INV_FSR_16G,
    348              NUM_ACCEL_FSR
    349          };
    350          
    351          /* Clock sources. */
    352          enum clock_sel_e {
    353              INV_CLK_INTERNAL = 0,
    354              INV_CLK_PLL,
    355              NUM_CLK
    356          };
    357          
    358          /* Low-power accel wakeup rates. */
    359          enum lp_accel_rate_e {
    360          #if defined MPU6050
    361              INV_LPA_1_25HZ,
    362              INV_LPA_5HZ,
    363              INV_LPA_20HZ,
    364              INV_LPA_40HZ
    365          #elif defined MPU6500
    366              INV_LPA_0_3125HZ,
    367              INV_LPA_0_625HZ,
    368              INV_LPA_1_25HZ,
    369              INV_LPA_2_5HZ,
    370              INV_LPA_5HZ,
    371              INV_LPA_10HZ,
    372              INV_LPA_20HZ,
    373              INV_LPA_40HZ,
    374              INV_LPA_80HZ,
    375              INV_LPA_160HZ,
    376              INV_LPA_320HZ,
    377              INV_LPA_640HZ
    378          #endif
    379          };
    380          
    381          #define BIT_I2C_MST_VDDIO   (0x80)
    382          #define BIT_FIFO_EN         (0x40)
    383          #define BIT_DMP_EN          (0x80)
    384          #define BIT_FIFO_RST        (0x04)
    385          #define BIT_DMP_RST         (0x08)
    386          #define BIT_FIFO_OVERFLOW   (0x10)
    387          #define BIT_DATA_RDY_EN     (0x01)
    388          #define BIT_DMP_INT_EN      (0x02)
    389          #define BIT_MOT_INT_EN      (0x40)
    390          #define BITS_FSR            (0x18)
    391          #define BITS_LPF            (0x07)
    392          #define BITS_HPF            (0x07)
    393          #define BITS_CLK            (0x07)
    394          #define BIT_FIFO_SIZE_1024  (0x40)
    395          #define BIT_FIFO_SIZE_2048  (0x80)
    396          #define BIT_FIFO_SIZE_4096  (0xC0)
    397          #define BIT_RESET           (0x80)
    398          #define BIT_SLEEP           (0x40)
    399          #define BIT_S0_DELAY_EN     (0x01)
    400          #define BIT_S2_DELAY_EN     (0x04)
    401          #define BITS_SLAVE_LENGTH   (0x0F)
    402          #define BIT_SLAVE_BYTE_SW   (0x40)
    403          #define BIT_SLAVE_GROUP     (0x10)
    404          #define BIT_SLAVE_EN        (0x80)
    405          #define BIT_I2C_READ        (0x80)
    406          #define BITS_I2C_MASTER_DLY (0x1F)
    407          #define BIT_AUX_IF_EN       (0x20)
    408          #define BIT_ACTL            (0x80)
    409          #define BIT_LATCH_EN        (0x20)
    410          #define BIT_ANY_RD_CLR      (0x10)
    411          #define BIT_BYPASS_EN       (0x02)
    412          #define BITS_WOM_EN         (0xC0)
    413          #define BIT_LPA_CYCLE       (0x20)
    414          #define BIT_STBY_XA         (0x20)
    415          #define BIT_STBY_YA         (0x10)
    416          #define BIT_STBY_ZA         (0x08)
    417          #define BIT_STBY_XG         (0x04)
    418          #define BIT_STBY_YG         (0x02)
    419          #define BIT_STBY_ZG         (0x01)
    420          #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
    421          #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
    422          
    423          #if defined AK8975_SECONDARY
    424          #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
    425          #define AK89xx_FSR                  (9830)
    426          #elif defined AK8963_SECONDARY
    427          #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
    428          #define AK89xx_FSR                  (4915)
    429          #endif
    430          
    431          #ifdef AK89xx_SECONDARY
    432          #define AKM_REG_WHOAMI      (0x00)
    433          
    434          #define AKM_REG_ST1         (0x02)
    435          #define AKM_REG_HXL         (0x03)
    436          #define AKM_REG_ST2         (0x09)
    437          
    438          #define AKM_REG_CNTL        (0x0A)
    439          #define AKM_REG_ASTC        (0x0C)
    440          #define AKM_REG_ASAX        (0x10)
    441          #define AKM_REG_ASAY        (0x11)
    442          #define AKM_REG_ASAZ        (0x12)
    443          
    444          #define AKM_DATA_READY      (0x01)
    445          #define AKM_DATA_OVERRUN    (0x02)
    446          #define AKM_OVERFLOW        (0x80)
    447          #define AKM_DATA_ERROR      (0x40)
    448          
    449          #define AKM_BIT_SELF_TEST   (0x40)
    450          
    451          #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
    452          #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
    453          #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
    454          #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
    455          
    456          #define AKM_WHOAMI      (0x48)
    457          #endif
    458          
    459          #if defined MPU6050
    460          const struct gyro_reg_s reg = {
    461              .who_am_i       = 0x75,
    462              .rate_div       = 0x19,
    463              .lpf            = 0x1A,
    464              .prod_id        = 0x0C,
    465              .user_ctrl      = 0x6A,
    466              .fifo_en        = 0x23,
    467              .gyro_cfg       = 0x1B,
    468              .accel_cfg      = 0x1C,
    469              .motion_thr     = 0x1F,
    470              .motion_dur     = 0x20,
    471              .fifo_count_h   = 0x72,
    472              .fifo_r_w       = 0x74,
    473              .raw_gyro       = 0x43,
    474              .raw_accel      = 0x3B,
    475              .temp           = 0x41,
    476              .int_enable     = 0x38,
    477              .dmp_int_status = 0x39,
    478              .int_status     = 0x3A,
    479              .pwr_mgmt_1     = 0x6B,
    480              .pwr_mgmt_2     = 0x6C,
    481              .int_pin_cfg    = 0x37,
    482              .mem_r_w        = 0x6F,
    483              .accel_offs     = 0x06,
    484              .i2c_mst        = 0x24,
    485              .bank_sel       = 0x6D,
    486              .mem_start_addr = 0x6E,
    487              .prgm_start_h   = 0x70
    488          #ifdef AK89xx_SECONDARY
    489              ,.raw_compass   = 0x49,
    490              .yg_offs_tc     = 0x01,
    491              .s0_addr        = 0x25,
    492              .s0_reg         = 0x26,
    493              .s0_ctrl        = 0x27,
    494              .s1_addr        = 0x28,
    495              .s1_reg         = 0x29,
    496              .s1_ctrl        = 0x2A,
    497              .s4_ctrl        = 0x34,
    498              .s0_do          = 0x63,
    499              .s1_do          = 0x64,
    500              .i2c_delay_ctrl = 0x67
    501          #endif
    502          };
    503          const struct hw_s hw = {
    504              .addr           = 0x68,
    505              .max_fifo       = 1024,
    506              .num_reg        = 118,
    507              .temp_sens      = 340,
    508              .temp_offset    = -521,
    509              .bank_size      = 256
    510          #if defined AK89xx_SECONDARY
    511              ,.compass_fsr    = AK89xx_FSR
    512          #endif
    513          };
    514          
    515          const struct test_s test = {
    516              .gyro_sens      = 32768/250,
    517              .accel_sens     = 32768/16,
    518              .reg_rate_div   = 0,    /* 1kHz. */
    519              .reg_lpf        = 1,    /* 188Hz. */
    520              .reg_gyro_fsr   = 0,    /* 250dps. */
    521              .reg_accel_fsr  = 0x18, /* 16g. */
    522              .wait_ms        = 50,
    523              .packet_thresh  = 5,    /* 5% */
    524              .min_dps        = 10.f,
    525              .max_dps        = 105.f,
    526              .max_gyro_var   = 0.14f,
    527              .min_g          = 0.3f,
    528              .max_g          = 0.95f,
    529              .max_accel_var  = 0.14f
    530          };
    531          
    532          static struct gyro_state_s st = {
    533              .reg = &reg,
    534              .hw = &hw,
    535              .test = &test
    536          };
    537          #elif defined MPU6500
    538          const struct gyro_reg_s reg = {
    539              .who_am_i       = 0x75,
    540              .rate_div       = 0x19,
    541              .lpf            = 0x1A,
    542              .prod_id        = 0x0C,
    543              .user_ctrl      = 0x6A,
    544              .fifo_en        = 0x23,
    545              .gyro_cfg       = 0x1B,
    546              .accel_cfg      = 0x1C,
    547              .accel_cfg2     = 0x1D,
    548              .lp_accel_odr   = 0x1E,
    549              .motion_thr     = 0x1F,
    550              .motion_dur     = 0x20,
    551              .fifo_count_h   = 0x72,
    552              .fifo_r_w       = 0x74,
    553              .raw_gyro       = 0x43,
    554              .raw_accel      = 0x3B,
    555              .temp           = 0x41,
    556              .int_enable     = 0x38,
    557              .dmp_int_status = 0x39,
    558              .int_status     = 0x3A,
    559              .accel_intel    = 0x69,
    560              .pwr_mgmt_1     = 0x6B,
    561              .pwr_mgmt_2     = 0x6C,
    562              .int_pin_cfg    = 0x37,
    563              .mem_r_w        = 0x6F,
    564              .accel_offs     = 0x77,
    565              .i2c_mst        = 0x24,
    566              .bank_sel       = 0x6D,
    567              .mem_start_addr = 0x6E,
    568              .prgm_start_h   = 0x70
    569          #ifdef AK89xx_SECONDARY
    570              ,.raw_compass   = 0x49,
    571              .s0_addr        = 0x25,
    572              .s0_reg         = 0x26,
    573              .s0_ctrl        = 0x27,
    574              .s1_addr        = 0x28,
    575              .s1_reg         = 0x29,
    576              .s1_ctrl        = 0x2A,
    577              .s4_ctrl        = 0x34,
    578              .s0_do          = 0x63,
    579              .s1_do          = 0x64,
    580              .i2c_delay_ctrl = 0x67
    581          #endif
    582          };
    583          const struct hw_s hw = {
    584              .addr           = 0x68,
    585              .max_fifo       = 1024,
    586              .num_reg        = 128,
    587              .temp_sens      = 321,
    588              .temp_offset    = 0,
    589              .bank_size      = 256
    590          #if defined AK89xx_SECONDARY
    591              ,.compass_fsr    = AK89xx_FSR
    592          #endif
    593          };
    594          
    595          const struct test_s test = {
    596              .gyro_sens      = 32768/250,
    597              .accel_sens     = 32768/2,  //FSR = +-2G = 16384 LSB/G
    598              .reg_rate_div   = 0,    /* 1kHz. */
    599              .reg_lpf        = 2,    /* 92Hz low pass filter*/
    600              .reg_gyro_fsr   = 0,    /* 250dps. */
    601              .reg_accel_fsr  = 0x0,  /* Accel FSR setting = 2g. */
    602              .wait_ms        = 200,   //200ms stabilization time
    603              .packet_thresh  = 200,    /* 200 samples */
    604              .min_dps        = 20.f,  //20 dps for Gyro Criteria C
    605              .max_dps        = 60.f, //Must exceed 60 dps threshold for Gyro Criteria B
    606              .max_gyro_var   = .5f, //Must exceed +50% variation for Gyro Criteria A
    607              .min_g          = .225f, //Accel must exceed Min 225 mg for Criteria B
    608              .max_g          = .675f, //Accel cannot exceed Max 675 mg for Criteria B
    609              .max_accel_var  = .5f,  //Accel must be within 50% variation for Criteria A
    610              .max_g_offset   = .5f,   //500 mg for Accel Criteria C
    611              .sample_wait_ms = 10    //10ms sample time wait
    612          };
    613          
    614          static struct gyro_state_s st = {
    615              .reg = &reg,
    616              .hw = &hw,
    617              .test = &test
    618          };
    619          #endif
    620          
    621          #define MAX_PACKET_LENGTH (12)
    622          #ifdef MPU6500
    623          #define HWST_MAX_PACKET_LENGTH (512)
    624          #endif
    625          
    626          #ifdef AK89xx_SECONDARY
    627          static int setup_compass(void);
    628          #define MAX_COMPASS_SAMPLE_RATE (100)
    629          #endif
    630          
    631          /**
    632           *  @brief      Enable/disable data ready interrupt.
    633           *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready
    634           *  interrupt is used.
    635           *  @param[in]  enable      1 to enable interrupt.
    636           *  @return     0 if successful.
    637           */
    638          static int set_int_enable(unsigned char enable)
    639          {
    640              unsigned char tmp;
    641          
    642              if (st.chip_cfg.dmp_on) {
    643                  if (enable)
    644                      tmp = BIT_DMP_INT_EN;
    645                  else
    646                      tmp = 0x00;
    647                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
    648                      return -1;
    649                  st.chip_cfg.int_enable = tmp;
    650              } else {
    651                  if (!st.chip_cfg.sensors)
    652                      return -1;
    653                  if (enable && st.chip_cfg.int_enable)
    654                      return 0;
    655                  if (enable)
    656                      tmp = BIT_DATA_RDY_EN;
    657                  else
    658                      tmp = 0x00;
    659                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
    660                      return -1;
    661                  st.chip_cfg.int_enable = tmp;
    662              }
    663              return 0;
    664          }
    665          
    666          /**
    667           *  @brief      Register dump for testing.
    668           *  @return     0 if successful.
    669           */
    670          int mpu_reg_dump(void)
    671          {
    672              unsigned char ii;
    673              unsigned char data;
    674          
    675              for (ii = 0; ii < st.hw->num_reg; ii++) {
    676                  if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
    677                      continue;
    678                  if (i2c_read(st.hw->addr, ii, 1, &data))
    679                      return -1;
    680                  log_i("%#5x: %#5x\r\n", ii, data);
    681              }
    682              return 0;
    683          }
    684          
    685          /**
    686           *  @brief      Read from a single register.
    687           *  NOTE: The memory and FIFO read/write registers cannot be accessed.
    688           *  @param[in]  reg     Register address.
    689           *  @param[out] data    Register data.
    690           *  @return     0 if successful.
    691           */
    692          int mpu_read_reg(unsigned char reg, unsigned char *data)
    693          {
    694              if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
    695                  return -1;
    696              if (reg >= st.hw->num_reg)
    697                  return -1;
    698              return i2c_read(st.hw->addr, reg, 1, data);
    699          }
    700          
    701          /**
    702           *  @brief      Initialize hardware.
    703           *  Initial configuration:\n
    704           *  Gyro FSR: +/- 2000DPS\n
    705           *  Accel FSR +/- 2G\n
    706           *  DLPF: 42Hz\n
    707           *  FIFO rate: 50Hz\n
    708           *  Clock source: Gyro PLL\n
    709           *  FIFO: Disabled.\n
    710           *  Data ready interrupt: Disabled, active low, unlatched.
    711           *  @param[in]  int_param   Platform-specific parameters to interrupt API.
    712           *  @return     0 if successful.
    713           */
    714          int mpu_init(struct int_param_s *int_param)
    715          {
    716              unsigned char data[6];
    717          
    718              /* Reset device. */
    719              data[0] = BIT_RESET;
    720              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
    721                  return -1;
    722              delay_ms(100);
    723          
    724              /* Wake up chip. */
    725              data[0] = 0x00;
    726              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
    727                  return -1;
    728          
    729             st.chip_cfg.accel_half = 0;
    730          
    731          #ifdef MPU6500
    732              /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
    733               * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
    734               */
    735              data[0] = BIT_FIFO_SIZE_1024 | 0x8;
    736              if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
    737                  return -1;
    738          #endif
    739          
    740              /* Set to invalid values to ensure no I2C writes are skipped. */
    741              st.chip_cfg.sensors = 0xFF;
    742              st.chip_cfg.gyro_fsr = 0xFF;
    743              st.chip_cfg.accel_fsr = 0xFF;
    744              st.chip_cfg.lpf = 0xFF;
    745              st.chip_cfg.sample_rate = 0xFFFF;
    746              st.chip_cfg.fifo_enable = 0xFF;
    747              st.chip_cfg.bypass_mode = 0xFF;
    748          #ifdef AK89xx_SECONDARY
    749              st.chip_cfg.compass_sample_rate = 0xFFFF;
    750          #endif
    751              /* mpu_set_sensors always preserves this setting. */
    752              st.chip_cfg.clk_src = INV_CLK_PLL;
    753              /* Handled in next call to mpu_set_bypass. */
    754              st.chip_cfg.active_low_int = 1;
    755              st.chip_cfg.latched_int = 0;
    756              st.chip_cfg.int_motion_only = 0;
    757              st.chip_cfg.lp_accel_mode = 0;
    758              memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
    759              st.chip_cfg.dmp_on = 0;
    760              st.chip_cfg.dmp_loaded = 0;
    761              st.chip_cfg.dmp_sample_rate = 0;
    762          
    763              if (mpu_set_gyro_fsr(2000))
    764                  return -1;
    765              if (mpu_set_accel_fsr(2))
    766                  return -1;
    767              if (mpu_set_lpf(42))
    768                  return -1;
    769              if (mpu_set_sample_rate(50))
    770                  return -1;
    771              if (mpu_configure_fifo(0))
    772                  return -1;
    773          
    774          #ifndef EMPL_TARGET_STM32F4    
    775              if (int_param)
    776                  reg_int_cb(int_param);
    777          #endif
    778          
    779          #ifdef AK89xx_SECONDARY
    780              setup_compass();
    781              if (mpu_set_compass_sample_rate(10))
    782                  return -1;
    783          #else
    784              /* Already disabled by setup_compass. */
    785              if (mpu_set_bypass(0))
    786                  return -1;
    787          #endif
    788          
    789              mpu_set_sensors(0);
    790              return 0;
    791          }
    792          
    793          /**
    794           *  @brief      Enter low-power accel-only mode.
    795           *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
    796           *  the accelerometer at one of the following frequencies:
    797           *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
    798           *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
    799           *  \n If the requested rate is not one listed above, the device will be set to
    800           *  the next highest rate. Requesting a rate above the maximum supported
    801           *  frequency will result in an error.
    802           *  \n To select a fractional wake-up frequency, round down the value passed to
    803           *  @e rate.
    804           *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
    805           *                          accel mode.
    806           *  @return     0 if successful.
    807           */
    808          int mpu_lp_accel_mode(unsigned short rate)
    809          {
    810              unsigned char tmp[2];
    811          
    812              if (rate > 40)
    813                  return -1;
    814          
    815              if (!rate) {
    816                  mpu_set_int_latched(0);
    817                  tmp[0] = 0;
    818                  tmp[1] = BIT_STBY_XYZG;
    819                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
    820                      return -1;
    821                  st.chip_cfg.lp_accel_mode = 0;
    822                  return 0;
    823              }
    824              /* For LP accel, we automatically configure the hardware to produce latched
    825               * interrupts. In LP accel mode, the hardware cycles into sleep mode before
    826               * it gets a chance to deassert the interrupt pin; therefore, we shift this
    827               * responsibility over to the MCU.
    828               *
    829               * Any register read will clear the interrupt.
    830               */
    831              mpu_set_int_latched(1);
    832          #if defined MPU6050
    833              tmp[0] = BIT_LPA_CYCLE;
    834              if (rate == 1) {
    835                  tmp[1] = INV_LPA_1_25HZ;
    836                  mpu_set_lpf(5);
    837              } else if (rate <= 5) {
    838                  tmp[1] = INV_LPA_5HZ;
    839                  mpu_set_lpf(5);
    840              } else if (rate <= 20) {
    841                  tmp[1] = INV_LPA_20HZ;
    842                  mpu_set_lpf(10);
    843              } else {
    844                  tmp[1] = INV_LPA_40HZ;
    845                  mpu_set_lpf(20);
    846              }
    847              tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
    848              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
    849                  return -1;
    850          #elif defined MPU6500
    851              /* Set wake frequency. */
    852              if (rate == 1)
    853                  tmp[0] = INV_LPA_1_25HZ;
    854              else if (rate == 2)
    855                  tmp[0] = INV_LPA_2_5HZ;
    856              else if (rate <= 5)
    857                  tmp[0] = INV_LPA_5HZ;
    858              else if (rate <= 10)
    859                  tmp[0] = INV_LPA_10HZ;
    860              else if (rate <= 20)
    861                  tmp[0] = INV_LPA_20HZ;
    862              else if (rate <= 40)
    863                  tmp[0] = INV_LPA_40HZ;
    864              else if (rate <= 80)
    865                  tmp[0] = INV_LPA_80HZ;
    866              else if (rate <= 160)
    867                  tmp[0] = INV_LPA_160HZ;
    868              else if (rate <= 320)
    869                  tmp[0] = INV_LPA_320HZ;
    870              else
    871                  tmp[0] = INV_LPA_640HZ;
    872              if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
    873                  return -1;
    874              tmp[0] = BIT_LPA_CYCLE;
    875              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
    876                  return -1;
    877          #endif
    878              st.chip_cfg.sensors = INV_XYZ_ACCEL;
    879              st.chip_cfg.clk_src = 0;
    880              st.chip_cfg.lp_accel_mode = 1;
    881              mpu_configure_fifo(0);
    882          
    883              return 0;
    884          }
    885          
    886          /**
    887           *  @brief      Read raw gyro data directly from the registers.
    888           *  @param[out] data        Raw data in hardware units.
    889           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
    890           *  @return     0 if successful.
    891           */
    892          int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
    893          {
    894              unsigned char tmp[6];
    895          
    896              if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
    897                  return -1;
    898          
    899              if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
    900                  return -1;
    901              data[0] = (tmp[0] << 8) | tmp[1];
    902              data[1] = (tmp[2] << 8) | tmp[3];
    903              data[2] = (tmp[4] << 8) | tmp[5];
    904              if (timestamp)
    905                  get_ms(timestamp);
    906              return 0;
    907          }
    908          
    909          /**
    910           *  @brief      Read raw accel data directly from the registers.
    911           *  @param[out] data        Raw data in hardware units.
    912           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
    913           *  @return     0 if successful.
    914           */
    915          int mpu_get_accel_reg(short *data, unsigned long *timestamp)
    916          {
    917              unsigned char tmp[6];
    918          
    919              if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
    920                  return -1;
    921          
    922              if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
    923                  return -1;
    924              data[0] = (tmp[0] << 8) | tmp[1];
    925              data[1] = (tmp[2] << 8) | tmp[3];
    926              data[2] = (tmp[4] << 8) | tmp[5];
    927              if (timestamp)
    928                  get_ms(timestamp);
    929              return 0;
    930          }
    931          
    932          /**
    933           *  @brief      Read temperature data directly from the registers.
    934           *  @param[out] data        Data in q16 format.
    935           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
    936           *  @return     0 if successful.
    937           */
    938          int mpu_get_temperature(long *data, unsigned long *timestamp)
    939          {
    940              unsigned char tmp[2];
    941              short raw;
    942          
    943              if (!(st.chip_cfg.sensors))
    944                  return -1;
    945          
    946              if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
    947                  return -1;
    948              raw = (tmp[0] << 8) | tmp[1];
    949              if (timestamp)
    950                  get_ms(timestamp);
    951          
    952              data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
    953              return 0;
    954          }
    955          
    956          /**
    957           *  @brief      Read biases to the accel bias 6500 registers.
    958           *  This function reads from the MPU6500 accel offset cancellations registers.
    959           *  The format are G in +-8G format. The register is initialized with OTP 
    960           *  factory trim values.
    961           *  @param[in]  accel_bias  returned structure with the accel bias
    962           *  @return     0 if successful.
    963           */
    964          int mpu_read_6500_accel_bias(long *accel_bias) {
    965          	unsigned char data[6];
    966          	if (i2c_read(st.hw->addr, 0x77, 2, &data[0]))
    967          		return -1;
    968          	if (i2c_read(st.hw->addr, 0x7A, 2, &data[2]))
    969          		return -1;
    970          	if (i2c_read(st.hw->addr, 0x7D, 2, &data[4]))
    971          		return -1;
    972          	accel_bias[0] = ((long)data[0]<<8) | data[1];
    973          	accel_bias[1] = ((long)data[2]<<8) | data[3];
    974          	accel_bias[2] = ((long)data[4]<<8) | data[5];
    975          	return 0;
    976          }
    977          
    978          /**
    979           *  @brief      Read biases to the accel bias 6050 registers.
    980           *  This function reads from the MPU6050 accel offset cancellations registers.
    981           *  The format are G in +-8G format. The register is initialized with OTP 
    982           *  factory trim values.
    983           *  @param[in]  accel_bias  returned structure with the accel bias
    984           *  @return     0 if successful.
    985           */
    986          int mpu_read_6050_accel_bias(long *accel_bias) {
    987          	unsigned char data[6];
    988          	if (i2c_read(st.hw->addr, 0x06, 2, &data[0]))
    989          		return -1;
    990          	if (i2c_read(st.hw->addr, 0x08, 2, &data[2]))
    991          		return -1;
    992          	if (i2c_read(st.hw->addr, 0x0A, 2, &data[4]))
    993          		return -1;
    994          	accel_bias[0] = ((long)data[0]<<8) | data[1];
    995          	accel_bias[1] = ((long)data[2]<<8) | data[3];
    996          	accel_bias[2] = ((long)data[4]<<8) | data[5];
    997          	return 0;
    998          }
    999          
   1000          int mpu_read_6500_gyro_bias(long *gyro_bias) {
   1001          	unsigned char data[6];
   1002          	if (i2c_read(st.hw->addr, 0x13, 2, &data[0]))
   1003          		return -1;
   1004          	if (i2c_read(st.hw->addr, 0x15, 2, &data[2]))
   1005          		return -1;
   1006          	if (i2c_read(st.hw->addr, 0x17, 2, &data[4]))
   1007          		return -1;
   1008          	gyro_bias[0] = ((long)data[0]<<8) | data[1];
   1009          	gyro_bias[1] = ((long)data[2]<<8) | data[3];
   1010          	gyro_bias[2] = ((long)data[4]<<8) | data[5];
   1011          	return 0;
   1012          }
   1013          
   1014          /**
   1015           *  @brief      Push biases to the gyro bias 6500/6050 registers.
   1016           *  This function expects biases relative to the current sensor output, and
   1017           *  these biases will be added to the factory-supplied values. Bias inputs are LSB
   1018           *  in +-1000dps format.
   1019           *  @param[in]  gyro_bias  New biases.
   1020           *  @return     0 if successful.
   1021           */
   1022          int mpu_set_gyro_bias_reg(long *gyro_bias)
   1023          {
   1024              unsigned char data[6] = {0, 0, 0, 0, 0, 0};
   1025              int i=0;
   1026              for(i=0;i<3;i++) {
   1027              	gyro_bias[i]= (-gyro_bias[i]);
   1028              }
   1029              data[0] = (gyro_bias[0] >> 8) & 0xff;
   1030              data[1] = (gyro_bias[0]) & 0xff;
   1031              data[2] = (gyro_bias[1] >> 8) & 0xff;
   1032              data[3] = (gyro_bias[1]) & 0xff;
   1033              data[4] = (gyro_bias[2] >> 8) & 0xff;
   1034              data[5] = (gyro_bias[2]) & 0xff;
   1035              if (i2c_write(st.hw->addr, 0x13, 2, &data[0]))
   1036                  return -1;
   1037              if (i2c_write(st.hw->addr, 0x15, 2, &data[2]))
   1038                  return -1;
   1039              if (i2c_write(st.hw->addr, 0x17, 2, &data[4]))
   1040                  return -1;
   1041              return 0;
   1042          }
   1043          
   1044          /**
   1045           *  @brief      Push biases to the accel bias 6050 registers.
   1046           *  This function expects biases relative to the current sensor output, and
   1047           *  these biases will be added to the factory-supplied values. Bias inputs are LSB
   1048           *  in +-16G format.
   1049           *  @param[in]  accel_bias  New biases.
   1050           *  @return     0 if successful.
   1051           */
   1052          int mpu_set_accel_bias_6050_reg(const long *accel_bias) {
   1053              unsigned char data[6] = {0, 0, 0, 0, 0, 0};
   1054              long accel_reg_bias[3] = {0, 0, 0};
   1055          
   1056              if(mpu_read_6050_accel_bias(accel_reg_bias))
   1057                  return -1;
   1058          
   1059              accel_reg_bias[0] -= (accel_bias[0] & ~1);
   1060              accel_reg_bias[1] -= (accel_bias[1] & ~1);
   1061              accel_reg_bias[2] -= (accel_bias[2] & ~1);
   1062          
   1063              data[0] = (accel_reg_bias[0] >> 8) & 0xff;
   1064              data[1] = (accel_reg_bias[0]) & 0xff;
   1065              data[2] = (accel_reg_bias[1] >> 8) & 0xff;
   1066              data[3] = (accel_reg_bias[1]) & 0xff;
   1067              data[4] = (accel_reg_bias[2] >> 8) & 0xff;
   1068              data[5] = (accel_reg_bias[2]) & 0xff;
   1069          
   1070              if (i2c_write(st.hw->addr, 0x06, 2, &data[0]))
   1071                  return -1;
   1072              if (i2c_write(st.hw->addr, 0x08, 2, &data[2]))
   1073                  return -1;
   1074              if (i2c_write(st.hw->addr, 0x0A, 2, &data[4]))
   1075                  return -1;
   1076          
   1077              return 0;
   1078          }
   1079          
   1080          
   1081          
   1082          /**
   1083           *  @brief      Push biases to the accel bias 6500 registers.
   1084           *  This function expects biases relative to the current sensor output, and
   1085           *  these biases will be added to the factory-supplied values. Bias inputs are LSB
   1086           *  in +-16G format.
   1087           *  @param[in]  accel_bias  New biases.
   1088           *  @return     0 if successful.
   1089           */
   1090          int mpu_set_accel_bias_6500_reg(const long *accel_bias) {
   1091              unsigned char data[6] = {0, 0, 0, 0, 0, 0};
   1092              long accel_reg_bias[3] = {0, 0, 0};
   1093          
   1094              if(mpu_read_6500_accel_bias(accel_reg_bias))
   1095                  return -1;
   1096          
   1097              // Preserve bit 0 of factory value (for temperature compensation)
   1098              accel_reg_bias[0] -= (accel_bias[0] & ~1);
   1099              accel_reg_bias[1] -= (accel_bias[1] & ~1);
   1100              accel_reg_bias[2] -= (accel_bias[2] & ~1);
   1101          
   1102              data[0] = (accel_reg_bias[0] >> 8) & 0xff;
   1103              data[1] = (accel_reg_bias[0]) & 0xff;
   1104              data[2] = (accel_reg_bias[1] >> 8) & 0xff;
   1105              data[3] = (accel_reg_bias[1]) & 0xff;
   1106              data[4] = (accel_reg_bias[2] >> 8) & 0xff;
   1107              data[5] = (accel_reg_bias[2]) & 0xff;
   1108          
   1109              if (i2c_write(st.hw->addr, 0x77, 2, &data[0]))
   1110                  return -1;
   1111              if (i2c_write(st.hw->addr, 0x7A, 2, &data[2]))
   1112                  return -1;
   1113              if (i2c_write(st.hw->addr, 0x7D, 2, &data[4]))
   1114                  return -1;
   1115          
   1116              return 0;
   1117          }
   1118          
   1119          
   1120          /**
   1121           *  @brief  Reset FIFO read/write pointers.
   1122           *  @return 0 if successful.
   1123           */
   1124          int mpu_reset_fifo(void)
   1125          {
   1126              unsigned char data;
   1127          
   1128              if (!(st.chip_cfg.sensors))
   1129                  return -1;
   1130          
   1131              data = 0;
   1132              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   1133                  return -1;
   1134              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   1135                  return -1;
   1136              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   1137                  return -1;
   1138          
   1139              if (st.chip_cfg.dmp_on) {
   1140                  data = BIT_FIFO_RST | BIT_DMP_RST;
   1141                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   1142                      return -1;
   1143                  delay_ms(50);
   1144                  data = BIT_DMP_EN | BIT_FIFO_EN;
   1145                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   1146                      data |= BIT_AUX_IF_EN;
   1147                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   1148                      return -1;
   1149                  if (st.chip_cfg.int_enable)
   1150                      data = BIT_DMP_INT_EN;
   1151                  else
   1152                      data = 0;
   1153                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   1154                      return -1;
   1155                  data = 0;
   1156                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   1157                      return -1;
   1158              } else {
   1159                  data = BIT_FIFO_RST;
   1160                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   1161                      return -1;
   1162                  if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   1163                      data = BIT_FIFO_EN;
   1164                  else
   1165                      data = BIT_FIFO_EN | BIT_AUX_IF_EN;
   1166                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   1167                      return -1;
   1168                  delay_ms(50);
   1169                  if (st.chip_cfg.int_enable)
   1170                      data = BIT_DATA_RDY_EN;
   1171                  else
   1172                      data = 0;
   1173                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   1174                      return -1;
   1175                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
   1176                      return -1;
   1177              }
   1178              return 0;
   1179          }
   1180          
   1181          /**
   1182           *  @brief      Get the gyro full-scale range.
   1183           *  @param[out] fsr Current full-scale range.
   1184           *  @return     0 if successful.
   1185           */
   1186          int mpu_get_gyro_fsr(unsigned short *fsr)
   1187          {
   1188              switch (st.chip_cfg.gyro_fsr) {
   1189              case INV_FSR_250DPS:
   1190                  fsr[0] = 250;
   1191                  break;
   1192              case INV_FSR_500DPS:
   1193                  fsr[0] = 500;
   1194                  break;
   1195              case INV_FSR_1000DPS:
   1196                  fsr[0] = 1000;
   1197                  break;
   1198              case INV_FSR_2000DPS:
   1199                  fsr[0] = 2000;
   1200                  break;
   1201              default:
   1202                  fsr[0] = 0;
   1203                  break;
   1204              }
   1205              return 0;
   1206          }
   1207          
   1208          /**
   1209           *  @brief      Set the gyro full-scale range.
   1210           *  @param[in]  fsr Desired full-scale range.
   1211           *  @return     0 if successful.
   1212           */
   1213          int mpu_set_gyro_fsr(unsigned short fsr)
   1214          {
   1215              unsigned char data;
   1216          
   1217              if (!(st.chip_cfg.sensors))
   1218                  return -1;
   1219          
   1220              switch (fsr) {
   1221              case 250:
   1222                  data = INV_FSR_250DPS << 3;
   1223                  break;
   1224              case 500:
   1225                  data = INV_FSR_500DPS << 3;
   1226                  break;
   1227              case 1000:
   1228                  data = INV_FSR_1000DPS << 3;
   1229                  break;
   1230              case 2000:
   1231                  data = INV_FSR_2000DPS << 3;
   1232                  break;
   1233              default:
   1234                  return -1;
   1235              }
   1236          
   1237              if (st.chip_cfg.gyro_fsr == (data >> 3))
   1238                  return 0;
   1239              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
   1240                  return -1;
   1241              st.chip_cfg.gyro_fsr = data >> 3;
   1242              return 0;
   1243          }
   1244          
   1245          /**
   1246           *  @brief      Get the accel full-scale range.
   1247           *  @param[out] fsr Current full-scale range.
   1248           *  @return     0 if successful.
   1249           */
   1250          int mpu_get_accel_fsr(unsigned char *fsr)
   1251          {
   1252              switch (st.chip_cfg.accel_fsr) {
   1253              case INV_FSR_2G:
   1254                  fsr[0] = 2;
   1255                  break;
   1256              case INV_FSR_4G:
   1257                  fsr[0] = 4;
   1258                  break;
   1259              case INV_FSR_8G:
   1260                  fsr[0] = 8;
   1261                  break;
   1262              case INV_FSR_16G:
   1263                  fsr[0] = 16;
   1264                  break;
   1265              default:
   1266                  return -1;
   1267              }
   1268              if (st.chip_cfg.accel_half)
   1269                  fsr[0] <<= 1;
   1270              return 0;
   1271          }
   1272          
   1273          /**
   1274           *  @brief      Set the accel full-scale range.
   1275           *  @param[in]  fsr Desired full-scale range.
   1276           *  @return     0 if successful.
   1277           */
   1278          int mpu_set_accel_fsr(unsigned char fsr)
   1279          {
   1280              unsigned char data;
   1281          
   1282              if (!(st.chip_cfg.sensors))
   1283                  return -1;
   1284          
   1285              switch (fsr) {
   1286              case 2:
   1287                  data = INV_FSR_2G << 3;
   1288                  break;
   1289              case 4:
   1290                  data = INV_FSR_4G << 3;
   1291                  break;
   1292              case 8:
   1293                  data = INV_FSR_8G << 3;
   1294                  break;
   1295              case 16:
   1296                  data = INV_FSR_16G << 3;
   1297                  break;
   1298              default:
   1299                  return -1;
   1300              }
   1301          
   1302              if (st.chip_cfg.accel_fsr == (data >> 3))
   1303                  return 0;
   1304              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
   1305                  return -1;
   1306              st.chip_cfg.accel_fsr = data >> 3;
   1307              return 0;
   1308          }
   1309          
   1310          /**
   1311           *  @brief      Get the current DLPF setting.
   1312           *  @param[out] lpf Current LPF setting.
   1313           *  0 if successful.
   1314           */
   1315          int mpu_get_lpf(unsigned short *lpf)
   1316          {
   1317              switch (st.chip_cfg.lpf) {
   1318              case INV_FILTER_188HZ:
   1319                  lpf[0] = 188;
   1320                  break;
   1321              case INV_FILTER_98HZ:
   1322                  lpf[0] = 98;
   1323                  break;
   1324              case INV_FILTER_42HZ:
   1325                  lpf[0] = 42;
   1326                  break;
   1327              case INV_FILTER_20HZ:
   1328                  lpf[0] = 20;
   1329                  break;
   1330              case INV_FILTER_10HZ:
   1331                  lpf[0] = 10;
   1332                  break;
   1333              case INV_FILTER_5HZ:
   1334                  lpf[0] = 5;
   1335                  break;
   1336              case INV_FILTER_256HZ_NOLPF2:
   1337              case INV_FILTER_2100HZ_NOLPF:
   1338              default:
   1339                  lpf[0] = 0;
   1340                  break;
   1341              }
   1342              return 0;
   1343          }
   1344          
   1345          /**
   1346           *  @brief      Set digital low pass filter.
   1347           *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
   1348           *  @param[in]  lpf Desired LPF setting.
   1349           *  @return     0 if successful.
   1350           */
   1351          int mpu_set_lpf(unsigned short lpf)
   1352          {
   1353              unsigned char data;
   1354          
   1355              if (!(st.chip_cfg.sensors))
   1356                  return -1;
   1357          
   1358              if (lpf >= 188)
   1359                  data = INV_FILTER_188HZ;
   1360              else if (lpf >= 98)
   1361                  data = INV_FILTER_98HZ;
   1362              else if (lpf >= 42)
   1363                  data = INV_FILTER_42HZ;
   1364              else if (lpf >= 20)
   1365                  data = INV_FILTER_20HZ;
   1366              else if (lpf >= 10)
   1367                  data = INV_FILTER_10HZ;
   1368              else
   1369                  data = INV_FILTER_5HZ;
   1370          
   1371              if (st.chip_cfg.lpf == data)
   1372                  return 0;
   1373              if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
   1374                  return -1;
   1375              st.chip_cfg.lpf = data;
   1376              return 0;
   1377          }
   1378          
   1379          /**
   1380           *  @brief      Get sampling rate.
   1381           *  @param[out] rate    Current sampling rate (Hz).
   1382           *  @return     0 if successful.
   1383           */
   1384          int mpu_get_sample_rate(unsigned short *rate)
   1385          {
   1386              if (st.chip_cfg.dmp_on)
   1387                  return -1;
   1388              else
   1389                  rate[0] = st.chip_cfg.sample_rate;
   1390              return 0;
   1391          }
   1392          
   1393          /**
   1394           *  @brief      Set sampling rate.
   1395           *  Sampling rate must be between 4Hz and 1kHz.
   1396           *  @param[in]  rate    Desired sampling rate (Hz).
   1397           *  @return     0 if successful.
   1398           */
   1399          int mpu_set_sample_rate(unsigned short rate)
   1400          {
   1401              unsigned char data;
   1402          
   1403              if (!(st.chip_cfg.sensors))
   1404                  return -1;
   1405          
   1406              if (st.chip_cfg.dmp_on)
   1407                  return -1;
   1408              else {
   1409                  if (st.chip_cfg.lp_accel_mode) {
   1410                      if (rate && (rate <= 40)) {
   1411                          /* Just stay in low-power accel mode. */
   1412                          mpu_lp_accel_mode(rate);
   1413                          return 0;
   1414                      }
   1415                      /* Requested rate exceeds the allowed frequencies in LP accel mode,
   1416                       * switch back to full-power mode.
   1417                       */
   1418                      mpu_lp_accel_mode(0);
   1419                  }
   1420                  if (rate < 4)
   1421                      rate = 4;
   1422                  else if (rate > 1000)
   1423                      rate = 1000;
   1424          
   1425                  data = 1000 / rate - 1;
   1426                  if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
   1427                      return -1;
   1428          
   1429                  st.chip_cfg.sample_rate = 1000 / (1 + data);
   1430          
   1431          #ifdef AK89xx_SECONDARY
   1432                  mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
   1433          #endif
   1434          
   1435                  /* Automatically set LPF to 1/2 sampling rate. */
   1436                  mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
   1437                  return 0;
   1438              }
   1439          }
   1440          
   1441          /**
   1442           *  @brief      Get compass sampling rate.
   1443           *  @param[out] rate    Current compass sampling rate (Hz).
   1444           *  @return     0 if successful.
   1445           */
   1446          int mpu_get_compass_sample_rate(unsigned short *rate)
   1447          {
   1448          #ifdef AK89xx_SECONDARY
   1449              rate[0] = st.chip_cfg.compass_sample_rate;
   1450              return 0;
   1451          #else
   1452              rate[0] = 0;
   1453              return -1;
   1454          #endif
   1455          }
   1456          
   1457          /**
   1458           *  @brief      Set compass sampling rate.
   1459           *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
   1460           *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
   1461           *  sampling rate.
   1462           *
   1463           *  \n WARNING: The new rate may be different than what was requested. Call
   1464           *  mpu_get_compass_sample_rate to check the actual setting.
   1465           *  @param[in]  rate    Desired compass sampling rate (Hz).
   1466           *  @return     0 if successful.
   1467           */
   1468          int mpu_set_compass_sample_rate(unsigned short rate)
   1469          {
   1470          #ifdef AK89xx_SECONDARY
   1471              unsigned char div;
   1472              if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
   1473                  return -1;
   1474          
   1475              div = st.chip_cfg.sample_rate / rate - 1;
   1476              if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
   1477                  return -1;
   1478              st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
   1479              return 0;
   1480          #else
   1481              return -1;
   1482          #endif
   1483          }
   1484          
   1485          /**
   1486           *  @brief      Get gyro sensitivity scale factor.
   1487           *  @param[out] sens    Conversion from hardware units to dps.
   1488           *  @return     0 if successful.
   1489           */
   1490          int mpu_get_gyro_sens(float *sens)
   1491          {
   1492              switch (st.chip_cfg.gyro_fsr) {
   1493              case INV_FSR_250DPS:
   1494                  sens[0] = 131.f;
   1495                  break;
   1496              case INV_FSR_500DPS:
   1497                  sens[0] = 65.5f;
   1498                  break;
   1499              case INV_FSR_1000DPS:
   1500                  sens[0] = 32.8f;
   1501                  break;
   1502              case INV_FSR_2000DPS:
   1503                  sens[0] = 16.4f;
   1504                  break;
   1505              default:
   1506                  return -1;
   1507              }
   1508              return 0;
   1509          }
   1510          
   1511          /**
   1512           *  @brief      Get accel sensitivity scale factor.
   1513           *  @param[out] sens    Conversion from hardware units to g's.
   1514           *  @return     0 if successful.
   1515           */
   1516          int mpu_get_accel_sens(unsigned short *sens)
   1517          {
   1518              switch (st.chip_cfg.accel_fsr) {
   1519              case INV_FSR_2G:
   1520                  sens[0] = 16384;
   1521                  break;
   1522              case INV_FSR_4G:
   1523                  sens[0] = 8192;
   1524                  break;
   1525              case INV_FSR_8G:
   1526                  sens[0] = 4096;
   1527                  break;
   1528              case INV_FSR_16G:
   1529                  sens[0] = 2048;
   1530                  break;
   1531              default:
   1532                  return -1;
   1533              }
   1534              if (st.chip_cfg.accel_half)
   1535                  sens[0] >>= 1;
   1536              return 0;
   1537          }
   1538          
   1539          /**
   1540           *  @brief      Get current FIFO configuration.
   1541           *  @e sensors can contain a combination of the following flags:
   1542           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1543           *  \n INV_XYZ_GYRO
   1544           *  \n INV_XYZ_ACCEL
   1545           *  @param[out] sensors Mask of sensors in FIFO.
   1546           *  @return     0 if successful.
   1547           */
   1548          int mpu_get_fifo_config(unsigned char *sensors)
   1549          {
   1550              sensors[0] = st.chip_cfg.fifo_enable;
   1551              return 0;
   1552          }
   1553          
   1554          /**
   1555           *  @brief      Select which sensors are pushed to FIFO.
   1556           *  @e sensors can contain a combination of the following flags:
   1557           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1558           *  \n INV_XYZ_GYRO
   1559           *  \n INV_XYZ_ACCEL
   1560           *  @param[in]  sensors Mask of sensors to push to FIFO.
   1561           *  @return     0 if successful.
   1562           */
   1563          int mpu_configure_fifo(unsigned char sensors)
   1564          {
   1565              unsigned char prev;
   1566              int result = 0;
   1567          
   1568              /* Compass data isn't going into the FIFO. Stop trying. */
   1569              sensors &= ~INV_XYZ_COMPASS;
   1570          
   1571              if (st.chip_cfg.dmp_on)
   1572                  return 0;
   1573              else {
   1574                  if (!(st.chip_cfg.sensors))
   1575                      return -1;
   1576                  prev = st.chip_cfg.fifo_enable;
   1577                  st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
   1578                  if (st.chip_cfg.fifo_enable != sensors)
   1579                      /* You're not getting what you asked for. Some sensors are
   1580                       * asleep.
   1581                       */
   1582                      result = -1;
   1583                  else
   1584                      result = 0;
   1585                  if (sensors || st.chip_cfg.lp_accel_mode)
   1586                      set_int_enable(1);
   1587                  else
   1588                      set_int_enable(0);
   1589                  if (sensors) {
   1590                      if (mpu_reset_fifo()) {
   1591                          st.chip_cfg.fifo_enable = prev;
   1592                          return -1;
   1593                      }
   1594                  }
   1595              }
   1596          
   1597              return result;
   1598          }
   1599          
   1600          /**
   1601           *  @brief      Get current power state.
   1602           *  @param[in]  power_on    1 if turned on, 0 if suspended.
   1603           *  @return     0 if successful.
   1604           */
   1605          int mpu_get_power_state(unsigned char *power_on)
   1606          {
   1607              if (st.chip_cfg.sensors)
   1608                  power_on[0] = 1;
   1609              else
   1610                  power_on[0] = 0;
   1611              return 0;
   1612          }
   1613          
   1614          /**
   1615           *  @brief      Turn specific sensors on/off.
   1616           *  @e sensors can contain a combination of the following flags:
   1617           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1618           *  \n INV_XYZ_GYRO
   1619           *  \n INV_XYZ_ACCEL
   1620           *  \n INV_XYZ_COMPASS
   1621           *  @param[in]  sensors    Mask of sensors to wake.
   1622           *  @return     0 if successful.
   1623           */
   1624          int mpu_set_sensors(unsigned char sensors)
   1625          {
   1626              unsigned char data;
   1627          #ifdef AK89xx_SECONDARY
   1628              unsigned char user_ctrl;
   1629          #endif
   1630          
   1631              if (sensors & INV_XYZ_GYRO)
   1632                  data = INV_CLK_PLL;
   1633              else if (sensors)
   1634                  data = 0;
   1635              else
   1636                  data = BIT_SLEEP;
   1637              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
   1638                  st.chip_cfg.sensors = 0;
   1639                  return -1;
   1640              }
   1641              st.chip_cfg.clk_src = data & ~BIT_SLEEP;
   1642          
   1643              data = 0;
   1644              if (!(sensors & INV_X_GYRO))
   1645                  data |= BIT_STBY_XG;
   1646              if (!(sensors & INV_Y_GYRO))
   1647                  data |= BIT_STBY_YG;
   1648              if (!(sensors & INV_Z_GYRO))
   1649                  data |= BIT_STBY_ZG;
   1650              if (!(sensors & INV_XYZ_ACCEL))
   1651                  data |= BIT_STBY_XYZA;
   1652              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
   1653                  st.chip_cfg.sensors = 0;
   1654                  return -1;
   1655              }
   1656          
   1657              if (sensors && (sensors != INV_XYZ_ACCEL))
   1658                  /* Latched interrupts only used in LP accel mode. */
   1659                  mpu_set_int_latched(0);
   1660          
   1661          #ifdef AK89xx_SECONDARY
   1662          #ifdef AK89xx_BYPASS
   1663              if (sensors & INV_XYZ_COMPASS)
   1664                  mpu_set_bypass(1);
   1665              else
   1666                  mpu_set_bypass(0);
   1667          #else
   1668              if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1669                  return -1;
   1670              /* Handle AKM power management. */
   1671              if (sensors & INV_XYZ_COMPASS) {
   1672                  data = AKM_SINGLE_MEASUREMENT;
   1673                  user_ctrl |= BIT_AUX_IF_EN;
   1674              } else {
   1675                  data = AKM_POWER_DOWN;
   1676                  user_ctrl &= ~BIT_AUX_IF_EN;
   1677              }
   1678              if (st.chip_cfg.dmp_on)
   1679                  user_ctrl |= BIT_DMP_EN;
   1680              else
   1681                  user_ctrl &= ~BIT_DMP_EN;
   1682              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
   1683                  return -1;
   1684              /* Enable/disable I2C master mode. */
   1685              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1686                  return -1;
   1687          #endif
   1688          #endif
   1689          
   1690              st.chip_cfg.sensors = sensors;
   1691              st.chip_cfg.lp_accel_mode = 0;
   1692              delay_ms(50);
   1693              return 0;
   1694          }
   1695          
   1696          /**
   1697           *  @brief      Read the MPU interrupt status registers.
   1698           *  @param[out] status  Mask of interrupt bits.
   1699           *  @return     0 if successful.
   1700           */
   1701          int mpu_get_int_status(short *status)
   1702          {
   1703              unsigned char tmp[2];
   1704              if (!st.chip_cfg.sensors)
   1705                  return -1;
   1706              if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
   1707                  return -1;
   1708              status[0] = (tmp[0] << 8) | tmp[1];
   1709              return 0;
   1710          }
   1711          
   1712          /**
   1713           *  @brief      Get one packet from the FIFO.
   1714           *  If @e sensors does not contain a particular sensor, disregard the data
   1715           *  returned to that pointer.
   1716           *  \n @e sensors can contain a combination of the following flags:
   1717           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1718           *  \n INV_XYZ_GYRO
   1719           *  \n INV_XYZ_ACCEL
   1720           *  \n If the FIFO has no new data, @e sensors will be zero.
   1721           *  \n If the FIFO is disabled, @e sensors will be zero and this function will
   1722           *  return a non-zero error code.
   1723           *  @param[out] gyro        Gyro data in hardware units.
   1724           *  @param[out] accel       Accel data in hardware units.
   1725           *  @param[out] timestamp   Timestamp in milliseconds.
   1726           *  @param[out] sensors     Mask of sensors read from FIFO.
   1727           *  @param[out] more        Number of remaining packets.
   1728           *  @return     0 if successful.
   1729           */
   1730          int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
   1731                  unsigned char *sensors, unsigned char *more)
   1732          {
   1733              /* Assumes maximum packet size is gyro (6) + accel (6). */
   1734              unsigned char data[MAX_PACKET_LENGTH];
   1735              unsigned char packet_size = 0;
   1736              unsigned short fifo_count, index = 0;
   1737          
   1738              if (st.chip_cfg.dmp_on)
   1739                  return -1;
   1740          
   1741              sensors[0] = 0;
   1742              if (!st.chip_cfg.sensors)
   1743                  return -1;
   1744              if (!st.chip_cfg.fifo_enable)
   1745                  return -1;
   1746          
   1747              if (st.chip_cfg.fifo_enable & INV_X_GYRO)
   1748                  packet_size += 2;
   1749              if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
   1750                  packet_size += 2;
   1751              if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
   1752                  packet_size += 2;
   1753              if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
   1754                  packet_size += 6;
   1755          
   1756              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   1757                  return -1;
   1758              fifo_count = (data[0] << 8) | data[1];
   1759              if (fifo_count < packet_size)
   1760                  return 0;
   1761          //    log_i("FIFO count: %hd\n", fifo_count);
   1762              if (fifo_count > (st.hw->max_fifo >> 1)) {
   1763                  /* FIFO is 50% full, better check overflow bit. */
   1764                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
   1765                      return -1;
   1766                  if (data[0] & BIT_FIFO_OVERFLOW) {
   1767                      mpu_reset_fifo();
   1768                      return -2;
   1769                  }
   1770              }
   1771              get_ms((unsigned long*)timestamp);
   1772          
   1773              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
   1774                  return -1;
   1775              more[0] = fifo_count / packet_size - 1;
   1776              sensors[0] = 0;
   1777          
   1778              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
   1779                  accel[0] = (data[index+0] << 8) | data[index+1];
   1780                  accel[1] = (data[index+2] << 8) | data[index+3];
   1781                  accel[2] = (data[index+4] << 8) | data[index+5];
   1782                  sensors[0] |= INV_XYZ_ACCEL;
   1783                  index += 6;
   1784              }
   1785              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
   1786                  gyro[0] = (data[index+0] << 8) | data[index+1];
   1787                  sensors[0] |= INV_X_GYRO;
   1788                  index += 2;
   1789              }
   1790              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
   1791                  gyro[1] = (data[index+0] << 8) | data[index+1];
   1792                  sensors[0] |= INV_Y_GYRO;
   1793                  index += 2;
   1794              }
   1795              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
   1796                  gyro[2] = (data[index+0] << 8) | data[index+1];
   1797                  sensors[0] |= INV_Z_GYRO;
   1798                  index += 2;
   1799              }
   1800          
   1801              return 0;
   1802          }
   1803          
   1804          /**
   1805           *  @brief      Get one unparsed packet from the FIFO.
   1806           *  This function should be used if the packet is to be parsed elsewhere.
   1807           *  @param[in]  length  Length of one FIFO packet.
   1808           *  @param[in]  data    FIFO packet.
   1809           *  @param[in]  more    Number of remaining packets.
   1810           */
   1811          int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
   1812              unsigned char *more)
   1813          {
   1814              unsigned char tmp[2];
   1815              unsigned short fifo_count;
   1816              if (!st.chip_cfg.dmp_on)
   1817                  return -1;
   1818              if (!st.chip_cfg.sensors)
   1819                  return -1;
   1820          
   1821              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
   1822                  return -1;
   1823              fifo_count = (tmp[0] << 8) | tmp[1];
   1824              if (fifo_count < length) {
   1825                  more[0] = 0;
   1826                  return -1;
   1827              }
   1828              if (fifo_count > (st.hw->max_fifo >> 1)) {
   1829                  /* FIFO is 50% full, better check overflow bit. */
   1830                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
   1831                      return -1;
   1832                  if (tmp[0] & BIT_FIFO_OVERFLOW) {
   1833                      mpu_reset_fifo();
   1834                      return -2;
   1835                  }
   1836              }
   1837          
   1838              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
   1839                  return -1;
   1840              more[0] = fifo_count / length - 1;
   1841              return 0;
   1842          }
   1843          
   1844          /**
   1845           *  @brief      Set device to bypass mode.
   1846           *  @param[in]  bypass_on   1 to enable bypass mode.
   1847           *  @return     0 if successful.
   1848           */
   1849          int mpu_set_bypass(unsigned char bypass_on)
   1850          {
   1851              unsigned char tmp;
   1852          
   1853              if (st.chip_cfg.bypass_mode == bypass_on)
   1854                  return 0;
   1855          
   1856              if (bypass_on) {
   1857                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   1858                      return -1;
   1859                  tmp &= ~BIT_AUX_IF_EN;
   1860                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   1861                      return -1;
   1862                  delay_ms(3);
   1863                  tmp = BIT_BYPASS_EN;
   1864                  if (st.chip_cfg.active_low_int)
   1865                      tmp |= BIT_ACTL;
   1866                  if (st.chip_cfg.latched_int)
   1867                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   1868                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   1869                      return -1;
   1870              } else {
   1871                  /* Enable I2C master mode if compass is being used. */
   1872                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   1873                      return -1;
   1874                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   1875                      tmp |= BIT_AUX_IF_EN;
   1876                  else
   1877                      tmp &= ~BIT_AUX_IF_EN;
   1878                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   1879                      return -1;
   1880                  delay_ms(3);
   1881                  if (st.chip_cfg.active_low_int)
   1882                      tmp = BIT_ACTL;
   1883                  else
   1884                      tmp = 0;
   1885                  if (st.chip_cfg.latched_int)
   1886                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   1887                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   1888                      return -1;
   1889              }
   1890              st.chip_cfg.bypass_mode = bypass_on;
   1891              return 0;
   1892          }
   1893          
   1894          /**
   1895           *  @brief      Set interrupt level.
   1896           *  @param[in]  active_low  1 for active low, 0 for active high.
   1897           *  @return     0 if successful.
   1898           */
   1899          int mpu_set_int_level(unsigned char active_low)
   1900          {
   1901              st.chip_cfg.active_low_int = active_low;
   1902              return 0;
   1903          }
   1904          
   1905          /**
   1906           *  @brief      Enable latched interrupts.
   1907           *  Any MPU register will clear the interrupt.
   1908           *  @param[in]  enable  1 to enable, 0 to disable.
   1909           *  @return     0 if successful.
   1910           */
   1911          int mpu_set_int_latched(unsigned char enable)
   1912          {
   1913              unsigned char tmp;
   1914              if (st.chip_cfg.latched_int == enable)
   1915                  return 0;
   1916          
   1917              if (enable)
   1918                  tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
   1919              else
   1920                  tmp = 0;
   1921              if (st.chip_cfg.bypass_mode)
   1922                  tmp |= BIT_BYPASS_EN;
   1923              if (st.chip_cfg.active_low_int)
   1924                  tmp |= BIT_ACTL;
   1925              if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   1926                  return -1;
   1927              st.chip_cfg.latched_int = enable;
   1928              return 0;
   1929          }
   1930          
   1931          #ifdef MPU6050
   1932          static int get_accel_prod_shift(float *st_shift)
   1933          {
   1934              unsigned char tmp[4], shift_code[3], ii;
   1935          
   1936              if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
   1937                  return 0x07;
   1938          
   1939              shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
   1940              shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
   1941              shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
   1942              for (ii = 0; ii < 3; ii++) {
   1943                  if (!shift_code[ii]) {
   1944                      st_shift[ii] = 0.f;
   1945                      continue;
   1946                  }
   1947                  /* Equivalent to..
   1948                   * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
   1949                   */
   1950                  st_shift[ii] = 0.34f;
   1951                  while (--shift_code[ii])
   1952                      st_shift[ii] *= 1.034f;
   1953              }
   1954              return 0;
   1955          }
   1956          
   1957          static int accel_self_test(long *bias_regular, long *bias_st)
   1958          {
   1959              int jj, result = 0;
   1960              float st_shift[3], st_shift_cust, st_shift_var;
   1961          
   1962              get_accel_prod_shift(st_shift);
   1963              for(jj = 0; jj < 3; jj++) {
   1964                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   1965                  if (st_shift[jj]) {
   1966                      st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
   1967                      if (fabs(st_shift_var) > test.max_accel_var)
   1968                          result |= 1 << jj;
   1969                  } else if ((st_shift_cust < test.min_g) ||
   1970                      (st_shift_cust > test.max_g))
   1971                      result |= 1 << jj;
   1972              }
   1973          
   1974              return result;
   1975          }
   1976          
   1977          static int gyro_self_test(long *bias_regular, long *bias_st)
   1978          {
   1979              int jj, result = 0;
   1980              unsigned char tmp[3];
   1981              float st_shift, st_shift_cust, st_shift_var;
   1982          
   1983              if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
   1984                  return 0x07;
   1985          
   1986              tmp[0] &= 0x1F;
   1987              tmp[1] &= 0x1F;
   1988              tmp[2] &= 0x1F;
   1989          
   1990              for (jj = 0; jj < 3; jj++) {
   1991                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   1992                  if (tmp[jj]) {
   1993                      st_shift = 3275.f / test.gyro_sens;
   1994                      while (--tmp[jj])
   1995                          st_shift *= 1.046f;
   1996                      st_shift_var = st_shift_cust / st_shift - 1.f;
   1997                      if (fabs(st_shift_var) > test.max_gyro_var)
   1998                          result |= 1 << jj;
   1999                  } else if ((st_shift_cust < test.min_dps) ||
   2000                      (st_shift_cust > test.max_dps))
   2001                      result |= 1 << jj;
   2002              }
   2003              return result;
   2004          }
   2005          
   2006          #endif 
   2007          #ifdef AK89xx_SECONDARY
   2008          static int compass_self_test(void)
   2009          {
   2010              unsigned char tmp[6];
   2011              unsigned char tries = 10;
   2012              int result = 0x07;
   2013              short data;
   2014          
   2015              mpu_set_bypass(1);
   2016          
   2017              tmp[0] = AKM_POWER_DOWN;
   2018              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   2019                  return 0x07;
   2020              tmp[0] = AKM_BIT_SELF_TEST;
   2021              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
   2022                  goto AKM_restore;
   2023              tmp[0] = AKM_MODE_SELF_TEST;
   2024              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   2025                  goto AKM_restore;
   2026          
   2027              do {
   2028                  delay_ms(10);
   2029                  if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
   2030                      goto AKM_restore;
   2031                  if (tmp[0] & AKM_DATA_READY)
   2032                      break;
   2033              } while (tries--);
   2034              if (!(tmp[0] & AKM_DATA_READY))
   2035                  goto AKM_restore;
   2036          
   2037              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
   2038                  goto AKM_restore;
   2039          
   2040              result = 0;
   2041          #if defined MPU9150
   2042              data = (short)(tmp[1] << 8) | tmp[0];
   2043              if ((data > 100) || (data < -100))
   2044                  result |= 0x01;
   2045              data = (short)(tmp[3] << 8) | tmp[2];
   2046              if ((data > 100) || (data < -100))
   2047                  result |= 0x02;
   2048              data = (short)(tmp[5] << 8) | tmp[4];
   2049              if ((data > -300) || (data < -1000))
   2050                  result |= 0x04;
   2051          #elif defined MPU9250
   2052              data = (short)(tmp[1] << 8) | tmp[0];
   2053              if ((data > 200) || (data < -200))  
   2054                  result |= 0x01;
   2055              data = (short)(tmp[3] << 8) | tmp[2];
   2056              if ((data > 200) || (data < -200))  
   2057                  result |= 0x02;
   2058              data = (short)(tmp[5] << 8) | tmp[4];
   2059              if ((data > -800) || (data < -3200))  
   2060                  result |= 0x04;
   2061          #endif
   2062          AKM_restore:
   2063              tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
   2064              i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
   2065              tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
   2066              i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
   2067              mpu_set_bypass(0);
   2068              return result;
   2069          }
   2070          #endif
   2071          
   2072          static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
   2073          {
   2074              unsigned char data[MAX_PACKET_LENGTH];
   2075              unsigned char packet_count, ii;
   2076              unsigned short fifo_count;
   2077          
   2078              data[0] = 0x01;
   2079              data[1] = 0;
   2080              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   2081                  return -1;
   2082              delay_ms(200);
   2083              data[0] = 0;
   2084              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   2085                  return -1;
   2086              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   2087                  return -1;
   2088              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   2089                  return -1;
   2090              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   2091                  return -1;
   2092              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   2093                  return -1;
   2094              data[0] = BIT_FIFO_RST | BIT_DMP_RST;
   2095              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   2096                  return -1;
   2097              delay_ms(15);
   2098              data[0] = st.test->reg_lpf;
   2099              if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   2100                  return -1;
   2101              data[0] = st.test->reg_rate_div;
   2102              if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
   2103                  return -1;
   2104              if (hw_test)
   2105                  data[0] = st.test->reg_gyro_fsr | 0xE0;
   2106              else
   2107                  data[0] = st.test->reg_gyro_fsr;
   2108              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
   2109                  return -1;
   2110          
   2111              if (hw_test)
   2112                  data[0] = st.test->reg_accel_fsr | 0xE0;
   2113              else
   2114                  data[0] = test.reg_accel_fsr;
   2115              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   2116                  return -1;
   2117              if (hw_test)
   2118                  delay_ms(200);
   2119          
   2120              /* Fill FIFO for test.wait_ms milliseconds. */
   2121              data[0] = BIT_FIFO_EN;
   2122              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   2123                  return -1;
   2124          
   2125              data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
   2126              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   2127                  return -1;
   2128              delay_ms(test.wait_ms);
   2129              data[0] = 0;
   2130              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   2131                  return -1;
   2132          
   2133              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   2134                  return -1;
   2135          
   2136              fifo_count = (data[0] << 8) | data[1];
   2137              packet_count = fifo_count / MAX_PACKET_LENGTH;
   2138              gyro[0] = gyro[1] = gyro[2] = 0;
   2139              accel[0] = accel[1] = accel[2] = 0;
   2140          
   2141              for (ii = 0; ii < packet_count; ii++) {
   2142                  short accel_cur[3], gyro_cur[3];
   2143                  if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
   2144                      return -1;
   2145                  accel_cur[0] = ((short)data[0] << 8) | data[1];
   2146                  accel_cur[1] = ((short)data[2] << 8) | data[3];
   2147                  accel_cur[2] = ((short)data[4] << 8) | data[5];
   2148                  accel[0] += (long)accel_cur[0];
   2149                  accel[1] += (long)accel_cur[1];
   2150                  accel[2] += (long)accel_cur[2];
   2151                  gyro_cur[0] = (((short)data[6] << 8) | data[7]);
   2152                  gyro_cur[1] = (((short)data[8] << 8) | data[9]);
   2153                  gyro_cur[2] = (((short)data[10] << 8) | data[11]);
   2154                  gyro[0] += (long)gyro_cur[0];
   2155                  gyro[1] += (long)gyro_cur[1];
   2156                  gyro[2] += (long)gyro_cur[2];
   2157              }
   2158          #ifdef EMPL_NO_64BIT
   2159              gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
   2160              gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
   2161              gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
   2162              if (has_accel) {
   2163                  accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
   2164                      packet_count);
   2165                  accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
   2166                      packet_count);
   2167                  accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
   2168                      packet_count);
   2169                  /* Don't remove gravity! */
   2170                  accel[2] -= 65536L;
   2171              }
   2172          #else
   2173              gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
   2174              gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
   2175              gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
   2176              accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
   2177                  packet_count);
   2178              accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
   2179                  packet_count);
   2180              accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
   2181                  packet_count);
   2182              /* Don't remove gravity! */
   2183              if (accel[2] > 0L)
   2184                  accel[2] -= 65536L;
   2185              else
   2186                  accel[2] += 65536L;
   2187          #endif
   2188          
   2189              return 0;
   2190          }
   2191          
   2192          #ifdef MPU6500
   2193          #define REG_6500_XG_ST_DATA     0x0
   2194          #define REG_6500_XA_ST_DATA     0xD
   2195          static const unsigned short mpu_6500_st_tb[256] = {
   2196          	2620,2646,2672,2699,2726,2753,2781,2808, //7
   2197          	2837,2865,2894,2923,2952,2981,3011,3041, //15
   2198          	3072,3102,3133,3165,3196,3228,3261,3293, //23
   2199          	3326,3359,3393,3427,3461,3496,3531,3566, //31
   2200          	3602,3638,3674,3711,3748,3786,3823,3862, //39
   2201          	3900,3939,3979,4019,4059,4099,4140,4182, //47
   2202          	4224,4266,4308,4352,4395,4439,4483,4528, //55
   2203          	4574,4619,4665,4712,4759,4807,4855,4903, //63
   2204          	4953,5002,5052,5103,5154,5205,5257,5310, //71
   2205          	5363,5417,5471,5525,5581,5636,5693,5750, //79
   2206          	5807,5865,5924,5983,6043,6104,6165,6226, //87
   2207          	6289,6351,6415,6479,6544,6609,6675,6742, //95
   2208          	6810,6878,6946,7016,7086,7157,7229,7301, //103
   2209          	7374,7448,7522,7597,7673,7750,7828,7906, //111
   2210          	7985,8065,8145,8227,8309,8392,8476,8561, //119
   2211          	8647,8733,8820,8909,8998,9088,9178,9270,
   2212          	9363,9457,9551,9647,9743,9841,9939,10038,
   2213          	10139,10240,10343,10446,10550,10656,10763,10870,
   2214          	10979,11089,11200,11312,11425,11539,11654,11771,
   2215          	11889,12008,12128,12249,12371,12495,12620,12746,
   2216          	12874,13002,13132,13264,13396,13530,13666,13802,
   2217          	13940,14080,14221,14363,14506,14652,14798,14946,
   2218          	15096,15247,15399,15553,15709,15866,16024,16184,
   2219          	16346,16510,16675,16842,17010,17180,17352,17526,
   2220          	17701,17878,18057,18237,18420,18604,18790,18978,
   2221          	19167,19359,19553,19748,19946,20145,20347,20550,
   2222          	20756,20963,21173,21385,21598,21814,22033,22253,
   2223          	22475,22700,22927,23156,23388,23622,23858,24097,
   2224          	24338,24581,24827,25075,25326,25579,25835,26093,
   2225          	26354,26618,26884,27153,27424,27699,27976,28255,
   2226          	28538,28823,29112,29403,29697,29994,30294,30597,
   2227          	30903,31212,31524,31839,32157,32479,32804,33132
   2228          };
   2229          static int accel_6500_self_test(long *bias_regular, long *bias_st, int debug)
   2230          {
   2231              int i, result = 0, otp_value_zero = 0;
   2232              float accel_st_al_min, accel_st_al_max;
   2233              float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], accel_offset_max;
   2234              unsigned char regs[3];
   2235              if (i2c_read(st.hw->addr, REG_6500_XA_ST_DATA, 3, regs)) {
   2236              	if(debug)
   2237              		log_i("Reading OTP Register Error.\n");
   2238              	return 0x07;
   2239              }
   2240              if(debug)
   2241              	log_i("Accel OTP:%d, %d, %d\n", regs[0], regs[1], regs[2]);
   2242          	for (i = 0; i < 3; i++) {
   2243          		if (regs[i] != 0) {
   2244          			ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
   2245          			ct_shift_prod[i] *= 65536.f;
   2246          			ct_shift_prod[i] /= test.accel_sens;
   2247          		}
   2248          		else {
   2249          			ct_shift_prod[i] = 0;
   2250          			otp_value_zero = 1;
   2251          		}
   2252          	}
   2253          	if(otp_value_zero == 0) {
   2254          		if(debug)
   2255          			log_i("ACCEL:CRITERIA A\n");
   2256          		for (i = 0; i < 3; i++) {
   2257          			st_shift_cust[i] = bias_st[i] - bias_regular[i];
   2258          			if(debug) {
   2259          				log_i("Bias_Shift=%7.4f, Bias_Reg=%7.4f, Bias_HWST=%7.4f\r\n",
   2260          						st_shift_cust[i]/1.f, bias_regular[i]/1.f,
   2261          						bias_st[i]/1.f);
   2262          				log_i("OTP value: %7.4f\r\n", ct_shift_prod[i]/1.f);
   2263          			}
   2264          
   2265          			st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i] - 1.f;
   2266          
   2267          			if(debug)
   2268          				log_i("ratio=%7.4f, threshold=%7.4f\r\n", st_shift_ratio[i]/1.f,
   2269          							test.max_accel_var/1.f);
   2270          
   2271          			if (fabs(st_shift_ratio[i]) > test.max_accel_var) {
   2272          				if(debug)
   2273          					log_i("ACCEL Fail Axis = %d\n", i);
   2274          				result |= 1 << i;	//Error condition
   2275          			}
   2276          		}
   2277          	}
   2278          	else {
   2279          		/* Self Test Pass/Fail Criteria B */
   2280          		accel_st_al_min = test.min_g * 65536.f;
   2281          		accel_st_al_max = test.max_g * 65536.f;
   2282          
   2283          		if(debug) {
   2284          			log_i("ACCEL:CRITERIA B\r\n");
   2285          			log_i("Min MG: %7.4f\r\n", accel_st_al_min/1.f);
   2286          			log_i("Max MG: %7.4f\r\n", accel_st_al_max/1.f);
   2287          		}
   2288          
   2289          		for (i = 0; i < 3; i++) {
   2290          			st_shift_cust[i] = bias_st[i] - bias_regular[i];
   2291          
   2292          			if(debug)
   2293          				log_i("Bias_shift=%7.4f, st=%7.4f, reg=%7.4f\n", st_shift_cust[i]/1.f, bias_st[i]/1.f, bias_regular[i]/1.f);
   2294          			if(st_shift_cust[i] < accel_st_al_min || st_shift_cust[i] > accel_st_al_max) {
   2295          				if(debug)
   2296          					log_i("Accel FAIL axis:%d <= 225mg or >= 675mg\n", i);
   2297          				result |= 1 << i;	//Error condition
   2298          			}
   2299          		}
   2300          	}
   2301          
   2302          	if(result == 0) {
   2303          	/* Self Test Pass/Fail Criteria C */
   2304          		accel_offset_max = test.max_g_offset * 65536.f;
   2305          		if(debug)
   2306          			log_i("Accel:CRITERIA C: bias less than %7.4f\n", accel_offset_max/1.f);
   2307          		for (i = 0; i < 3; i++) {
   2308          			if(fabs(bias_regular[i]) > accel_offset_max) {
   2309          				if(debug)
   2310          					log_i("FAILED: Accel axis:%d = %ld > 500mg\n", i, bias_regular[i]);
   2311          				result |= 1 << i;	//Error condition
   2312          			}
   2313          		}
   2314          	}
   2315          
   2316              return result;
   2317          }
   2318          
   2319          static int gyro_6500_self_test(long *bias_regular, long *bias_st, int debug)
   2320          {
   2321              int i, result = 0, otp_value_zero = 0;
   2322              float gyro_st_al_max;
   2323              float st_shift_cust[3], st_shift_ratio[3], ct_shift_prod[3], gyro_offset_max;
   2324              unsigned char regs[3];
   2325          
   2326              if (i2c_read(st.hw->addr, REG_6500_XG_ST_DATA, 3, regs)) {
   2327              	if(debug)
   2328              		log_i("Reading OTP Register Error.\n");
   2329                  return 0x07;
   2330              }
   2331          
   2332              if(debug)
   2333              	log_i("Gyro OTP:%d, %d, %d\r\n", regs[0], regs[1], regs[2]);
   2334          
   2335          	for (i = 0; i < 3; i++) {
   2336          		if (regs[i] != 0) {
   2337          			ct_shift_prod[i] = mpu_6500_st_tb[regs[i] - 1];
   2338          			ct_shift_prod[i] *= 65536.f;
   2339          			ct_shift_prod[i] /= test.gyro_sens;
   2340          		}
   2341          		else {
   2342          			ct_shift_prod[i] = 0;
   2343          			otp_value_zero = 1;
   2344          		}
   2345          	}
   2346          
   2347          	if(otp_value_zero == 0) {
   2348          		if(debug)
   2349          			log_i("GYRO:CRITERIA A\n");
   2350          		/* Self Test Pass/Fail Criteria A */
   2351          		for (i = 0; i < 3; i++) {
   2352          			st_shift_cust[i] = bias_st[i] - bias_regular[i];
   2353          
   2354          			if(debug) {
   2355          				log_i("Bias_Shift=%7.4f, Bias_Reg=%7.4f, Bias_HWST=%7.4f\r\n",
   2356          						st_shift_cust[i]/1.f, bias_regular[i]/1.f,
   2357          						bias_st[i]/1.f);
   2358          				log_i("OTP value: %7.4f\r\n", ct_shift_prod[i]/1.f);
   2359          			}
   2360          
   2361          			st_shift_ratio[i] = st_shift_cust[i] / ct_shift_prod[i];
   2362          
   2363          			if(debug)
   2364          				log_i("ratio=%7.4f, threshold=%7.4f\r\n", st_shift_ratio[i]/1.f,
   2365          							test.max_gyro_var/1.f);
   2366          
   2367          			if (fabs(st_shift_ratio[i]) < test.max_gyro_var) {
   2368          				if(debug)
   2369          					log_i("Gyro Fail Axis = %d\n", i);
   2370          				result |= 1 << i;	//Error condition
   2371          			}
   2372          		}
   2373          	}
   2374          	else {
   2375          		/* Self Test Pass/Fail Criteria B */
   2376          		gyro_st_al_max = test.max_dps * 65536.f;
   2377          
   2378          		if(debug) {
   2379          			log_i("GYRO:CRITERIA B\r\n");
   2380          			log_i("Max DPS: %7.4f\r\n", gyro_st_al_max/1.f);
   2381          		}
   2382          
   2383          		for (i = 0; i < 3; i++) {
   2384          			st_shift_cust[i] = bias_st[i] - bias_regular[i];
   2385          
   2386          			if(debug)
   2387          				log_i("Bias_shift=%7.4f, st=%7.4f, reg=%7.4f\n", st_shift_cust[i]/1.f, bias_st[i]/1.f, bias_regular[i]/1.f);
   2388          			if(st_shift_cust[i] < gyro_st_al_max) {
   2389          				if(debug)
   2390          					log_i("GYRO FAIL axis:%d greater than 60dps\n", i);
   2391          				result |= 1 << i;	//Error condition
   2392          			}
   2393          		}
   2394          	}
   2395          
   2396          	if(result == 0) {
   2397          	/* Self Test Pass/Fail Criteria C */
   2398          		gyro_offset_max = test.min_dps * 65536.f;
   2399          		if(debug)
   2400          			log_i("Gyro:CRITERIA C: bias less than %7.4f\n", gyro_offset_max/1.f);
   2401          		for (i = 0; i < 3; i++) {
   2402          			if(fabs(bias_regular[i]) > gyro_offset_max) {
   2403          				if(debug)
   2404          					log_i("FAILED: Gyro axis:%d = %ld > 20dps\n", i, bias_regular[i]);
   2405          				result |= 1 << i;	//Error condition
   2406          			}
   2407          		}
   2408          	}
   2409              return result;
   2410          }
   2411          
   2412          static int get_st_6500_biases(long *gyro, long *accel, unsigned char hw_test, int debug)
   2413          {
   2414              unsigned char data[HWST_MAX_PACKET_LENGTH];
   2415              unsigned char packet_count, ii;
   2416              unsigned short fifo_count;
   2417              int s = 0, read_size = 0, ind;
   2418          
   2419              data[0] = 0x01;
   2420              data[1] = 0;
   2421              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   2422                  return -1;
   2423              delay_ms(200);
   2424              data[0] = 0;
   2425              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   2426                  return -1;
   2427              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   2428                  return -1;
   2429              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   2430                  return -1;
   2431              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   2432                  return -1;
   2433              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   2434                  return -1;
   2435              data[0] = BIT_FIFO_RST | BIT_DMP_RST;
   2436              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   2437                  return -1;
   2438              delay_ms(15);
   2439              data[0] = st.test->reg_lpf;
   2440              if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   2441                  return -1;
   2442              data[0] = st.test->reg_rate_div;
   2443              if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
   2444                  return -1;
   2445              if (hw_test)
   2446                  data[0] = st.test->reg_gyro_fsr | 0xE0;
   2447              else
   2448                  data[0] = st.test->reg_gyro_fsr;
   2449              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
   2450                  return -1;
   2451          
   2452              if (hw_test)
   2453                  data[0] = st.test->reg_accel_fsr | 0xE0;
   2454              else
   2455                  data[0] = test.reg_accel_fsr;
   2456              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   2457                  return -1;
   2458          
   2459              delay_ms(test.wait_ms);  //wait 200ms for sensors to stabilize
   2460          
   2461              /* Enable FIFO */
   2462              data[0] = BIT_FIFO_EN;
   2463              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   2464                  return -1;
   2465              data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
   2466              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   2467                  return -1;
   2468          
   2469              //initialize the bias return values
   2470              gyro[0] = gyro[1] = gyro[2] = 0;
   2471              accel[0] = accel[1] = accel[2] = 0;
   2472          
   2473              if(debug)
   2474              	log_i("Starting Bias Loop Reads\n");
   2475          
   2476              //start reading samples
   2477              while (s < test.packet_thresh) {
   2478              	delay_ms(test.sample_wait_ms); //wait 10ms to fill FIFO
   2479          		if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   2480          			return -1;
   2481          		fifo_count = (data[0] << 8) | data[1];
   2482          		packet_count = fifo_count / MAX_PACKET_LENGTH;
   2483          		if ((test.packet_thresh - s) < packet_count)
   2484          		            packet_count = test.packet_thresh - s;
   2485          		read_size = packet_count * MAX_PACKET_LENGTH;
   2486          
   2487          		//burst read from FIFO
   2488          		if (i2c_read(st.hw->addr, st.reg->fifo_r_w, read_size, data))
   2489          						return -1;
   2490          		ind = 0;
   2491          		for (ii = 0; ii < packet_count; ii++) {
   2492          			short accel_cur[3], gyro_cur[3];
   2493          			accel_cur[0] = ((short)data[ind + 0] << 8) | data[ind + 1];
   2494          			accel_cur[1] = ((short)data[ind + 2] << 8) | data[ind + 3];
   2495          			accel_cur[2] = ((short)data[ind + 4] << 8) | data[ind + 5];
   2496          			accel[0] += (long)accel_cur[0];
   2497          			accel[1] += (long)accel_cur[1];
   2498          			accel[2] += (long)accel_cur[2];
   2499          			gyro_cur[0] = (((short)data[ind + 6] << 8) | data[ind + 7]);
   2500          			gyro_cur[1] = (((short)data[ind + 8] << 8) | data[ind + 9]);
   2501          			gyro_cur[2] = (((short)data[ind + 10] << 8) | data[ind + 11]);
   2502          			gyro[0] += (long)gyro_cur[0];
   2503          			gyro[1] += (long)gyro_cur[1];
   2504          			gyro[2] += (long)gyro_cur[2];
   2505          			ind += MAX_PACKET_LENGTH;
   2506          		}
   2507          		s += packet_count;
   2508              }
   2509          
   2510              if(debug)
   2511              	log_i("Samples: %d\n", s);
   2512          
   2513              //stop FIFO
   2514              data[0] = 0;
   2515              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   2516                  return -1;
   2517          
   2518              gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / s);
   2519              gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / s);
   2520              gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / s);
   2521              accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens / s);
   2522              accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens / s);
   2523              accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens / s);
   2524              /* remove gravity from bias calculation */
   2525              if (accel[2] > 0L)
   2526                  accel[2] -= 65536L;
   2527              else
   2528                  accel[2] += 65536L;
   2529          
   2530          
   2531              if(debug) {
   2532              	log_i("Accel offset data HWST bit=%d: %7.4f %7.4f %7.4f\r\n", hw_test, accel[0]/65536.f, accel[1]/65536.f, accel[2]/65536.f);
   2533              	log_i("Gyro offset data HWST bit=%d: %7.4f %7.4f %7.4f\r\n", hw_test, gyro[0]/65536.f, gyro[1]/65536.f, gyro[2]/65536.f);
   2534              }
   2535          
   2536              return 0;
   2537          }
   2538          /**
   2539           *  @brief      Trigger gyro/accel/compass self-test for MPU6500/MPU9250
   2540           *  On success/error, the self-test returns a mask representing the sensor(s)
   2541           *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
   2542           *  a zero (0) indicates a failure.
   2543           *
   2544           *  \n The mask is defined as follows:
   2545           *  \n Bit 0:   Gyro.
   2546           *  \n Bit 1:   Accel.
   2547           *  \n Bit 2:   Compass.
   2548           *
   2549           *  @param[out] gyro        Gyro biases in q16 format.
   2550           *  @param[out] accel       Accel biases (if applicable) in q16 format.
   2551           *  @param[in]  debug       Debug flag used to print out more detailed logs. Must first set up logging in Motion Driver.
   2552           *  @return     Result mask (see above).
   2553           */
   2554          int mpu_run_6500_self_test(long *gyro, long *accel, unsigned char debug)
   2555          {
   2556              const unsigned char tries = 2;
   2557              long gyro_st[3], accel_st[3];
   2558              unsigned char accel_result, gyro_result;
   2559          #ifdef AK89xx_SECONDARY
   2560              unsigned char compass_result;
   2561          #endif
   2562              int ii;
   2563          
   2564              int result;
   2565              unsigned char accel_fsr, fifo_sensors, sensors_on;
   2566              unsigned short gyro_fsr, sample_rate, lpf;
   2567              unsigned char dmp_was_on;
   2568          
   2569          
   2570          
   2571              if(debug)
   2572              	log_i("Starting MPU6500 HWST!\r\n");
   2573          
   2574              if (st.chip_cfg.dmp_on) {
   2575                  mpu_set_dmp_state(0);
   2576                  dmp_was_on = 1;
   2577              } else
   2578                  dmp_was_on = 0;
   2579          
   2580              /* Get initial settings. */
   2581              mpu_get_gyro_fsr(&gyro_fsr);
   2582              mpu_get_accel_fsr(&accel_fsr);
   2583              mpu_get_lpf(&lpf);
   2584              mpu_get_sample_rate(&sample_rate);
   2585              sensors_on = st.chip_cfg.sensors;
   2586              mpu_get_fifo_config(&fifo_sensors);
   2587          
   2588              if(debug)
   2589              	log_i("Retrieving Biases\r\n");
   2590          
   2591              for (ii = 0; ii < tries; ii++)
   2592                  if (!get_st_6500_biases(gyro, accel, 0, debug))
   2593                      break;
   2594              if (ii == tries) {
   2595                  /* If we reach this point, we most likely encountered an I2C error.
   2596                   * We'll just report an error for all three sensors.
   2597                   */
   2598                  if(debug)
   2599                  	log_i("Retrieving Biases Error - possible I2C error\n");
   2600          
   2601                  result = 0;
   2602                  goto restore;
   2603              }
   2604          
   2605              if(debug)
   2606              	log_i("Retrieving ST Biases\n");
   2607          
   2608              for (ii = 0; ii < tries; ii++)
   2609                  if (!get_st_6500_biases(gyro_st, accel_st, 1, debug))
   2610                      break;
   2611              if (ii == tries) {
   2612          
   2613                  if(debug)
   2614                  	log_i("Retrieving ST Biases Error - possible I2C error\n");
   2615          
   2616                  /* Again, probably an I2C error. */
   2617                  result = 0;
   2618                  goto restore;
   2619              }
   2620          
   2621              accel_result = accel_6500_self_test(accel, accel_st, debug);
   2622              if(debug)
   2623              	log_i("Accel Self Test Results: %d\n", accel_result);
   2624          
   2625              gyro_result = gyro_6500_self_test(gyro, gyro_st, debug);
   2626              if(debug)
   2627              	log_i("Gyro Self Test Results: %d\n", gyro_result);
   2628          
   2629              result = 0;
   2630              if (!gyro_result)
   2631                  result |= 0x01;
   2632              if (!accel_result)
   2633                  result |= 0x02;
   2634          
   2635          #ifdef AK89xx_SECONDARY
   2636              compass_result = compass_self_test();
   2637              if(debug)
   2638              	log_i("Compass Self Test Results: %d\n", compass_result);
   2639              if (!compass_result)
   2640                  result |= 0x04;
   2641          #else
   2642              result |= 0x04;
   2643          #endif
   2644          restore:
   2645          	if(debug)
   2646          		log_i("Exiting HWST\n");
   2647          	/* Set to invalid values to ensure no I2C writes are skipped. */
   2648          	st.chip_cfg.gyro_fsr = 0xFF;
   2649          	st.chip_cfg.accel_fsr = 0xFF;
   2650          	st.chip_cfg.lpf = 0xFF;
   2651          	st.chip_cfg.sample_rate = 0xFFFF;
   2652          	st.chip_cfg.sensors = 0xFF;
   2653          	st.chip_cfg.fifo_enable = 0xFF;
   2654          	st.chip_cfg.clk_src = INV_CLK_PLL;
   2655          	mpu_set_gyro_fsr(gyro_fsr);
   2656          	mpu_set_accel_fsr(accel_fsr);
   2657          	mpu_set_lpf(lpf);
   2658          	mpu_set_sample_rate(sample_rate);
   2659          	mpu_set_sensors(sensors_on);
   2660          	mpu_configure_fifo(fifo_sensors);
   2661          
   2662          	if (dmp_was_on)
   2663          		mpu_set_dmp_state(1);
   2664          
   2665          	return result;
   2666          }
   2667          #endif
   2668           /*
   2669           *  \n This function must be called with the device either face-up or face-down
   2670           *  (z-axis is parallel to gravity).
   2671           *  @param[out] gyro        Gyro biases in q16 format.
   2672           *  @param[out] accel       Accel biases (if applicable) in q16 format.
   2673           *  @return     Result mask (see above).
   2674           */
   2675          int mpu_run_self_test(long *gyro, long *accel)
   2676          {
   2677          #ifdef MPU6050
   2678              const unsigned char tries = 2;
   2679              long gyro_st[3], accel_st[3];
   2680              unsigned char accel_result, gyro_result;
   2681          #ifdef AK89xx_SECONDARY
   2682              unsigned char compass_result;
   2683          #endif
   2684              int ii;
   2685          #endif
   2686              int result;
   2687              unsigned char accel_fsr, fifo_sensors, sensors_on;
   2688              unsigned short gyro_fsr, sample_rate, lpf;
   2689              unsigned char dmp_was_on;
   2690          
   2691              if (st.chip_cfg.dmp_on) {
   2692                  mpu_set_dmp_state(0);
   2693                  dmp_was_on = 1;
   2694              } else
   2695                  dmp_was_on = 0;
   2696          
   2697              /* Get initial settings. */
   2698              mpu_get_gyro_fsr(&gyro_fsr);
   2699              mpu_get_accel_fsr(&accel_fsr);
   2700              mpu_get_lpf(&lpf);
   2701              mpu_get_sample_rate(&sample_rate);
   2702              sensors_on = st.chip_cfg.sensors;
   2703              mpu_get_fifo_config(&fifo_sensors);
   2704          
   2705              /* For older chips, the self-test will be different. */
   2706          #if defined MPU6050
   2707              for (ii = 0; ii < tries; ii++)
   2708                  if (!get_st_biases(gyro, accel, 0))
   2709                      break;
   2710              if (ii == tries) {
   2711                  /* If we reach this point, we most likely encountered an I2C error.
   2712                   * We'll just report an error for all three sensors.
   2713                   */
   2714                  result = 0;
   2715                  goto restore;
   2716              }
   2717              for (ii = 0; ii < tries; ii++)
   2718                  if (!get_st_biases(gyro_st, accel_st, 1))
   2719                      break;
   2720              if (ii == tries) {
   2721                  /* Again, probably an I2C error. */
   2722                  result = 0;
   2723                  goto restore;
   2724              }
   2725              accel_result = accel_self_test(accel, accel_st);
   2726              gyro_result = gyro_self_test(gyro, gyro_st);
   2727          
   2728              result = 0;
   2729              if (!gyro_result)
   2730                  result |= 0x01;
   2731              if (!accel_result)
   2732                  result |= 0x02;
   2733          
   2734          #ifdef AK89xx_SECONDARY
   2735              compass_result = compass_self_test();
   2736              if (!compass_result)
   2737                  result |= 0x04;
   2738          #else
   2739                  result |= 0x04;
   2740          #endif
   2741          restore:
   2742          #elif defined MPU6500
   2743              /* For now, this function will return a "pass" result for all three sensors
   2744               * for compatibility with current test applications.
   2745               */
   2746              get_st_biases(gyro, accel, 0);
   2747              result = 0x7;
   2748          #endif
   2749              /* Set to invalid values to ensure no I2C writes are skipped. */
   2750              st.chip_cfg.gyro_fsr = 0xFF;
   2751              st.chip_cfg.accel_fsr = 0xFF;
   2752              st.chip_cfg.lpf = 0xFF;
   2753              st.chip_cfg.sample_rate = 0xFFFF;
   2754              st.chip_cfg.sensors = 0xFF;
   2755              st.chip_cfg.fifo_enable = 0xFF;
   2756              st.chip_cfg.clk_src = INV_CLK_PLL;
   2757              mpu_set_gyro_fsr(gyro_fsr);
   2758              mpu_set_accel_fsr(accel_fsr);
   2759              mpu_set_lpf(lpf);
   2760              mpu_set_sample_rate(sample_rate);
   2761              mpu_set_sensors(sensors_on);
   2762              mpu_configure_fifo(fifo_sensors);
   2763          
   2764              if (dmp_was_on)
   2765                  mpu_set_dmp_state(1);
   2766          
   2767              return result;
   2768          }
   2769          
   2770          /**
   2771           *  @brief      Write to the DMP memory.
   2772           *  This function prevents I2C writes past the bank boundaries. The DMP memory
   2773           *  is only accessible when the chip is awake.
   2774           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2775           *  @param[in]  length      Number of bytes to write.
   2776           *  @param[in]  data        Bytes to write to memory.
   2777           *  @return     0 if successful.
   2778           */
   2779          int mpu_write_mem(unsigned short mem_addr, unsigned short length,
   2780                  unsigned char *data)
   2781          {
   2782              unsigned char tmp[2];
   2783          
   2784              if (!data)
   2785                  return -1;
   2786              if (!st.chip_cfg.sensors)
   2787                  return -1;
   2788          
   2789              tmp[0] = (unsigned char)(mem_addr >> 8);
   2790              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   2791          
   2792              /* Check bank boundaries. */
   2793              if (tmp[1] + length > st.hw->bank_size)
   2794                  return -1;
   2795          
   2796              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   2797                  return -1;
   2798              if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
   2799                  return -1;
   2800              return 0;
   2801          }
   2802          
   2803          /**
   2804           *  @brief      Read from the DMP memory.
   2805           *  This function prevents I2C reads past the bank boundaries. The DMP memory
   2806           *  is only accessible when the chip is awake.
   2807           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2808           *  @param[in]  length      Number of bytes to read.
   2809           *  @param[out] data        Bytes read from memory.
   2810           *  @return     0 if successful.
   2811           */
   2812          int mpu_read_mem(unsigned short mem_addr, unsigned short length,
   2813                  unsigned char *data)
   2814          {
   2815              unsigned char tmp[2];
   2816          
   2817              if (!data)
   2818                  return -1;
   2819              if (!st.chip_cfg.sensors)
   2820                  return -1;
   2821          
   2822              tmp[0] = (unsigned char)(mem_addr >> 8);
   2823              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   2824          
   2825              /* Check bank boundaries. */
   2826              if (tmp[1] + length > st.hw->bank_size)
   2827                  return -1;
   2828          
   2829              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   2830                  return -1;
   2831              if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
   2832                  return -1;
   2833              return 0;
   2834          }
   2835          
   2836          /**
   2837           *  @brief      Load and verify DMP image.
   2838           *  @param[in]  length      Length of DMP image.
   2839           *  @param[in]  firmware    DMP code.
   2840           *  @param[in]  start_addr  Starting address of DMP code memory.
   2841           *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
   2842           *  @return     0 if successful.
   2843           */
   2844          int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
   2845              unsigned short start_addr, unsigned short sample_rate)
   2846          {
   2847              unsigned short ii;
   2848              unsigned short this_write;
   2849              /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
   2850          #define LOAD_CHUNK  (16)
   2851              unsigned char cur[LOAD_CHUNK], tmp[2];
   2852          
   2853              if (st.chip_cfg.dmp_loaded)
   2854                  /* DMP should only be loaded once. */
   2855                  return -1;
   2856          
   2857              if (!firmware)
   2858                  return -1;
   2859              for (ii = 0; ii < length; ii += this_write) {
   2860                  this_write = min(LOAD_CHUNK, length - ii);
   2861                  if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
   2862                      return -1;
   2863                  if (mpu_read_mem(ii, this_write, cur))
   2864                      return -1;
   2865                  if (memcmp(firmware+ii, cur, this_write))
   2866                      return -2;
   2867              }
   2868          
   2869              /* Set program start address. */
   2870              tmp[0] = start_addr >> 8;
   2871              tmp[1] = start_addr & 0xFF;
   2872              if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
   2873                  return -1;
   2874          
   2875              st.chip_cfg.dmp_loaded = 1;
   2876              st.chip_cfg.dmp_sample_rate = sample_rate;
   2877              return 0;
   2878          }
   2879          
   2880          /**
   2881           *  @brief      Enable/disable DMP support.
   2882           *  @param[in]  enable  1 to turn on the DMP.
   2883           *  @return     0 if successful.
   2884           */
   2885          int mpu_set_dmp_state(unsigned char enable)
   2886          {
   2887              unsigned char tmp;
   2888              if (st.chip_cfg.dmp_on == enable)
   2889                  return 0;
   2890          
   2891              if (enable) {
   2892                  if (!st.chip_cfg.dmp_loaded)
   2893                      return -1;
   2894                  /* Disable data ready interrupt. */
   2895                  set_int_enable(0);
   2896                  /* Disable bypass mode. */
   2897                  mpu_set_bypass(0);
   2898                  /* Keep constant sample rate, FIFO rate controlled by DMP. */
   2899                  mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
   2900                  /* Remove FIFO elements. */
   2901                  tmp = 0;
   2902                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2903                  st.chip_cfg.dmp_on = 1;
   2904                  /* Enable DMP interrupt. */
   2905                  set_int_enable(1);
   2906                  mpu_reset_fifo();
   2907              } else {
   2908                  /* Disable DMP interrupt. */
   2909                  set_int_enable(0);
   2910                  /* Restore FIFO settings. */
   2911                  tmp = st.chip_cfg.fifo_enable;
   2912                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2913                  st.chip_cfg.dmp_on = 0;
   2914                  mpu_reset_fifo();
   2915              }
   2916              return 0;
   2917          }
   2918          
   2919          /**
   2920           *  @brief      Get DMP state.
   2921           *  @param[out] enabled 1 if enabled.
   2922           *  @return     0 if successful.
   2923           */
   2924          int mpu_get_dmp_state(unsigned char *enabled)
   2925          {
   2926              enabled[0] = st.chip_cfg.dmp_on;
   2927              return 0;
   2928          }
   2929          
   2930          #ifdef AK89xx_SECONDARY
   2931          /* This initialization is similar to the one in ak8975.c. */
   2932          static int setup_compass(void)
   2933          {
   2934              unsigned char data[4], akm_addr;
   2935          
   2936              mpu_set_bypass(1);
   2937          
   2938              /* Find compass. Possible addresses range from 0x0C to 0x0F. */
   2939              for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
   2940                  int result;
   2941                  result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
   2942                  if (!result && (data[0] == AKM_WHOAMI))
   2943                      break;
   2944              }
   2945          
   2946              if (akm_addr > 0x0F) {
   2947                  /* TODO: Handle this case in all compass-related functions. */
   2948                  log_e("Compass not found.\n");
   2949                  return -1;
   2950              }
   2951          
   2952              st.chip_cfg.compass_addr = akm_addr;
   2953          
   2954              data[0] = AKM_POWER_DOWN;
   2955              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2956                  return -1;
   2957              delay_ms(1);
   2958          
   2959              data[0] = AKM_FUSE_ROM_ACCESS;
   2960              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2961                  return -1;
   2962              delay_ms(1);
   2963          
   2964              /* Get sensitivity adjustment data from fuse ROM. */
   2965              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
   2966                  return -1;
   2967              st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
   2968              st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
   2969              st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
   2970          
   2971              data[0] = AKM_POWER_DOWN;
   2972              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2973                  return -1;
   2974              delay_ms(1);
   2975          
   2976              mpu_set_bypass(0);
   2977          
   2978              /* Set up master mode, master clock, and ES bit. */
   2979              data[0] = 0x40;
   2980              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   2981                  return -1;
   2982          
   2983              /* Slave 0 reads from AKM data registers. */
   2984              data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
   2985              if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
   2986                  return -1;
   2987          
   2988              /* Compass reads start at this register. */
   2989              data[0] = AKM_REG_ST1;
   2990              if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
   2991                  return -1;
   2992          
   2993              /* Enable slave 0, 8-byte reads. */
   2994              data[0] = BIT_SLAVE_EN | 8;
   2995              if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
   2996                  return -1;
   2997          
   2998              /* Slave 1 changes AKM measurement mode. */
   2999              data[0] = st.chip_cfg.compass_addr;
   3000              if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
   3001                  return -1;
   3002          
   3003              /* AKM measurement mode register. */
   3004              data[0] = AKM_REG_CNTL;
   3005              if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
   3006                  return -1;
   3007          
   3008              /* Enable slave 1, 1-byte writes. */
   3009              data[0] = BIT_SLAVE_EN | 1;
   3010              if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
   3011                  return -1;
   3012          
   3013              /* Set slave 1 data. */
   3014              data[0] = AKM_SINGLE_MEASUREMENT;
   3015              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
   3016                  return -1;
   3017          
   3018              /* Trigger slave 0 and slave 1 actions at each sample. */
   3019              data[0] = 0x03;
   3020              if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
   3021                  return -1;
   3022          
   3023          #ifdef MPU9150
   3024              /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
   3025              data[0] = BIT_I2C_MST_VDDIO;
   3026              if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
   3027                  return -1;
   3028          #endif
   3029          
   3030              return 0;
   3031          }
   3032          #endif
   3033          
   3034          /**
   3035           *  @brief      Read raw compass data.
   3036           *  @param[out] data        Raw data in hardware units.
   3037           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   3038           *  @return     0 if successful.
   3039           */
   3040          int mpu_get_compass_reg(short *data, unsigned long *timestamp)
   3041          {
   3042          #ifdef AK89xx_SECONDARY
   3043              unsigned char tmp[9];
   3044          
   3045              if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   3046                  return -1;
   3047          
   3048          #ifdef AK89xx_BYPASS
   3049              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
   3050                  return -1;
   3051              tmp[8] = AKM_SINGLE_MEASUREMENT;
   3052              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
   3053                  return -1;
   3054          #else
   3055              if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
   3056                  return -1;
   3057          #endif
   3058          
   3059          #if defined AK8975_SECONDARY
   3060              /* AK8975 doesn't have the overrun error bit. */
   3061              if (!(tmp[0] & AKM_DATA_READY))
   3062                  return -2;
   3063              if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
   3064                  return -3;
   3065          #elif defined AK8963_SECONDARY
   3066              /* AK8963 doesn't have the data read error bit. */
   3067              if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
   3068                  return -2;
   3069              if (tmp[7] & AKM_OVERFLOW)
   3070                  return -3;
   3071          #endif
   3072              data[0] = (tmp[2] << 8) | tmp[1];
   3073              data[1] = (tmp[4] << 8) | tmp[3];
   3074              data[2] = (tmp[6] << 8) | tmp[5];
   3075          
   3076              data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
   3077              data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
   3078              data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
   3079          
   3080              if (timestamp)
   3081                  get_ms(timestamp);
   3082              return 0;
   3083          #else
   3084              return -1;
   3085          #endif
   3086          }
   3087          
   3088          /**
   3089           *  @brief      Get the compass full-scale range.
   3090           *  @param[out] fsr Current full-scale range.
   3091           *  @return     0 if successful.
   3092           */
   3093          int mpu_get_compass_fsr(unsigned short *fsr)
   3094          {
   3095          #ifdef AK89xx_SECONDARY
   3096              fsr[0] = st.hw->compass_fsr;
   3097              return 0;
   3098          #else
   3099              return -1;
   3100          #endif
   3101          }
   3102          
   3103          /**
   3104           *  @brief      Enters LP accel motion interrupt mode.
   3105           *  The behaviour of this feature is very different between the MPU6050 and the
   3106           *  MPU6500. Each chip's version of this feature is explained below.
   3107           *
   3108           *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
   3109           *  increments.
   3110           *
   3111           *  \n Low-power accel mode supports the following frequencies:
   3112           *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
   3113           *
   3114           *  \n MPU6500:
   3115           *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
   3116           *  sample. The hardware monitors the accel data and detects any large change
   3117           *  over a short period of time.
   3118           *
   3119           *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
   3120           *  increments.
   3121           *
   3122           *  \n MPU6500 Low-power accel mode supports the following frequencies:
   3123           *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
   3124           *
   3125           *  \n\n NOTES:
   3126           *  \n The driver will round down @e thresh to the nearest supported value if
   3127           *  an unsupported threshold is selected.
   3128           *  \n To select a fractional wake-up frequency, round down the value passed to
   3129           *  @e lpa_freq.
   3130           *  \n The MPU6500 does not support a delay parameter. If this function is used
   3131           *  for the MPU6500, the value passed to @e time will be ignored.
   3132           *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
   3133           *  the previous configuration.
   3134           *
   3135           *  @param[in]  thresh      Motion threshold in mg.
   3136           *  @param[in]  time        Duration in milliseconds that the accel data must
   3137           *                          exceed @e thresh before motion is reported.
   3138           *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
   3139           *  @return     0 if successful.
   3140           */
   3141          int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
   3142              unsigned short lpa_freq)
   3143          {
   3144          
   3145          #if defined MPU6500
   3146              unsigned char data[3];
   3147          #endif
   3148              if (lpa_freq) {
   3149          #if defined MPU6500
   3150              	unsigned char thresh_hw;
   3151          
   3152                  /* 1LSb = 4mg. */
   3153                  if (thresh > 1020)
   3154                      thresh_hw = 255;
   3155                  else if (thresh < 4)
   3156                      thresh_hw = 1;
   3157                  else
   3158                      thresh_hw = thresh >> 2;
   3159          #endif
   3160          
   3161                  if (!time)
   3162                      /* Minimum duration must be 1ms. */
   3163                      time = 1;
   3164          
   3165          #if defined MPU6500
   3166                  if (lpa_freq > 640)
   3167                      /* At this point, the chip has not been re-configured, so the
   3168                       * function can safely exit.
   3169                       */
   3170                      return -1;
   3171          #endif
   3172          
   3173                  if (!st.chip_cfg.int_motion_only) {
   3174                      /* Store current settings for later. */
   3175                      if (st.chip_cfg.dmp_on) {
   3176                          mpu_set_dmp_state(0);
   3177                          st.chip_cfg.cache.dmp_on = 1;
   3178                      } else
   3179                          st.chip_cfg.cache.dmp_on = 0;
   3180                      mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
   3181                      mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
   3182                      mpu_get_lpf(&st.chip_cfg.cache.lpf);
   3183                      mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
   3184                      st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
   3185                      mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
   3186                  }
   3187          
   3188          #if defined MPU6500
   3189                  /* Disable hardware interrupts. */
   3190                  set_int_enable(0);
   3191          
   3192                  /* Enter full-power accel-only mode, no FIFO/DMP. */
   3193                  data[0] = 0;
   3194                  data[1] = 0;
   3195                  data[2] = BIT_STBY_XYZG;
   3196                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
   3197                      goto lp_int_restore;
   3198          
   3199                  /* Set motion threshold. */
   3200                  data[0] = thresh_hw;
   3201                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
   3202                      goto lp_int_restore;
   3203          
   3204                  /* Set wake frequency. */
   3205                  if (lpa_freq == 1)
   3206                      data[0] = INV_LPA_1_25HZ;
   3207                  else if (lpa_freq == 2)
   3208                      data[0] = INV_LPA_2_5HZ;
   3209                  else if (lpa_freq <= 5)
   3210                      data[0] = INV_LPA_5HZ;
   3211                  else if (lpa_freq <= 10)
   3212                      data[0] = INV_LPA_10HZ;
   3213                  else if (lpa_freq <= 20)
   3214                      data[0] = INV_LPA_20HZ;
   3215                  else if (lpa_freq <= 40)
   3216                      data[0] = INV_LPA_40HZ;
   3217                  else if (lpa_freq <= 80)
   3218                      data[0] = INV_LPA_80HZ;
   3219                  else if (lpa_freq <= 160)
   3220                      data[0] = INV_LPA_160HZ;
   3221                  else if (lpa_freq <= 320)
   3222                      data[0] = INV_LPA_320HZ;
   3223                  else
   3224                      data[0] = INV_LPA_640HZ;
   3225                  if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
   3226                      goto lp_int_restore;
   3227          
   3228                  /* Enable motion interrupt (MPU6500 version). */
   3229                  data[0] = BITS_WOM_EN;
   3230                  if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   3231                      goto lp_int_restore;
   3232          
   3233                  /* Enable cycle mode. */
   3234                  data[0] = BIT_LPA_CYCLE;
   3235                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   3236                      goto lp_int_restore;
   3237          
   3238                  /* Enable interrupt. */
   3239                  data[0] = BIT_MOT_INT_EN;
   3240                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   3241                      goto lp_int_restore;
   3242          
   3243                  st.chip_cfg.int_motion_only = 1;
   3244                  return 0;
   3245          #endif
   3246              } else {
   3247                  /* Don't "restore" the previous state if no state has been saved. */
   3248                  unsigned int ii;
   3249                  char *cache_ptr = (char*)&st.chip_cfg.cache;
   3250                  for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
   3251                      if (cache_ptr[ii] != 0)
   3252                          goto lp_int_restore;
   3253                  }
   3254                  /* If we reach this point, motion interrupt mode hasn't been used yet. */
   3255                  return -1;
   3256              }
   3257          lp_int_restore:
   3258              /* Set to invalid values to ensure no I2C writes are skipped. */
   3259              st.chip_cfg.gyro_fsr = 0xFF;
   3260              st.chip_cfg.accel_fsr = 0xFF;
   3261              st.chip_cfg.lpf = 0xFF;
   3262              st.chip_cfg.sample_rate = 0xFFFF;
   3263              st.chip_cfg.sensors = 0xFF;
   3264              st.chip_cfg.fifo_enable = 0xFF;
   3265              st.chip_cfg.clk_src = INV_CLK_PLL;
   3266              mpu_set_sensors(st.chip_cfg.cache.sensors_on);
   3267              mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
   3268              mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
   3269              mpu_set_lpf(st.chip_cfg.cache.lpf);
   3270              mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
   3271              mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
   3272          
   3273              if (st.chip_cfg.cache.dmp_on)
   3274                  mpu_set_dmp_state(1);
   3275          
   3276          #ifdef MPU6500
   3277              /* Disable motion interrupt (MPU6500 version). */
   3278              data[0] = 0;
   3279              if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   3280                  goto lp_int_restore;
   3281          #endif
   3282          
   3283              st.chip_cfg.int_motion_only = 0;
   3284              return 0;
   3285          }
   3286          
   3287          /**
   3288           *  @}
   3289           */
   3290          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     112   accel_6500_self_test
       112   -> Sensors_I2C_ReadRegister
       112   -> _MLPrintLog
       112   -> __aeabi_f2d
       112   -> __aeabi_i2d
       112 __aeabi_cdcmple
      24   compass_self_test
        24   -> Sensors_I2C_ReadRegister
        24   -> Sensors_I2C_WriteRegister
        24   -> mdelay
        24   -> mpu_set_bypass
     568   get_st_6500_biases
       568   -> Sensors_I2C_ReadRegister
       568   -> Sensors_I2C_WriteRegister
       568   -> _MLPrintLog
       568   -> __aeabi_f2d
       568   -> mdelay
       568 __aeabi_ldivmod
      48   get_st_biases
        48   -> Sensors_I2C_ReadRegister
        48   -> Sensors_I2C_WriteRegister
        48   -> mdelay
        48 __aeabi_ldivmod
     112   gyro_6500_self_test
       112   -> Sensors_I2C_ReadRegister
       112   -> _MLPrintLog
       112   -> __aeabi_f2d
       112   -> __aeabi_i2d
       112 __aeabi_cdcmple
      16   mpu_configure_fifo
        16   -> mpu_reset_fifo
        16   -> set_int_enable
       0   mpu_get_accel_fsr
      24   mpu_get_accel_reg
        24   -> Sensors_I2C_ReadRegister
        24   -> get_tick_count
       0   mpu_get_accel_sens
       0   mpu_get_compass_fsr
      24   mpu_get_compass_reg
        24   -> Sensors_I2C_ReadRegister
        24   -> get_tick_count
       0   mpu_get_compass_sample_rate
       0   mpu_get_dmp_state
       0   mpu_get_fifo_config
       0   mpu_get_gyro_fsr
      24   mpu_get_gyro_reg
        24   -> Sensors_I2C_ReadRegister
        24   -> get_tick_count
       0   mpu_get_gyro_sens
      16   mpu_get_int_status
        16   -> Sensors_I2C_ReadRegister
       0   mpu_get_lpf
       0   mpu_get_power_state
       0   mpu_get_sample_rate
      24   mpu_get_temperature
        24   -> Sensors_I2C_ReadRegister
        24   -> get_tick_count
      16   mpu_init
        16   -> Sensors_I2C_WriteRegister
        16   -> __aeabi_memset
        16   -> mdelay
        16   -> mpu_configure_fifo
        16   -> mpu_set_accel_fsr
        16   -> mpu_set_compass_sample_rate
        16   -> mpu_set_gyro_fsr
        16   -> mpu_set_lpf
        16   -> mpu_set_sample_rate
        16   -> mpu_set_sensors
        16   -> setup_compass
      48   mpu_load_firmware
        48   -> Sensors_I2C_WriteRegister
        48   -> memcmp
        48   -> mpu_read_mem
        48   -> mpu_write_mem
      16   mpu_lp_accel_mode
        16   -> Sensors_I2C_WriteRegister
        16   -> mpu_configure_fifo
        16   -> mpu_set_int_latched
      16   mpu_lp_motion_interrupt
        16   -> Sensors_I2C_WriteRegister
        16   -> mpu_configure_fifo
        16   -> mpu_get_accel_fsr
        16   -> mpu_get_fifo_config
        16   -> mpu_get_gyro_fsr
        16   -> mpu_get_lpf
        16   -> mpu_get_sample_rate
        16   -> mpu_set_accel_fsr
        16   -> mpu_set_dmp_state
        16   -> mpu_set_gyro_fsr
        16   -> mpu_set_lpf
        16   -> mpu_set_sample_rate
        16   -> mpu_set_sensors
        16   -> set_int_enable
      16   mpu_read_6050_accel_bias
        16   -> Sensors_I2C_ReadRegister
      16   mpu_read_6500_accel_bias
        16   -> Sensors_I2C_ReadRegister
      16   mpu_read_6500_gyro_bias
        16   -> Sensors_I2C_ReadRegister
      48   mpu_read_fifo
        48   -> Sensors_I2C_ReadRegister
        48   -> get_tick_count
        48   -> mpu_reset_fifo
      24   mpu_read_fifo_stream
        24   -> Sensors_I2C_ReadRegister
        24   -> mpu_reset_fifo
      16   mpu_read_mem
        16   -> Sensors_I2C_ReadRegister
        16   -> Sensors_I2C_WriteRegister
       8   mpu_read_reg
         8   -> Sensors_I2C_ReadRegister
      16   mpu_reg_dump
        16   -> Sensors_I2C_ReadRegister
        16   -> _MLPrintLog
       8   mpu_reset_fifo
         8   -> Sensors_I2C_WriteRegister
         8   -> mdelay
      64   mpu_run_6500_self_test
        64   -> _MLPrintLog
        64   -> accel_6500_self_test
        64   -> compass_self_test
        64   -> get_st_6500_biases
        64   -> gyro_6500_self_test
        64   -> mpu_configure_fifo
        64   -> mpu_get_accel_fsr
        64   -> mpu_get_fifo_config
        64   -> mpu_get_gyro_fsr
        64   -> mpu_get_lpf
        64   -> mpu_get_sample_rate
        64   -> mpu_set_accel_fsr
        64   -> mpu_set_dmp_state
        64   -> mpu_set_gyro_fsr
        64   -> mpu_set_lpf
        64   -> mpu_set_sample_rate
        64   -> mpu_set_sensors
      32   mpu_run_self_test
        32   -> get_st_biases
        32   -> mpu_configure_fifo
        32   -> mpu_get_accel_fsr
        32   -> mpu_get_fifo_config
        32   -> mpu_get_gyro_fsr
        32   -> mpu_get_lpf
        32   -> mpu_get_sample_rate
        32   -> mpu_set_accel_fsr
        32   -> mpu_set_dmp_state
        32   -> mpu_set_gyro_fsr
        32   -> mpu_set_lpf
        32   -> mpu_set_sample_rate
        32   -> mpu_set_sensors
      32   mpu_set_accel_bias_6050_reg
        32   -> Sensors_I2C_WriteRegister
        32   -> mpu_read_6050_accel_bias
      32   mpu_set_accel_bias_6500_reg
        32   -> Sensors_I2C_WriteRegister
        32   -> mpu_read_6500_accel_bias
       8   mpu_set_accel_fsr
         8   -> Sensors_I2C_WriteRegister
      16   mpu_set_bypass
        16   -> Sensors_I2C_ReadRegister
        16   -> Sensors_I2C_WriteRegister
        16   -> mdelay
       8   mpu_set_compass_sample_rate
         8   -> Sensors_I2C_WriteRegister
       8   mpu_set_dmp_state
         8   -> Sensors_I2C_WriteRegister
         8   -> mpu_reset_fifo
         8   -> mpu_set_bypass
         8   -> mpu_set_sample_rate
         8   -> set_int_enable
      16   mpu_set_gyro_bias_reg
        16   -> Sensors_I2C_WriteRegister
       8   mpu_set_gyro_fsr
         8   -> Sensors_I2C_WriteRegister
      16   mpu_set_int_latched
        16   -> Sensors_I2C_WriteRegister
       0   mpu_set_int_level
       8   mpu_set_lpf
         8   -> Sensors_I2C_WriteRegister
      16   mpu_set_sample_rate
        16   -> Sensors_I2C_WriteRegister
        16   -> mpu_lp_accel_mode
        16   -> mpu_set_compass_sample_rate
        16   -> mpu_set_lpf
      16   mpu_set_sensors
        16   -> Sensors_I2C_ReadRegister
        16   -> Sensors_I2C_WriteRegister
        16   -> mdelay
        16   -> mpu_set_int_latched
      16   mpu_write_mem
        16   -> Sensors_I2C_WriteRegister
       8   set_int_enable
         8   -> Sensors_I2C_WriteRegister
      16   setup_compass
        16   -> Sensors_I2C_ReadRegister
        16   -> Sensors_I2C_WriteRegister
        16   -> _MLPrintLog
        16   -> mdelay
        16   -> mpu_set_bypass


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable17
       4  ??DataTable19
       4  ??DataTable23
       4  ??DataTable29
       4  ??DataTable35
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable38
       4  ??DataTable39
       4  ??DataTable40
       4  ??DataTable40_1
       4  ??DataTable40_2
       4  ??DataTable40_3
       4  ??DataTable40_4
       4  ??DataTable41
       4  ??DataTable41_1
       4  ??DataTable41_2
       4  ??DataTable41_3
       4  ??DataTable41_4
       4  ??DataTable41_5
       4  ??DataTable41_6
       4  ??DataTable41_7
       4  ??DataTable41_8
       4  ??DataTable41_9
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable42_2
       4  ??DataTable43
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable45
       4  ??DataTable48
       4  ??DataTable48_1
       4  ??DataTable48_2
       4  ??DataTable48_3
       4  ??DataTable48_4
       4  ??DataTable48_5
       4  ??DataTable48_6
       4  ??DataTable51
       4  ??DataTable51_1
       4  ??DataTable52
       4  ??DataTable52_1
       4  ??DataTable52_10
       4  ??DataTable52_11
       4  ??DataTable52_12
       4  ??DataTable52_13
       4  ??DataTable52_14
       4  ??DataTable52_15
       4  ??DataTable52_16
       4  ??DataTable52_17
       4  ??DataTable52_2
       4  ??DataTable52_3
       4  ??DataTable52_4
       4  ??DataTable52_5
       4  ??DataTable52_6
       4  ??DataTable52_7
       4  ??DataTable52_8
       4  ??DataTable52_9
      16  ?_0
      32  ?_1
      16  ?_10
      40  ?_11
      44  ?_12
      40  ?_13
      40  ?_14
      24  ?_15
      20  ?_16
      24  ?_17
      20  ?_18
      20  ?_19
      24  ?_2
      40  ?_20
      40  ?_21
      36  ?_22
      28  ?_23
      16  ?_24
      52  ?_25
      52  ?_26
      28  ?_27
      20  ?_28
      48  ?_29
      20  ?_3
      24  ?_30
      52  ?_31
      32  ?_32
      28  ?_33
      32  ?_34
      16  ?_35
      20  ?_36
       8  ?_37
       8  ?_38
      12  ?_39
      52  ?_4
       8  ?_40
      12  ?_41
      20  ?_5
      32  ?_6
      24  ?_7
      20  ?_8
      16  ?_9
    1094  accel_6500_self_test
     318  compass_self_test
    1502  get_st_6500_biases
    1142  get_st_biases
    1008  gyro_6500_self_test
      16  hw
     512  mpu_6500_st_tb
     126  mpu_configure_fifo
      70  mpu_get_accel_fsr
     114  mpu_get_accel_reg
      76  mpu_get_accel_sens
      12  mpu_get_compass_fsr
     200  mpu_get_compass_reg
      10  mpu_get_compass_sample_rate
      14  mpu_get_dmp_state
      10  mpu_get_fifo_config
      60  mpu_get_gyro_fsr
     116  mpu_get_gyro_reg
      60  mpu_get_gyro_sens
      74  mpu_get_int_status
      74  mpu_get_lpf
      22  mpu_get_power_state
      26  mpu_get_sample_rate
     152  mpu_get_temperature
     402  mpu_init
     230  mpu_load_firmware
     336  mpu_lp_accel_mode
     652  mpu_lp_motion_interrupt
     136  mpu_read_6050_accel_bias
     136  mpu_read_6500_accel_bias
     136  mpu_read_6500_gyro_bias
     662  mpu_read_fifo
     228  mpu_read_fifo_stream
     134  mpu_read_mem
      78  mpu_read_reg
     108  mpu_reg_dump
     498  mpu_reset_fifo
     562  mpu_run_6500_self_test
     192  mpu_run_self_test
     214  mpu_set_accel_bias_6050_reg
     214  mpu_set_accel_bias_6500_reg
     148  mpu_set_accel_fsr
     406  mpu_set_bypass
     100  mpu_set_compass_sample_rate
     148  mpu_set_dmp_state
     168  mpu_set_gyro_bias_reg
     144  mpu_set_gyro_fsr
     136  mpu_set_int_latched
      12  mpu_set_int_level
     150  mpu_set_lpf
     198  mpu_set_sample_rate
     438  mpu_set_sensors
     134  mpu_write_mem
      44  reg
     184  set_int_enable
     662  setup_compass
      56  st
      48  test

 
     56 bytes in section .data
  1 776 bytes in section .rodata
 14 470 bytes in section .text
 
 14 470 bytes of CODE  memory
  1 776 bytes of CONST memory
     56 bytes of DATA  memory

Errors: none
Warnings: none
