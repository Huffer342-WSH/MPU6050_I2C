###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        05/May/2015  09:12:29
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
#    Command line =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
#        -D USE_STDPERIPH_DRIVER -D USE_DMP -D MPL_LOG_NDEBUG=1 -D EMPL -D
#        MPU9250 -D EMPL_TARGET_STM32F4 -lcN
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\List\ -o
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4F -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0_2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\User\inc\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\User\src\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\Peripheral\inc\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\Peripheral\src\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\DeviceSupport\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\DeviceSupport\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\include\
#        -I C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\eMPL\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\stm32l\
#        -I C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\mllite\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\mpl\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\eMPL-hal\ -Ol
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\CMSIS\Include\"
#    List file    =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\List\stm32f4xx_can.lst
#    Object file  =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\Obj\stm32f4xx_can.o
#
###############################################################################

C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral:           
      9            *           - Initialization and Configuration 
     10            *           - CAN Frames Transmission 
     11            *           - CAN Frames Reception    
     12            *           - Operation modes switch  
     13            *           - Error management          
     14            *           - Interrupts and flags        
     15            *         
     16            *  @verbatim
     17            *                               
     18            *          ===================================================================      
     19            *                                   How to use this driver
     20            *          ===================================================================
     21                          
     22            *          1.  Enable the CAN controller interface clock using 
     23            *                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); for CAN1 
     24            *              and RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE); for CAN2
     25            *  @note   In case you are using CAN2 only, you have to enable the CAN1 clock.
     26            *     
     27            *          2. CAN pins configuration
     28            *               - Enable the clock for the CAN GPIOs using the following function:
     29            *                   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     30            *               - Connect the involved CAN pins to AF9 using the following function 
     31            *                   GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     32            *                - Configure these CAN pins in alternate function mode by calling
     33            *                  the function  GPIO_Init();
     34            *    
     35            *          3.  Initialise and configure the CAN using CAN_Init() and 
     36            *               CAN_FilterInit() functions.   
     37            *               
     38            *          4.  Transmit the desired CAN frame using CAN_Transmit() function.
     39            *         
     40            *          5.  Check the transmission of a CAN frame using CAN_TransmitStatus()
     41            *              function.
     42            *               
     43            *          6.  Cancel the transmission of a CAN frame using CAN_CancelTransmit()
     44            *              function.  
     45            *            
     46            *          7.  Receive a CAN frame using CAN_Recieve() function.
     47            *         
     48            *          8.  Release the receive FIFOs using CAN_FIFORelease() function.
     49            *               
     50            *          9. Return the number of pending received frames using 
     51            *              CAN_MessagePending() function.            
     52            *                   
     53            *          10. To control CAN events you can use one of the following two methods:
     54            *               - Check on CAN flags using the CAN_GetFlagStatus() function.  
     55            *               - Use CAN interrupts through the function CAN_ITConfig() at 
     56            *                 initialization phase and CAN_GetITStatus() function into 
     57            *                 interrupt routines to check if the event has occurred or not.
     58            *             After checking on a flag you should clear it using CAN_ClearFlag()
     59            *             function. And after checking on an interrupt event you should 
     60            *             clear it using CAN_ClearITPendingBit() function.            
     61            *               
     62            *              
     63            *  @endverbatim
     64            *         
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     69            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     70            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     71            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     72            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     73            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     74            *
     75            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     76            ******************************************************************************  
     77            */
     78          
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm32f4xx_can.h"
     81          #include "stm32f4xx_rcc.h"
     82          
     83          /** @addtogroup STM32F4xx_StdPeriph_Driver
     84            * @{
     85            */
     86          
     87          /** @defgroup CAN 
     88            * @brief CAN driver modules
     89            * @{
     90            */ 
     91          /* Private typedef -----------------------------------------------------------*/
     92          /* Private define ------------------------------------------------------------*/
     93          
     94          /* CAN Master Control Register bits */
     95          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
     96          
     97          /* CAN Mailbox Transmit Request */
     98          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
     99          
    100          /* CAN Filter Master Register bits */
    101          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
    102          
    103          /* Time out for INAK bit */
    104          #define INAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    105          /* Time out for SLAK bit */
    106          #define SLAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    107          
    108          /* Flags in TSR register */
    109          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    110          /* Flags in RF1R register */
    111          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    112          /* Flags in RF0R register */
    113          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    114          /* Flags in MSR register */
    115          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    116          /* Flags in ESR register */
    117          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    118          
    119          /* Mailboxes definition */
    120          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    121          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    122          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    123          
    124          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    125          
    126          /* Private macro -------------------------------------------------------------*/
    127          /* Private variables ---------------------------------------------------------*/
    128          /* Private function prototypes -----------------------------------------------*/
    129          /* Private functions ---------------------------------------------------------*/
    130          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    131          
    132          /** @defgroup CAN_Private_Functions
    133            * @{
    134            */
    135          
    136          /** @defgroup CAN_Group1 Initialization and Configuration functions
    137           *  @brief    Initialization and Configuration functions 
    138           *
    139          @verbatim    
    140           ===============================================================================
    141                                Initialization and Configuration functions
    142           ===============================================================================  
    143            This section provides functions allowing to 
    144             - Initialize the CAN peripherals : Prescaler, operating mode, the maximum number 
    145               of time quanta to perform resynchronization, the number of time quanta in
    146               Bit Segment 1 and 2 and many other modes. 
    147               Refer to  @ref CAN_InitTypeDef  for more details.
    148             - Configures the CAN reception filter.                                      
    149             - Select the start bank filter for slave CAN.
    150             - Enables or disables the Debug Freeze mode for CAN
    151             - Enables or disables the CAN Time Trigger Operation communication mode
    152             
    153          @endverbatim
    154            * @{
    155            */
    156            
    157          /**
    158            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    159            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    160            * @retval None.
    161            */
    162          void CAN_DeInit(CAN_TypeDef* CANx)
    163          {
    164            /* Check the parameters */
    165            assert_param(IS_CAN_ALL_PERIPH(CANx));
    166           
    167            if (CANx == CAN1)
    168            {
    169              /* Enable CAN1 reset state */
    170              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
    171              /* Release CAN1 from reset state */
    172              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
    173            }
    174            else
    175            {  
    176              /* Enable CAN2 reset state */
    177              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
    178              /* Release CAN2 from reset state */
    179              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
    180            }
    181          }
    182          
    183          /**
    184            * @brief  Initializes the CAN peripheral according to the specified
    185            *         parameters in the CAN_InitStruct.
    186            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    187            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    188            *         the configuration information for the CAN peripheral.
    189            * @retval Constant indicates initialization succeed which will be 
    190            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    191            */
    192          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    193          {
    194            uint8_t InitStatus = CAN_InitStatus_Failed;
    195            uint32_t wait_ack = 0x00000000;
    196            /* Check the parameters */
    197            assert_param(IS_CAN_ALL_PERIPH(CANx));
    198            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    199            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    200            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    201            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    202            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    203            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    204            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    205            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    206            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    207            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    208            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    209          
    210            /* Exit from sleep mode */
    211            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
    212          
    213            /* Request initialisation */
    214            CANx->MCR |= CAN_MCR_INRQ ;
    215          
    216            /* Wait the acknowledge */
    217            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    218            {
    219              wait_ack++;
    220            }
    221          
    222            /* Check acknowledge */
    223            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
    224            {
    225              InitStatus = CAN_InitStatus_Failed;
    226            }
    227            else 
    228            {
    229              /* Set the time triggered communication mode */
    230              if (CAN_InitStruct->CAN_TTCM == ENABLE)
    231              {
    232                CANx->MCR |= CAN_MCR_TTCM;
    233              }
    234              else
    235              {
    236                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
    237              }
    238          
    239              /* Set the automatic bus-off management */
    240              if (CAN_InitStruct->CAN_ABOM == ENABLE)
    241              {
    242                CANx->MCR |= CAN_MCR_ABOM;
    243              }
    244              else
    245              {
    246                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
    247              }
    248          
    249              /* Set the automatic wake-up mode */
    250              if (CAN_InitStruct->CAN_AWUM == ENABLE)
    251              {
    252                CANx->MCR |= CAN_MCR_AWUM;
    253              }
    254              else
    255              {
    256                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
    257              }
    258          
    259              /* Set the no automatic retransmission */
    260              if (CAN_InitStruct->CAN_NART == ENABLE)
    261              {
    262                CANx->MCR |= CAN_MCR_NART;
    263              }
    264              else
    265              {
    266                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
    267              }
    268          
    269              /* Set the receive FIFO locked mode */
    270              if (CAN_InitStruct->CAN_RFLM == ENABLE)
    271              {
    272                CANx->MCR |= CAN_MCR_RFLM;
    273              }
    274              else
    275              {
    276                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
    277              }
    278          
    279              /* Set the transmit FIFO priority */
    280              if (CAN_InitStruct->CAN_TXFP == ENABLE)
    281              {
    282                CANx->MCR |= CAN_MCR_TXFP;
    283              }
    284              else
    285              {
    286                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    287              }
    288          
    289              /* Set the bit timing register */
    290              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    291                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    292                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    293                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    294                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
    295          
    296              /* Request leave initialisation */
    297              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
    298          
    299             /* Wait the acknowledge */
    300             wait_ack = 0;
    301          
    302             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    303             {
    304               wait_ack++;
    305             }
    306          
    307              /* ...and check acknowledged */
    308              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
    309              {
    310                InitStatus = CAN_InitStatus_Failed;
    311              }
    312              else
    313              {
    314                InitStatus = CAN_InitStatus_Success ;
    315              }
    316            }
    317          
    318            /* At this step, return the status of initialization */
    319            return InitStatus;
    320          }
    321          
    322          /**
    323            * @brief  Configures the CAN reception filter according to the specified
    324            *         parameters in the CAN_FilterInitStruct.
    325            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    326            *         contains the configuration information.
    327            * @retval None
    328            */
    329          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    330          {
    331            uint32_t filter_number_bit_pos = 0;
    332            /* Check the parameters */
    333            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    334            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    335            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    336            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    337            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    338          
    339            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
    340          
    341            /* Initialisation mode for the filter */
    342            CAN1->FMR |= FMR_FINIT;
    343          
    344            /* Filter Deactivation */
    345            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
    346          
    347            /* Filter Scale */
    348            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
    349            {
    350              /* 16-bit scale for the filter */
    351              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
    352          
    353              /* First 16-bit identifier and First 16-bit mask */
    354              /* Or First 16-bit identifier and Second 16-bit identifier */
    355              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    356                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    357                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    358          
    359              /* Second 16-bit identifier and Second 16-bit mask */
    360              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    361              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    362                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    363                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
    364            }
    365          
    366            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
    367            {
    368              /* 32-bit scale for the filter */
    369              CAN1->FS1R |= filter_number_bit_pos;
    370              /* 32-bit identifier or First 32-bit identifier */
    371              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    372                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    373                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    374              /* 32-bit mask or Second 32-bit identifier */
    375              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    376                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    377                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
    378            }
    379          
    380            /* Filter Mode */
    381            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
    382            {
    383              /*Id/Mask mode for the filter*/
    384              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
    385            }
    386            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    387            {
    388              /*Identifier list mode for the filter*/
    389              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
    390            }
    391          
    392            /* Filter FIFO assignment */
    393            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
    394            {
    395              /* FIFO 0 assignation for the filter */
    396              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
    397            }
    398          
    399            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
    400            {
    401              /* FIFO 1 assignation for the filter */
    402              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
    403            }
    404            
    405            /* Filter activation */
    406            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
    407            {
    408              CAN1->FA1R |= filter_number_bit_pos;
    409            }
    410          
    411            /* Leave the initialisation mode for the filter */
    412            CAN1->FMR &= ~FMR_FINIT;
    413          }
    414          
    415          /**
    416            * @brief  Fills each CAN_InitStruct member with its default value.
    417            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    418            * @retval None
    419            */
    420          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    421          {
    422            /* Reset CAN init structure parameters values */
    423            
    424            /* Initialize the time triggered communication mode */
    425            CAN_InitStruct->CAN_TTCM = DISABLE;
    426            
    427            /* Initialize the automatic bus-off management */
    428            CAN_InitStruct->CAN_ABOM = DISABLE;
    429            
    430            /* Initialize the automatic wake-up mode */
    431            CAN_InitStruct->CAN_AWUM = DISABLE;
    432            
    433            /* Initialize the no automatic retransmission */
    434            CAN_InitStruct->CAN_NART = DISABLE;
    435            
    436            /* Initialize the receive FIFO locked mode */
    437            CAN_InitStruct->CAN_RFLM = DISABLE;
    438            
    439            /* Initialize the transmit FIFO priority */
    440            CAN_InitStruct->CAN_TXFP = DISABLE;
    441            
    442            /* Initialize the CAN_Mode member */
    443            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
    444            
    445            /* Initialize the CAN_SJW member */
    446            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
    447            
    448            /* Initialize the CAN_BS1 member */
    449            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
    450            
    451            /* Initialize the CAN_BS2 member */
    452            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
    453            
    454            /* Initialize the CAN_Prescaler member */
    455            CAN_InitStruct->CAN_Prescaler = 1;
    456          }
    457          
    458          /**
    459            * @brief  Select the start bank filter for slave CAN.
    460            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    461            * @retval None
    462            */
    463          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    464          {
    465            /* Check the parameters */
    466            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    467            
    468            /* Enter Initialisation mode for the filter */
    469            CAN1->FMR |= FMR_FINIT;
    470            
    471            /* Select the start slave bank */
    472            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
    473            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
    474            
    475            /* Leave Initialisation mode for the filter */
    476            CAN1->FMR &= ~FMR_FINIT;
    477          }
    478          
    479          /**
    480            * @brief  Enables or disables the DBG Freeze for CAN.
    481            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    482            * @param  NewState: new state of the CAN peripheral. 
    483            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    484            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    485            *          or DISABLE (CAN is working during debug).
    486            * @retval None
    487            */
    488          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    489          {
    490            /* Check the parameters */
    491            assert_param(IS_CAN_ALL_PERIPH(CANx));
    492            assert_param(IS_FUNCTIONAL_STATE(NewState));
    493            
    494            if (NewState != DISABLE)
    495            {
    496              /* Enable Debug Freeze  */
    497              CANx->MCR |= MCR_DBF;
    498            }
    499            else
    500            {
    501              /* Disable Debug Freeze */
    502              CANx->MCR &= ~MCR_DBF;
    503            }
    504          }
    505          
    506          
    507          /**
    508            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    509            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    510            *         sent over the CAN bus.  
    511            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    512            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    513            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    514            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    515            *         in data byte 7. 
    516            * @retval None
    517            */
    518          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    519          {
    520            /* Check the parameters */
    521            assert_param(IS_CAN_ALL_PERIPH(CANx));
    522            assert_param(IS_FUNCTIONAL_STATE(NewState));
    523            if (NewState != DISABLE)
    524            {
    525              /* Enable the TTCM mode */
    526              CANx->MCR |= CAN_MCR_TTCM;
    527          
    528              /* Set TGT bits */
    529              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
    530              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
    531              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
    532            }
    533            else
    534            {
    535              /* Disable the TTCM mode */
    536              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
    537          
    538              /* Reset TGT bits */
    539              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
    540              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
    541              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
    542            }
    543          }
    544          /**
    545            * @}
    546            */
    547          
    548          
    549          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    550           *  @brief    CAN Frames Transmission functions 
    551           *
    552          @verbatim    
    553           ===============================================================================
    554                                CAN Frames Transmission functions
    555           ===============================================================================  
    556            This section provides functions allowing to 
    557             - Initiate and transmit a CAN frame message (if there is an empty mailbox).
    558             - Check the transmission status of a CAN Frame
    559             - Cancel a transmit request
    560             
    561          @endverbatim
    562            * @{
    563            */
    564          
    565          /**
    566            * @brief  Initiates and transmits a CAN frame message.
    567            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    568            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    569            * @retval The number of the mailbox that is used for transmission or
    570            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    571            */
    572          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    573          {
    574            uint8_t transmit_mailbox = 0;
    575            /* Check the parameters */
    576            assert_param(IS_CAN_ALL_PERIPH(CANx));
    577            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    578            assert_param(IS_CAN_RTR(TxMessage->RTR));
    579            assert_param(IS_CAN_DLC(TxMessage->DLC));
    580          
    581            /* Select one empty transmit mailbox */
    582            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
    583            {
    584              transmit_mailbox = 0;
    585            }
    586            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
    587            {
    588              transmit_mailbox = 1;
    589            }
    590            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
    591            {
    592              transmit_mailbox = 2;
    593            }
    594            else
    595            {
    596              transmit_mailbox = CAN_TxStatus_NoMailBox;
    597            }
    598          
    599            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
    600            {
    601              /* Set up the Id */
    602              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
    603              if (TxMessage->IDE == CAN_Id_Standard)
    604              {
    605                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    606                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    607                                                            TxMessage->RTR);
    608              }
    609              else
    610              {
    611                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    612                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    613                                                            TxMessage->IDE | \
    614                                                            TxMessage->RTR);
    615              }
    616              
    617              /* Set up the DLC */
    618              TxMessage->DLC &= (uint8_t)0x0000000F;
    619              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    620              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
    621          
    622              /* Set up the data field */
    623              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    624                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    625                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    626                                                       ((uint32_t)TxMessage->Data[0]));
    627              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    628                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    629                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    630                                                       ((uint32_t)TxMessage->Data[4]));
    631              /* Request transmission */
    632              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
    633            }
    634            return transmit_mailbox;
    635          }
    636          
    637          /**
    638            * @brief  Checks the transmission status of a CAN Frame.
    639            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    640            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    641            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    642            *         CAN_TxStatus_Failed in an other case.
    643            */
    644          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    645          {
    646            uint32_t state = 0;
    647          
    648            /* Check the parameters */
    649            assert_param(IS_CAN_ALL_PERIPH(CANx));
    650            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    651           
    652            switch (TransmitMailbox)
    653            {
    654              case (CAN_TXMAILBOX_0): 
    655                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
    656                break;
    657              case (CAN_TXMAILBOX_1): 
    658                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
    659                break;
    660              case (CAN_TXMAILBOX_2): 
    661                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
    662                break;
    663              default:
    664                state = CAN_TxStatus_Failed;
    665                break;
    666            }
    667            switch (state)
    668            {
    669                /* transmit pending  */
    670              case (0x0): state = CAN_TxStatus_Pending;
    671                break;
    672                /* transmit failed  */
    673               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
    674                break;
    675               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
    676                break;
    677               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
    678                break;
    679                /* transmit succeeded  */
    680              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
    681                break;
    682              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
    683                break;
    684              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
    685                break;
    686              default: state = CAN_TxStatus_Failed;
    687                break;
    688            }
    689            return (uint8_t) state;
    690          }
    691          
    692          /**
    693            * @brief  Cancels a transmit request.
    694            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    695            * @param  Mailbox: Mailbox number.
    696            * @retval None
    697            */
    698          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    699          {
    700            /* Check the parameters */
    701            assert_param(IS_CAN_ALL_PERIPH(CANx));
    702            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    703            /* abort transmission */
    704            switch (Mailbox)
    705            {
    706              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
    707                break;
    708              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
    709                break;
    710              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
    711                break;
    712              default:
    713                break;
    714            }
    715          }
    716          /**
    717            * @}
    718            */
    719          
    720          
    721          /** @defgroup CAN_Group3 CAN Frames Reception functions
    722           *  @brief    CAN Frames Reception functions 
    723           *
    724          @verbatim    
    725           ===============================================================================
    726                                CAN Frames Reception functions
    727           ===============================================================================  
    728            This section provides functions allowing to 
    729             -  Receive a correct CAN frame
    730             -  Release a specified receive FIFO (2 FIFOs are available)
    731             -  Return the number of the pending received CAN frames
    732             
    733          @endverbatim
    734            * @{
    735            */
    736          
    737          /**
    738            * @brief  Receives a correct CAN frame.
    739            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    740            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    741            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    742            *         CAN DLC, CAN data and FMI number.
    743            * @retval None
    744            */
    745          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    746          {
    747            /* Check the parameters */
    748            assert_param(IS_CAN_ALL_PERIPH(CANx));
    749            assert_param(IS_CAN_FIFO(FIFONumber));
    750            /* Get the Id */
    751            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
    752            if (RxMessage->IDE == CAN_Id_Standard)
    753            {
    754              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
    755            }
    756            else
    757            {
    758              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
    759            }
    760            
    761            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
    762            /* Get the DLC */
    763            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
    764            /* Get the FMI */
    765            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
    766            /* Get the data field */
    767            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
    768            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
    769            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
    770            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
    771            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
    772            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
    773            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
    774            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
    775            /* Release the FIFO */
    776            /* Release FIFO0 */
    777            if (FIFONumber == CAN_FIFO0)
    778            {
    779              CANx->RF0R |= CAN_RF0R_RFOM0;
    780            }
    781            /* Release FIFO1 */
    782            else /* FIFONumber == CAN_FIFO1 */
    783            {
    784              CANx->RF1R |= CAN_RF1R_RFOM1;
    785            }
    786          }
    787          
    788          /**
    789            * @brief  Releases the specified receive FIFO.
    790            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    791            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    792            * @retval None
    793            */
    794          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    795          {
    796            /* Check the parameters */
    797            assert_param(IS_CAN_ALL_PERIPH(CANx));
    798            assert_param(IS_CAN_FIFO(FIFONumber));
    799            /* Release FIFO0 */
    800            if (FIFONumber == CAN_FIFO0)
    801            {
    802              CANx->RF0R |= CAN_RF0R_RFOM0;
    803            }
    804            /* Release FIFO1 */
    805            else /* FIFONumber == CAN_FIFO1 */
    806            {
    807              CANx->RF1R |= CAN_RF1R_RFOM1;
    808            }
    809          }
    810          
    811          /**
    812            * @brief  Returns the number of pending received messages.
    813            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    814            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    815            * @retval NbMessage : which is the number of pending message.
    816            */
    817          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    818          {
    819            uint8_t message_pending=0;
    820            /* Check the parameters */
    821            assert_param(IS_CAN_ALL_PERIPH(CANx));
    822            assert_param(IS_CAN_FIFO(FIFONumber));
    823            if (FIFONumber == CAN_FIFO0)
    824            {
    825              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
    826            }
    827            else if (FIFONumber == CAN_FIFO1)
    828            {
    829              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
    830            }
    831            else
    832            {
    833              message_pending = 0;
    834            }
    835            return message_pending;
    836          }
    837          /**
    838            * @}
    839            */
    840          
    841          
    842          /** @defgroup CAN_Group4 CAN Operation modes functions
    843           *  @brief    CAN Operation modes functions 
    844           *
    845          @verbatim    
    846           ===============================================================================
    847                                CAN Operation modes functions
    848           ===============================================================================  
    849            This section provides functions allowing to select the CAN Operation modes
    850            - sleep mode
    851            - normal mode 
    852            - initialization mode
    853             
    854          @endverbatim
    855            * @{
    856            */
    857            
    858            
    859          /**
    860            * @brief  Selects the CAN Operation mode.
    861            * @param  CAN_OperatingMode: CAN Operating Mode.
    862            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    863            * @retval status of the requested mode which can be 
    864            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    865            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    866            */
    867          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    868          {
    869            uint8_t status = CAN_ModeStatus_Failed;
    870            
    871            /* Timeout for INAK or also for SLAK bits*/
    872            uint32_t timeout = INAK_TIMEOUT; 
    873          
    874            /* Check the parameters */
    875            assert_param(IS_CAN_ALL_PERIPH(CANx));
    876            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    877          
    878            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
    879            {
    880              /* Request initialisation */
    881              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
    882          
    883              /* Wait the acknowledge */
    884              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    885              {
    886                timeout--;
    887              }
    888              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
    889              {
    890                status = CAN_ModeStatus_Failed;
    891              }
    892              else
    893              {
    894                status = CAN_ModeStatus_Success;
    895              }
    896            }
    897            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
    898            {
    899              /* Request leave initialisation and sleep mode  and enter Normal mode */
    900              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
    901          
    902              /* Wait the acknowledge */
    903              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
    904              {
    905                timeout--;
    906              }
    907              if ((CANx->MSR & CAN_MODE_MASK) != 0)
    908              {
    909                status = CAN_ModeStatus_Failed;
    910              }
    911              else
    912              {
    913                status = CAN_ModeStatus_Success;
    914              }
    915            }
    916            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
    917            {
    918              /* Request Sleep mode */
    919              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    920          
    921              /* Wait the acknowledge */
    922              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
    923              {
    924                timeout--;
    925              }
    926              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
    927              {
    928                status = CAN_ModeStatus_Failed;
    929              }
    930              else
    931              {
    932                status = CAN_ModeStatus_Success;
    933              }
    934            }
    935            else
    936            {
    937              status = CAN_ModeStatus_Failed;
    938            }
    939          
    940            return  (uint8_t) status;
    941          }
    942          
    943          /**
    944            * @brief  Enters the Sleep (low power) mode.
    945            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    946            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    947            */
    948          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    949          {
    950            uint8_t sleepstatus = CAN_Sleep_Failed;
    951            
    952            /* Check the parameters */
    953            assert_param(IS_CAN_ALL_PERIPH(CANx));
    954              
    955            /* Request Sleep mode */
    956             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    957             
    958            /* Sleep mode status */
    959            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
    960            {
    961              /* Sleep mode not entered */
    962              sleepstatus =  CAN_Sleep_Ok;
    963            }
    964            /* return sleep mode status */
    965             return (uint8_t)sleepstatus;
    966          }
    967          
    968          /**
    969            * @brief  Wakes up the CAN peripheral from sleep mode .
    970            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    971            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    972            */
    973          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    974          {
    975            uint32_t wait_slak = SLAK_TIMEOUT;
    976            uint8_t wakeupstatus = CAN_WakeUp_Failed;
    977            
    978            /* Check the parameters */
    979            assert_param(IS_CAN_ALL_PERIPH(CANx));
    980              
    981            /* Wake up request */
    982            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
    983              
    984            /* Sleep mode status */
    985            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    986            {
    987             wait_slak--;
    988            }
    989            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
    990            {
    991             /* wake up done : Sleep mode exited */
    992              wakeupstatus = CAN_WakeUp_Ok;
    993            }
    994            /* return wakeup status */
    995            return (uint8_t)wakeupstatus;
    996          }
    997          /**
    998            * @}
    999            */
   1000          
   1001          
   1002          /** @defgroup CAN_Group5 CAN Bus Error management functions
   1003           *  @brief    CAN Bus Error management functions 
   1004           *
   1005          @verbatim    
   1006           ===============================================================================
   1007                                CAN Bus Error management functions
   1008           ===============================================================================  
   1009            This section provides functions allowing to 
   1010             -  Return the CANx's last error code (LEC)
   1011             -  Return the CANx Receive Error Counter (REC)
   1012             -  Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1013             
   1014             @note If TEC is greater than 255, The CAN is in bus-off state.
   1015             @note if REC or TEC are greater than 96, an Error warning flag occurs.
   1016             @note if REC or TEC are greater than 127, an Error Passive Flag occurs.
   1017                                  
   1018          @endverbatim
   1019            * @{
   1020            */
   1021            
   1022          /**
   1023            * @brief  Returns the CANx's last error code (LEC).
   1024            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1025            * @retval Error code: 
   1026            *          - CAN_ERRORCODE_NoErr: No Error  
   1027            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1028            *          - CAN_ERRORCODE_FormErr: Form Error
   1029            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1030            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1031            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1032            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1033            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1034            */
   1035          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1036          {
   1037            uint8_t errorcode=0;
   1038            
   1039            /* Check the parameters */
   1040            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1041            
   1042            /* Get the error code*/
   1043            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   1044            
   1045            /* Return the error code*/
   1046            return errorcode;
   1047          }
   1048          
   1049          /**
   1050            * @brief  Returns the CANx Receive Error Counter (REC).
   1051            * @note   In case of an error during reception, this counter is incremented 
   1052            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1053            *         standard. After every successful reception, the counter is 
   1054            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1055            *         When the counter value exceeds 127, the CAN controller enters the 
   1056            *         error passive state.  
   1057            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
   1058            * @retval CAN Receive Error Counter. 
   1059            */
   1060          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1061          {
   1062            uint8_t counter=0;
   1063            
   1064            /* Check the parameters */
   1065            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1066            
   1067            /* Get the Receive Error Counter*/
   1068            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   1069            
   1070            /* Return the Receive Error Counter*/
   1071            return counter;
   1072          }
   1073          
   1074          
   1075          /**
   1076            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1077            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1078            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1079            */
   1080          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1081          {
   1082            uint8_t counter=0;
   1083            
   1084            /* Check the parameters */
   1085            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1086            
   1087            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1088            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   1089            
   1090            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1091            return counter;
   1092          }
   1093          /**
   1094            * @}
   1095            */
   1096          
   1097          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1098           *  @brief   Interrupts and flags management functions
   1099           *
   1100          @verbatim   
   1101           ===============================================================================
   1102                             Interrupts and flags management functions
   1103           ===============================================================================  
   1104          
   1105            This section provides functions allowing to configure the CAN Interrupts and 
   1106            to get the status and clear flags and Interrupts pending bits.
   1107            
   1108            The CAN provides 14 Interrupts sources and 15 Flags:
   1109          
   1110            ===============  
   1111                Flags :
   1112            ===============
   1113            The 15 flags can be divided on 4 groups: 
   1114          
   1115             A. Transmit Flags
   1116            -----------------------
   1117                  CAN_FLAG_RQCP0, 
   1118                  CAN_FLAG_RQCP1, 
   1119                  CAN_FLAG_RQCP2  : Request completed MailBoxes 0, 1 and 2  Flags
   1120                                    Set when when the last request (transmit or abort) has 
   1121                                    been performed. 
   1122          
   1123            B. Receive Flags
   1124            -----------------------
   1125          
   1126                  CAN_FLAG_FMP0,
   1127                  CAN_FLAG_FMP1   : FIFO 0 and 1 Message Pending Flags 
   1128                                    set to signal that messages are pending in the receive 
   1129                                    FIFO.
   1130                                    These Flags are cleared only by hardware. 
   1131          
   1132                  CAN_FLAG_FF0,
   1133                  CAN_FLAG_FF1    : FIFO 0 and 1 Full Flags
   1134                                    set when three messages are stored in the selected 
   1135                                    FIFO.                        
   1136          
   1137                  CAN_FLAG_FOV0              
   1138                  CAN_FLAG_FOV1   : FIFO 0 and 1 Overrun Flags
   1139                                    set when a new message has been received and passed 
   1140                                    the filter while the FIFO was full.         
   1141          
   1142            C. Operating Mode Flags
   1143            ----------------------- 
   1144                  CAN_FLAG_WKU    : Wake up Flag
   1145                                    set to signal that a SOF bit has been detected while 
   1146                                    the CAN hardware was in Sleep mode. 
   1147                  
   1148                  CAN_FLAG_SLAK   : Sleep acknowledge Flag
   1149                                    Set to signal that the CAN has entered Sleep Mode. 
   1150              
   1151            D. Error Flags
   1152            ----------------------- 
   1153                  CAN_FLAG_EWG    : Error Warning Flag
   1154                                    Set when the warning limit has been reached (Receive 
   1155                                    Error Counter or Transmit Error Counter greater than 96). 
   1156                                    This Flag is cleared only by hardware.
   1157                                      
   1158                  CAN_FLAG_EPV    : Error Passive Flag
   1159                                    Set when the Error Passive limit has been reached 
   1160                                    (Receive Error Counter or Transmit Error Counter 
   1161                                    greater than 127).
   1162                                    This Flag is cleared only by hardware.
   1163                                       
   1164                  CAN_FLAG_BOF    : Bus-Off Flag
   1165                                    set when CAN enters the bus-off state. The bus-off 
   1166                                    state is entered on TEC overflow, greater than 255.
   1167                                    This Flag is cleared only by hardware.
   1168                                             
   1169                  CAN_FLAG_LEC    : Last error code Flag
   1170                                    set If a message has been transferred (reception or
   1171                                    transmission) with error, and the error code is hold.              
   1172                                    
   1173            ===============  
   1174             Interrupts :
   1175            ===============
   1176            The 14 interrupts can be divided on 4 groups: 
   1177            
   1178             A. Transmit interrupt
   1179            -----------------------   
   1180                    CAN_IT_TME   :  Transmit mailbox empty Interrupt
   1181                                    if enabled, this interrupt source is pending when 
   1182                                    no transmit request are pending for Tx mailboxes.      
   1183          
   1184             B. Receive Interrupts
   1185            -----------------------          
   1186                  CAN_IT_FMP0,
   1187                  CAN_IT_FMP1    :  FIFO 0 and FIFO1 message pending Interrupts
   1188                                    if enabled, these interrupt sources are pending when 
   1189                                    messages are pending in the receive FIFO.
   1190                                    The corresponding interrupt pending bits are cleared 
   1191                                    only by hardware.
   1192                          
   1193                  CAN_IT_FF0,              
   1194                  CAN_IT_FF1     :  FIFO 0 and FIFO1 full Interrupts
   1195                                    if enabled, these interrupt sources are pending when
   1196                                    three messages are stored in the selected FIFO.
   1197                  
   1198                  CAN_IT_FOV0,        
   1199                  CAN_IT_FOV1    :  FIFO 0 and FIFO1 overrun Interrupts        
   1200                                    if enabled, these interrupt sources are pending when
   1201                                    a new message has been received and passed the filter
   1202                                    while the FIFO was full.
   1203          
   1204             C. Operating Mode Interrupts
   1205            -------------------------------          
   1206                  CAN_IT_WKU     :  Wake-up Interrupt
   1207                                    if enabled, this interrupt source is pending when 
   1208                                    a SOF bit has been detected while the CAN hardware was 
   1209                                    in Sleep mode.
   1210                                            
   1211                  CAN_IT_SLK     :  Sleep acknowledge Interrupt
   1212                                    if enabled, this interrupt source is pending when 
   1213                                    the CAN has entered Sleep Mode.       
   1214          
   1215             D. Error Interrupts 
   1216            -----------------------         
   1217                  CAN_IT_EWG     :  Error warning Interrupt 
   1218                                    if enabled, this interrupt source is pending when
   1219                                    the warning limit has been reached (Receive Error 
   1220                                    Counter or Transmit Error Counter=96). 
   1221                                         
   1222                  CAN_IT_EPV     :  Error passive Interrupt        
   1223                                    if enabled, this interrupt source is pending when
   1224                                    the Error Passive limit has been reached (Receive 
   1225                                    Error Counter or Transmit Error Counter>127).
   1226                                    
   1227                  CAN_IT_BOF     :  Bus-off Interrupt
   1228                                    if enabled, this interrupt source is pending when
   1229                                    CAN enters the bus-off state. The bus-off state is 
   1230                                    entered on TEC overflow, greater than 255.
   1231                                    This Flag is cleared only by hardware.
   1232                                            
   1233                  CAN_IT_LEC     :  Last error code Interrupt        
   1234                                    if enabled, this interrupt source is pending  when
   1235                                    a message has been transferred (reception or
   1236                                    transmission) with error, and the error code is hold.
   1237                                    
   1238                  CAN_IT_ERR     :  Error Interrupt
   1239                                    if enabled, this interrupt source is pending when 
   1240                                    an error condition is pending.      
   1241                                
   1242          
   1243            Managing the CAN controller events :
   1244            ------------------------------------ 
   1245            The user should identify which mode will be used in his application to manage 
   1246            the CAN controller events: Polling mode or Interrupt mode.
   1247            
   1248            1.  In the Polling Mode it is advised to use the following functions:
   1249                - CAN_GetFlagStatus() : to check if flags events occur. 
   1250                - CAN_ClearFlag()     : to clear the flags events.
   1251            
   1252          
   1253            
   1254            2.  In the Interrupt Mode it is advised to use the following functions:
   1255                - CAN_ITConfig()       : to enable or disable the interrupt source.
   1256                - CAN_GetITStatus()    : to check if Interrupt occurs.
   1257                - CAN_ClearITPendingBit() : to clear the Interrupt pending Bit (corresponding Flag).
   1258                @note  This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1259                       pending bits since there are cleared only by hardware. 
   1260            
   1261          @endverbatim
   1262            * @{
   1263            */ 
   1264          /**
   1265            * @brief  Enables or disables the specified CANx interrupts.
   1266            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1267            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1268            *          This parameter can be: 
   1269            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1270            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1271            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1272            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1273            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1274            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1275            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1276            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1277            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1278            *            @arg CAN_IT_EWG: Error warning Interrupt
   1279            *            @arg CAN_IT_EPV: Error passive Interrupt
   1280            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1281            *            @arg CAN_IT_LEC: Last error code Interrupt
   1282            *            @arg CAN_IT_ERR: Error Interrupt
   1283            * @param  NewState: new state of the CAN interrupts.
   1284            *          This parameter can be: ENABLE or DISABLE.
   1285            * @retval None
   1286            */
   1287          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1288          {
   1289            /* Check the parameters */
   1290            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1291            assert_param(IS_CAN_IT(CAN_IT));
   1292            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1293          
   1294            if (NewState != DISABLE)
   1295            {
   1296              /* Enable the selected CANx interrupt */
   1297              CANx->IER |= CAN_IT;
   1298            }
   1299            else
   1300            {
   1301              /* Disable the selected CANx interrupt */
   1302              CANx->IER &= ~CAN_IT;
   1303            }
   1304          }
   1305          /**
   1306            * @brief  Checks whether the specified CAN flag is set or not.
   1307            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1308            * @param  CAN_FLAG: specifies the flag to check.
   1309            *          This parameter can be one of the following values:
   1310            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1311            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1312            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1313            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1314            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1315            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1316            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1317            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1318            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1319            *            @arg CAN_FLAG_WKU: Wake up Flag
   1320            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1321            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1322            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1323            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1324            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1325            * @retval The new state of CAN_FLAG (SET or RESET).
   1326            */
   1327          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1328          {
   1329            FlagStatus bitstatus = RESET;
   1330            
   1331            /* Check the parameters */
   1332            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1333            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1334            
   1335          
   1336            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   1337            { 
   1338              /* Check the status of the specified CAN flag */
   1339              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1340              { 
   1341                /* CAN_FLAG is set */
   1342                bitstatus = SET;
   1343              }
   1344              else
   1345              { 
   1346                /* CAN_FLAG is reset */
   1347                bitstatus = RESET;
   1348              }
   1349            }
   1350            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   1351            { 
   1352              /* Check the status of the specified CAN flag */
   1353              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1354              { 
   1355                /* CAN_FLAG is set */
   1356                bitstatus = SET;
   1357              }
   1358              else
   1359              { 
   1360                /* CAN_FLAG is reset */
   1361                bitstatus = RESET;
   1362              }
   1363            }
   1364            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   1365            { 
   1366              /* Check the status of the specified CAN flag */
   1367              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1368              { 
   1369                /* CAN_FLAG is set */
   1370                bitstatus = SET;
   1371              }
   1372              else
   1373              { 
   1374                /* CAN_FLAG is reset */
   1375                bitstatus = RESET;
   1376              }
   1377            }
   1378            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   1379            { 
   1380              /* Check the status of the specified CAN flag */
   1381              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1382              { 
   1383                /* CAN_FLAG is set */
   1384                bitstatus = SET;
   1385              }
   1386              else
   1387              { 
   1388                /* CAN_FLAG is reset */
   1389                bitstatus = RESET;
   1390              }
   1391            }
   1392            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1393            { 
   1394              /* Check the status of the specified CAN flag */
   1395              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1396              { 
   1397                /* CAN_FLAG is set */
   1398                bitstatus = SET;
   1399              }
   1400              else
   1401              { 
   1402                /* CAN_FLAG is reset */
   1403                bitstatus = RESET;
   1404              }
   1405            }
   1406            /* Return the CAN_FLAG status */
   1407            return  bitstatus;
   1408          }
   1409          
   1410          /**
   1411            * @brief  Clears the CAN's pending flags.
   1412            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1413            * @param  CAN_FLAG: specifies the flag to clear.
   1414            *          This parameter can be one of the following values:
   1415            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1416            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1417            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1418            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1419            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1420            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1421            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1422            *            @arg CAN_FLAG_WKU: Wake up Flag
   1423            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1424            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1425            * @retval None
   1426            */
   1427          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1428          {
   1429            uint32_t flagtmp=0;
   1430            /* Check the parameters */
   1431            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1432            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1433            
   1434            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   1435            {
   1436              /* Clear the selected CAN flags */
   1437              CANx->ESR = (uint32_t)RESET;
   1438            }
   1439            else /* MSR or TSR or RF0R or RF1R */
   1440            {
   1441              flagtmp = CAN_FLAG & 0x000FFFFF;
   1442          
   1443              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   1444              {
   1445                /* Receive Flags */
   1446                CANx->RF0R = (uint32_t)(flagtmp);
   1447              }
   1448              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   1449              {
   1450                /* Receive Flags */
   1451                CANx->RF1R = (uint32_t)(flagtmp);
   1452              }
   1453              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   1454              {
   1455                /* Transmit Flags */
   1456                CANx->TSR = (uint32_t)(flagtmp);
   1457              }
   1458              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1459              {
   1460                /* Operating mode Flags */
   1461                CANx->MSR = (uint32_t)(flagtmp);
   1462              }
   1463            }
   1464          }
   1465          
   1466          /**
   1467            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1468            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1469            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1470            *          This parameter can be one of the following values:
   1471            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1472            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1473            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1474            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1475            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1476            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1477            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1478            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1479            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1480            *            @arg CAN_IT_EWG: Error warning Interrupt
   1481            *            @arg CAN_IT_EPV: Error passive Interrupt
   1482            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1483            *            @arg CAN_IT_LEC: Last error code Interrupt
   1484            *            @arg CAN_IT_ERR: Error Interrupt
   1485            * @retval The current state of CAN_IT (SET or RESET).
   1486            */
   1487          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1488          {
   1489            ITStatus itstatus = RESET;
   1490            /* Check the parameters */
   1491            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1492            assert_param(IS_CAN_IT(CAN_IT));
   1493            
   1494            /* check the interrupt enable bit */
   1495           if((CANx->IER & CAN_IT) != RESET)
   1496           {
   1497             /* in case the Interrupt is enabled, .... */
   1498              switch (CAN_IT)
   1499              {
   1500                case CAN_IT_TME:
   1501                  /* Check CAN_TSR_RQCPx bits */
   1502                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   1503                  break;
   1504                case CAN_IT_FMP0:
   1505                  /* Check CAN_RF0R_FMP0 bit */
   1506                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   1507                  break;
   1508                case CAN_IT_FF0:
   1509                  /* Check CAN_RF0R_FULL0 bit */
   1510                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   1511                  break;
   1512                case CAN_IT_FOV0:
   1513                  /* Check CAN_RF0R_FOVR0 bit */
   1514                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   1515                  break;
   1516                case CAN_IT_FMP1:
   1517                  /* Check CAN_RF1R_FMP1 bit */
   1518                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   1519                  break;
   1520                case CAN_IT_FF1:
   1521                  /* Check CAN_RF1R_FULL1 bit */
   1522                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   1523                  break;
   1524                case CAN_IT_FOV1:
   1525                  /* Check CAN_RF1R_FOVR1 bit */
   1526                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   1527                  break;
   1528                case CAN_IT_WKU:
   1529                  /* Check CAN_MSR_WKUI bit */
   1530                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   1531                  break;
   1532                case CAN_IT_SLK:
   1533                  /* Check CAN_MSR_SLAKI bit */
   1534                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   1535                  break;
   1536                case CAN_IT_EWG:
   1537                  /* Check CAN_ESR_EWGF bit */
   1538                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   1539                  break;
   1540                case CAN_IT_EPV:
   1541                  /* Check CAN_ESR_EPVF bit */
   1542                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   1543                  break;
   1544                case CAN_IT_BOF:
   1545                  /* Check CAN_ESR_BOFF bit */
   1546                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   1547                  break;
   1548                case CAN_IT_LEC:
   1549                  /* Check CAN_ESR_LEC bit */
   1550                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   1551                  break;
   1552                case CAN_IT_ERR:
   1553                  /* Check CAN_MSR_ERRI bit */ 
   1554                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   1555                  break;
   1556                default:
   1557                  /* in case of error, return RESET */
   1558                  itstatus = RESET;
   1559                  break;
   1560              }
   1561            }
   1562            else
   1563            {
   1564             /* in case the Interrupt is not enabled, return RESET */
   1565              itstatus  = RESET;
   1566            }
   1567            
   1568            /* Return the CAN_IT status */
   1569            return  itstatus;
   1570          }
   1571          
   1572          /**
   1573            * @brief  Clears the CANx's interrupt pending bits.
   1574            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1575            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1576            *          This parameter can be one of the following values:
   1577            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1578            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1579            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1580            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1581            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1582            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1583            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1584            *            @arg CAN_IT_EWG: Error warning Interrupt
   1585            *            @arg CAN_IT_EPV: Error passive Interrupt
   1586            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1587            *            @arg CAN_IT_LEC: Last error code Interrupt
   1588            *            @arg CAN_IT_ERR: Error Interrupt 
   1589            * @retval None
   1590            */
   1591          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1592          {
   1593            /* Check the parameters */
   1594            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1595            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1596          
   1597            switch (CAN_IT)
   1598            {
   1599              case CAN_IT_TME:
   1600                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1601                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   1602                break;
   1603              case CAN_IT_FF0:
   1604                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1605                CANx->RF0R = CAN_RF0R_FULL0; 
   1606                break;
   1607              case CAN_IT_FOV0:
   1608                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1609                CANx->RF0R = CAN_RF0R_FOVR0; 
   1610                break;
   1611              case CAN_IT_FF1:
   1612                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1613                CANx->RF1R = CAN_RF1R_FULL1;  
   1614                break;
   1615              case CAN_IT_FOV1:
   1616                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1617                CANx->RF1R = CAN_RF1R_FOVR1; 
   1618                break;
   1619              case CAN_IT_WKU:
   1620                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1621                CANx->MSR = CAN_MSR_WKUI;  
   1622                break;
   1623              case CAN_IT_SLK:
   1624                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1625                CANx->MSR = CAN_MSR_SLAKI;   
   1626                break;
   1627              case CAN_IT_EWG:
   1628                /* Clear CAN_MSR_ERRI (rc_w1) */
   1629                CANx->MSR = CAN_MSR_ERRI;
   1630                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1631                break;
   1632              case CAN_IT_EPV:
   1633                /* Clear CAN_MSR_ERRI (rc_w1) */
   1634                CANx->MSR = CAN_MSR_ERRI; 
   1635                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1636                break;
   1637              case CAN_IT_BOF:
   1638                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1639                CANx->MSR = CAN_MSR_ERRI; 
   1640                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1641                 break;
   1642              case CAN_IT_LEC:
   1643                /*  Clear LEC bits */
   1644                CANx->ESR = RESET; 
   1645                /* Clear CAN_MSR_ERRI (rc_w1) */
   1646                CANx->MSR = CAN_MSR_ERRI; 
   1647                break;
   1648              case CAN_IT_ERR:
   1649                /*Clear LEC bits */
   1650                CANx->ESR = RESET; 
   1651                /* Clear CAN_MSR_ERRI (rc_w1) */
   1652                CANx->MSR = CAN_MSR_ERRI; 
   1653                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1654                 break;
   1655              default:
   1656                 break;
   1657             }
   1658          }
   1659           /**
   1660            * @}
   1661            */
   1662          
   1663          /**
   1664            * @brief  Checks whether the CAN interrupt has occurred or not.
   1665            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1666            * @param  It_Bit: specifies the interrupt source bit to check.
   1667            * @retval The new state of the CAN Interrupt (SET or RESET).
   1668            */
   1669          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1670          {
   1671            ITStatus pendingbitstatus = RESET;
   1672            
   1673            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   1674            {
   1675              /* CAN_IT is set */
   1676              pendingbitstatus = SET;
   1677            }
   1678            else
   1679            {
   1680              /* CAN_IT is reset */
   1681              pendingbitstatus = RESET;
   1682            }
   1683            return pendingbitstatus;
   1684          }
   1685          
   1686          /**
   1687            * @}
   1688            */
   1689          
   1690          /**
   1691            * @}
   1692            */
   1693          
   1694          /**
   1695            * @}
   1696            */
   1697          
   1698          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       0   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
       4   CAN_FilterInit
       0   CAN_GetFlagStatus
       8   CAN_GetITStatus
         8   -> CheckITStatus
       0   CAN_GetLSBTransmitErrorCounter
       0   CAN_GetLastErrorCode
       0   CAN_GetReceiveErrorCounter
       0   CAN_ITConfig
       0   CAN_Init
       0   CAN_MessagePending
       0   CAN_OperatingModeRequest
       0   CAN_Receive
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       0   CAN_TTComModeCmd
       8   CAN_Transmit
       0   CAN_TransmitStatus
       0   CAN_WakeUp
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      46  CAN_CancelTransmit
      46  CAN_ClearFlag
     146  CAN_ClearITPendingBit
      26  CAN_DBGFreeze
      54  CAN_DeInit
      26  CAN_FIFORelease
     272  CAN_FilterInit
     104  CAN_GetFlagStatus
     262  CAN_GetITStatus
      12  CAN_GetLSBTransmitErrorCounter
      14  CAN_GetLastErrorCode
      12  CAN_GetReceiveErrorCounter
      24  CAN_ITConfig
     268  CAN_Init
      38  CAN_MessagePending
     170  CAN_OperatingModeRequest
     232  CAN_Receive
      70  CAN_SlaveStartBank
      32  CAN_Sleep
      46  CAN_StructInit
      98  CAN_TTComModeCmd
     286  CAN_Transmit
     140  CAN_TransmitStatus
      42  CAN_WakeUp
      18  CheckITStatus

 
 2 548 bytes in section .text
 
 2 548 bytes of CODE memory

Errors: none
Warnings: none
