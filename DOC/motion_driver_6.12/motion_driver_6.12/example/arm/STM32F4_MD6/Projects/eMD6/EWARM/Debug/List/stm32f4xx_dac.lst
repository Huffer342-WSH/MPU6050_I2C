###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        05/May/2015  09:12:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
#    Command line =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
#        -D USE_STDPERIPH_DRIVER -D USE_DMP -D MPL_LOG_NDEBUG=1 -D EMPL -D
#        MPU9250 -D EMPL_TARGET_STM32F4 -lcN
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\List\ -o
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4F -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0_2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\User\inc\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\User\src\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\Peripheral\inc\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\Peripheral\src\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\DeviceSupport\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\DeviceSupport\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\include\
#        -I C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\eMPL\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\stm32l\
#        -I C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\mllite\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\mpl\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\eMPL-hal\ -Ol
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\CMSIS\Include\"
#    List file    =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\List\stm32f4xx_dac.lst
#    Object file  =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\Obj\stm32f4xx_dac.o
#
###############################################################################

C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dac.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dac.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7             * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Digital-to-Analog Converter (DAC) peripheral: 
      9            *           - DAC channels configuration: trigger, output buffer, data format
     10            *           - DMA management      
     11            *           - Interrupts and flags management
     12            *
     13            *  @verbatim
     14            *    
     15            *          ===================================================================
     16            *                             DAC Peripheral features
     17            *          ===================================================================
     18            *          
     19            *          DAC Channels
     20            *          =============  
     21            *          The device integrates two 12-bit Digital Analog Converters that can 
     22            *          be used independently or simultaneously (dual mode):
     23            *            1- DAC channel1 with DAC_OUT1 (PA4) as output
     24            *            1- DAC channel2 with DAC_OUT2 (PA5) as output
     25            *
     26            *          DAC Triggers
     27            *          =============
     28            *          Digital to Analog conversion can be non-triggered using DAC_Trigger_None
     29            *          and DAC_OUT1/DAC_OUT2 is available once writing to DHRx register 
     30            *          using DAC_SetChannel1Data() / DAC_SetChannel2Data() functions.
     31            *   
     32            *         Digital to Analog conversion can be triggered by:
     33            *             1- External event: EXTI Line 9 (any GPIOx_Pin9) using DAC_Trigger_Ext_IT9.
     34            *                The used pin (GPIOx_Pin9) must be configured in input mode.
     35            *
     36            *             2- Timers TRGO: TIM2, TIM4, TIM5, TIM6, TIM7 and TIM8 
     37            *                (DAC_Trigger_T2_TRGO, DAC_Trigger_T4_TRGO...)
     38            *                The timer TRGO event should be selected using TIM_SelectOutputTrigger()
     39            *
     40            *             3- Software using DAC_Trigger_Software
     41            *
     42            *          DAC Buffer mode feature
     43            *          ========================  
     44            *          Each DAC channel integrates an output buffer that can be used to 
     45            *          reduce the output impedance, and to drive external loads directly
     46            *          without having to add an external operational amplifier.
     47            *          To enable, the output buffer use  
     48            *              DAC_InitStructure.DAC_OutputBuffer = DAC_OutputBuffer_Enable;
     49            *          
     50            *          Refer to the device datasheet for more details about output 
     51            *          impedance value with and without output buffer.
     52            *          
     53            *          DAC wave generation feature
     54            *          =============================      
     55            *          Both DAC channels can be used to generate
     56            *             1- Noise wave using DAC_WaveGeneration_Noise
     57            *             2- Triangle wave using DAC_WaveGeneration_Triangle
     58            *        
     59            *          Wave generation can be disabled using DAC_WaveGeneration_None
     60            *
     61            *          DAC data format
     62            *          ================   
     63            *          The DAC data format can be:
     64            *             1- 8-bit right alignment using DAC_Align_8b_R
     65            *             2- 12-bit left alignment using DAC_Align_12b_L
     66            *             3- 12-bit right alignment using DAC_Align_12b_R
     67            *
     68            *          DAC data value to voltage correspondence  
     69            *          ========================================  
     70            *          The analog output voltage on each DAC channel pin is determined
     71            *          by the following equation: 
     72            *          DAC_OUTx = VREF+ * DOR / 4095
     73            *          with  DOR is the Data Output Register
     74            *                VEF+ is the input voltage reference (refer to the device datasheet)
     75            *          e.g. To set DAC_OUT1 to 0.7V, use
     76            *            DAC_SetChannel1Data(DAC_Align_12b_R, 868);
     77            *          Assuming that VREF+ = 3.3V, DAC_OUT1 = (3.3 * 868) / 4095 = 0.7V
     78            *
     79            *          DMA requests 
     80            *          =============    
     81            *          A DMA1 request can be generated when an external trigger (but not
     82            *          a software trigger) occurs if DMA1 requests are enabled using
     83            *          DAC_DMACmd()
     84            *          DMA1 requests are mapped as following:
     85            *             1- DAC channel1 : mapped on DMA1 Stream5 channel7 which must be 
     86            *                               already configured
     87            *             2- DAC channel2 : mapped on DMA1 Stream6 channel7 which must be 
     88            *                               already configured
     89            *
     90            *          ===================================================================      
     91            *                              How to use this driver 
     92            *          ===================================================================          
     93            *            - DAC APB clock must be enabled to get write access to DAC
     94            *              registers using
     95            *              RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE)
     96            *            - Configure DAC_OUTx (DAC_OUT1: PA4, DAC_OUT2: PA5) in analog mode.
     97            *            - Configure the DAC channel using DAC_Init() function
     98            *            - Enable the DAC channel using DAC_Cmd() function
     99            * 
    100            *  @endverbatim
    101            *    
    102            ******************************************************************************
    103            * @attention
    104            *
    105            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    106            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    107            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    108            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    109            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    110            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    111            *
    112            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    113            ******************************************************************************  
    114            */ 
    115          
    116          
    117          /* Includes ------------------------------------------------------------------*/
    118          #include "stm32f4xx_dac.h"
    119          #include "stm32f4xx_rcc.h"
    120          
    121          /** @addtogroup STM32F4xx_StdPeriph_Driver
    122            * @{
    123            */
    124          
    125          /** @defgroup DAC 
    126            * @brief DAC driver modules
    127            * @{
    128            */ 
    129          
    130          /* Private typedef -----------------------------------------------------------*/
    131          /* Private define ------------------------------------------------------------*/
    132          
    133          /* CR register Mask */
    134          #define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)
    135          
    136          /* DAC Dual Channels SWTRIG masks */
    137          #define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)
    138          #define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)
    139          
    140          /* DHR registers offsets */
    141          #define DHR12R1_OFFSET             ((uint32_t)0x00000008)
    142          #define DHR12R2_OFFSET             ((uint32_t)0x00000014)
    143          #define DHR12RD_OFFSET             ((uint32_t)0x00000020)
    144          
    145          /* DOR register offset */
    146          #define DOR_OFFSET                 ((uint32_t)0x0000002C)
    147          
    148          /* Private macro -------------------------------------------------------------*/
    149          /* Private variables ---------------------------------------------------------*/
    150          /* Private function prototypes -----------------------------------------------*/
    151          /* Private functions ---------------------------------------------------------*/
    152          
    153          /** @defgroup DAC_Private_Functions
    154            * @{
    155            */
    156          
    157          /** @defgroup DAC_Group1 DAC channels configuration
    158           *  @brief   DAC channels configuration: trigger, output buffer, data format 
    159           *
    160          @verbatim   
    161           ===============================================================================
    162                    DAC channels configuration: trigger, output buffer, data format
    163           ===============================================================================  
    164          
    165          @endverbatim
    166            * @{
    167            */
    168          
    169          /**
    170            * @brief  Deinitializes the DAC peripheral registers to their default reset values.
    171            * @param  None
    172            * @retval None
    173            */
    174          void DAC_DeInit(void)
    175          {
    176            /* Enable DAC reset state */
    177            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
    178            /* Release DAC from reset state */
    179            RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
    180          }
    181          
    182          /**
    183            * @brief  Initializes the DAC peripheral according to the specified parameters
    184            *         in the DAC_InitStruct.
    185            * @param  DAC_Channel: the selected DAC channel. 
    186            *          This parameter can be one of the following values:
    187            *            @arg DAC_Channel_1: DAC Channel1 selected
    188            *            @arg DAC_Channel_2: DAC Channel2 selected
    189            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
    190            *         the configuration information for the  specified DAC channel.
    191            * @retval None
    192            */
    193          void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
    194          {
    195            uint32_t tmpreg1 = 0, tmpreg2 = 0;
    196          
    197            /* Check the DAC parameters */
    198            assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
    199            assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
    200            assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
    201            assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
    202          
    203          /*---------------------------- DAC CR Configuration --------------------------*/
    204            /* Get the DAC CR value */
    205            tmpreg1 = DAC->CR;
    206            /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
    207            tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
    208            /* Configure for the selected DAC channel: buffer output, trigger, 
    209               wave generation, mask/amplitude for wave generation */
    210            /* Set TSELx and TENx bits according to DAC_Trigger value */
    211            /* Set WAVEx bits according to DAC_WaveGeneration value */
    212            /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
    213            /* Set BOFFx bit according to DAC_OutputBuffer value */   
    214            tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
    215                       DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
    216                       DAC_InitStruct->DAC_OutputBuffer);
    217            /* Calculate CR register value depending on DAC_Channel */
    218            tmpreg1 |= tmpreg2 << DAC_Channel;
    219            /* Write to DAC CR */
    220            DAC->CR = tmpreg1;
    221          }
    222          
    223          /**
    224            * @brief  Fills each DAC_InitStruct member with its default value.
    225            * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure which will 
    226            *         be initialized.
    227            * @retval None
    228            */
    229          void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
    230          {
    231          /*--------------- Reset DAC init structure parameters values -----------------*/
    232            /* Initialize the DAC_Trigger member */
    233            DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
    234            /* Initialize the DAC_WaveGeneration member */
    235            DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
    236            /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
    237            DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
    238            /* Initialize the DAC_OutputBuffer member */
    239            DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
    240          }
    241          
    242          /**
    243            * @brief  Enables or disables the specified DAC channel.
    244            * @param  DAC_Channel: The selected DAC channel. 
    245            *          This parameter can be one of the following values:
    246            *            @arg DAC_Channel_1: DAC Channel1 selected
    247            *            @arg DAC_Channel_2: DAC Channel2 selected
    248            * @param  NewState: new state of the DAC channel. 
    249            *          This parameter can be: ENABLE or DISABLE.
    250            * @note   When the DAC channel is enabled the trigger source can no more be modified.
    251            * @retval None
    252            */
    253          void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
    254          {
    255            /* Check the parameters */
    256            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    257            assert_param(IS_FUNCTIONAL_STATE(NewState));
    258          
    259            if (NewState != DISABLE)
    260            {
    261              /* Enable the selected DAC channel */
    262              DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
    263            }
    264            else
    265            {
    266              /* Disable the selected DAC channel */
    267              DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
    268            }
    269          }
    270          
    271          /**
    272            * @brief  Enables or disables the selected DAC channel software trigger.
    273            * @param  DAC_Channel: The selected DAC channel. 
    274            *          This parameter can be one of the following values:
    275            *            @arg DAC_Channel_1: DAC Channel1 selected
    276            *            @arg DAC_Channel_2: DAC Channel2 selected
    277            * @param  NewState: new state of the selected DAC channel software trigger.
    278            *          This parameter can be: ENABLE or DISABLE.
    279            * @retval None
    280            */
    281          void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
    282          {
    283            /* Check the parameters */
    284            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    285            assert_param(IS_FUNCTIONAL_STATE(NewState));
    286          
    287            if (NewState != DISABLE)
    288            {
    289              /* Enable software trigger for the selected DAC channel */
    290              DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
    291            }
    292            else
    293            {
    294              /* Disable software trigger for the selected DAC channel */
    295              DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
    296            }
    297          }
    298          
    299          /**
    300            * @brief  Enables or disables simultaneously the two DAC channels software triggers.
    301            * @param  NewState: new state of the DAC channels software triggers.
    302            *          This parameter can be: ENABLE or DISABLE.
    303            * @retval None
    304            */
    305          void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
    306          {
    307            /* Check the parameters */
    308            assert_param(IS_FUNCTIONAL_STATE(NewState));
    309          
    310            if (NewState != DISABLE)
    311            {
    312              /* Enable software trigger for both DAC channels */
    313              DAC->SWTRIGR |= DUAL_SWTRIG_SET;
    314            }
    315            else
    316            {
    317              /* Disable software trigger for both DAC channels */
    318              DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
    319            }
    320          }
    321          
    322          /**
    323            * @brief  Enables or disables the selected DAC channel wave generation.
    324            * @param  DAC_Channel: The selected DAC channel. 
    325            *          This parameter can be one of the following values:
    326            *            @arg DAC_Channel_1: DAC Channel1 selected
    327            *            @arg DAC_Channel_2: DAC Channel2 selected
    328            * @param  DAC_Wave: specifies the wave type to enable or disable.
    329            *          This parameter can be one of the following values:
    330            *            @arg DAC_Wave_Noise: noise wave generation
    331            *            @arg DAC_Wave_Triangle: triangle wave generation
    332            * @param  NewState: new state of the selected DAC channel wave generation.
    333            *          This parameter can be: ENABLE or DISABLE.  
    334            * @retval None
    335            */
    336          void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
    337          {
    338            /* Check the parameters */
    339            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    340            assert_param(IS_DAC_WAVE(DAC_Wave)); 
    341            assert_param(IS_FUNCTIONAL_STATE(NewState));
    342          
    343            if (NewState != DISABLE)
    344            {
    345              /* Enable the selected wave generation for the selected DAC channel */
    346              DAC->CR |= DAC_Wave << DAC_Channel;
    347            }
    348            else
    349            {
    350              /* Disable the selected wave generation for the selected DAC channel */
    351              DAC->CR &= ~(DAC_Wave << DAC_Channel);
    352            }
    353          }
    354          
    355          /**
    356            * @brief  Set the specified data holding register value for DAC channel1.
    357            * @param  DAC_Align: Specifies the data alignment for DAC channel1.
    358            *          This parameter can be one of the following values:
    359            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    360            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    361            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    362            * @param  Data: Data to be loaded in the selected data holding register.
    363            * @retval None
    364            */
    365          void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
    366          {  
    367            __IO uint32_t tmp = 0;
    368            
    369            /* Check the parameters */
    370            assert_param(IS_DAC_ALIGN(DAC_Align));
    371            assert_param(IS_DAC_DATA(Data));
    372            
    373            tmp = (uint32_t)DAC_BASE; 
    374            tmp += DHR12R1_OFFSET + DAC_Align;
    375          
    376            /* Set the DAC channel1 selected data holding register */
    377            *(__IO uint32_t *) tmp = Data;
    378          }
    379          
    380          /**
    381            * @brief  Set the specified data holding register value for DAC channel2.
    382            * @param  DAC_Align: Specifies the data alignment for DAC channel2.
    383            *          This parameter can be one of the following values:
    384            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    385            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    386            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    387            * @param  Data: Data to be loaded in the selected data holding register.
    388            * @retval None
    389            */
    390          void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
    391          {
    392            __IO uint32_t tmp = 0;
    393          
    394            /* Check the parameters */
    395            assert_param(IS_DAC_ALIGN(DAC_Align));
    396            assert_param(IS_DAC_DATA(Data));
    397            
    398            tmp = (uint32_t)DAC_BASE;
    399            tmp += DHR12R2_OFFSET + DAC_Align;
    400          
    401            /* Set the DAC channel2 selected data holding register */
    402            *(__IO uint32_t *)tmp = Data;
    403          }
    404          
    405          /**
    406            * @brief  Set the specified data holding register value for dual channel DAC.
    407            * @param  DAC_Align: Specifies the data alignment for dual channel DAC.
    408            *          This parameter can be one of the following values:
    409            *            @arg DAC_Align_8b_R: 8bit right data alignment selected
    410            *            @arg DAC_Align_12b_L: 12bit left data alignment selected
    411            *            @arg DAC_Align_12b_R: 12bit right data alignment selected
    412            * @param  Data2: Data for DAC Channel2 to be loaded in the selected data holding register.
    413            * @param  Data1: Data for DAC Channel1 to be loaded in the selected data  holding register.
    414            * @note   In dual mode, a unique register access is required to write in both
    415            *          DAC channels at the same time.
    416            * @retval None
    417            */
    418          void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
    419          {
    420            uint32_t data = 0, tmp = 0;
    421            
    422            /* Check the parameters */
    423            assert_param(IS_DAC_ALIGN(DAC_Align));
    424            assert_param(IS_DAC_DATA(Data1));
    425            assert_param(IS_DAC_DATA(Data2));
    426            
    427            /* Calculate and set dual DAC data holding register value */
    428            if (DAC_Align == DAC_Align_8b_R)
    429            {
    430              data = ((uint32_t)Data2 << 8) | Data1; 
    431            }
    432            else
    433            {
    434              data = ((uint32_t)Data2 << 16) | Data1;
    435            }
    436            
    437            tmp = (uint32_t)DAC_BASE;
    438            tmp += DHR12RD_OFFSET + DAC_Align;
    439          
    440            /* Set the dual DAC selected data holding register */
    441            *(__IO uint32_t *)tmp = data;
    442          }
    443          
    444          /**
    445            * @brief  Returns the last data output value of the selected DAC channel.
    446            * @param  DAC_Channel: The selected DAC channel. 
    447            *          This parameter can be one of the following values:
    448            *            @arg DAC_Channel_1: DAC Channel1 selected
    449            *            @arg DAC_Channel_2: DAC Channel2 selected
    450            * @retval The selected DAC channel data output value.
    451            */
    452          uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
    453          {
    454            __IO uint32_t tmp = 0;
    455            
    456            /* Check the parameters */
    457            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    458            
    459            tmp = (uint32_t) DAC_BASE ;
    460            tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
    461            
    462            /* Returns the DAC channel data output register value */
    463            return (uint16_t) (*(__IO uint32_t*) tmp);
    464          }
    465          /**
    466            * @}
    467            */
    468          
    469          /** @defgroup DAC_Group2 DMA management functions
    470           *  @brief   DMA management functions
    471           *
    472          @verbatim   
    473           ===============================================================================
    474                                    DMA management functions
    475           ===============================================================================  
    476          
    477          @endverbatim
    478            * @{
    479            */
    480          
    481          /**
    482            * @brief  Enables or disables the specified DAC channel DMA request.
    483            * @note   When enabled DMA1 is generated when an external trigger (EXTI Line9,
    484            *         TIM2, TIM4, TIM5, TIM6, TIM7 or TIM8  but not a software trigger) occurs.
    485            * @param  DAC_Channel: The selected DAC channel. 
    486            *          This parameter can be one of the following values:
    487            *            @arg DAC_Channel_1: DAC Channel1 selected
    488            *            @arg DAC_Channel_2: DAC Channel2 selected
    489            * @param  NewState: new state of the selected DAC channel DMA request.
    490            *          This parameter can be: ENABLE or DISABLE.
    491            * @note   The DAC channel1 is mapped on DMA1 Stream 5 channel7 which must be
    492            *          already configured.
    493            * @note   The DAC channel2 is mapped on DMA1 Stream 6 channel7 which must be
    494            *          already configured.    
    495            * @retval None
    496            */
    497          void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
    498          {
    499            /* Check the parameters */
    500            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    501            assert_param(IS_FUNCTIONAL_STATE(NewState));
    502          
    503            if (NewState != DISABLE)
    504            {
    505              /* Enable the selected DAC channel DMA request */
    506              DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
    507            }
    508            else
    509            {
    510              /* Disable the selected DAC channel DMA request */
    511              DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
    512            }
    513          }
    514          /**
    515            * @}
    516            */
    517          
    518          /** @defgroup DAC_Group3 Interrupts and flags management functions
    519           *  @brief   Interrupts and flags management functions
    520           *
    521          @verbatim   
    522           ===============================================================================
    523                             Interrupts and flags management functions
    524           ===============================================================================  
    525          
    526          @endverbatim
    527            * @{
    528            */
    529          
    530          /**
    531            * @brief  Enables or disables the specified DAC interrupts.
    532            * @param  DAC_Channel: The selected DAC channel. 
    533            *          This parameter can be one of the following values:
    534            *            @arg DAC_Channel_1: DAC Channel1 selected
    535            *            @arg DAC_Channel_2: DAC Channel2 selected
    536            * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled. 
    537            *          This parameter can be the following values:
    538            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    539            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    540            *         acknowledgement for the first external trigger is received (first request).
    541            * @param  NewState: new state of the specified DAC interrupts.
    542            *          This parameter can be: ENABLE or DISABLE.
    543            * @retval None
    544            */ 
    545          void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)  
    546          {
    547            /* Check the parameters */
    548            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    549            assert_param(IS_FUNCTIONAL_STATE(NewState));
    550            assert_param(IS_DAC_IT(DAC_IT)); 
    551          
    552            if (NewState != DISABLE)
    553            {
    554              /* Enable the selected DAC interrupts */
    555              DAC->CR |=  (DAC_IT << DAC_Channel);
    556            }
    557            else
    558            {
    559              /* Disable the selected DAC interrupts */
    560              DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
    561            }
    562          }
    563          
    564          /**
    565            * @brief  Checks whether the specified DAC flag is set or not.
    566            * @param  DAC_Channel: The selected DAC channel. 
    567            *          This parameter can be one of the following values:
    568            *            @arg DAC_Channel_1: DAC Channel1 selected
    569            *            @arg DAC_Channel_2: DAC Channel2 selected
    570            * @param  DAC_FLAG: specifies the flag to check. 
    571            *          This parameter can be only of the following value:
    572            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag
    573            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    574            *         acknowledgement for the first external trigger is received (first request).
    575            * @retval The new state of DAC_FLAG (SET or RESET).
    576            */
    577          FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    578          {
    579            FlagStatus bitstatus = RESET;
    580            /* Check the parameters */
    581            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    582            assert_param(IS_DAC_FLAG(DAC_FLAG));
    583          
    584            /* Check the status of the specified DAC flag */
    585            if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
    586            {
    587              /* DAC_FLAG is set */
    588              bitstatus = SET;
    589            }
    590            else
    591            {
    592              /* DAC_FLAG is reset */
    593              bitstatus = RESET;
    594            }
    595            /* Return the DAC_FLAG status */
    596            return  bitstatus;
    597          }
    598          
    599          /**
    600            * @brief  Clears the DAC channel's pending flags.
    601            * @param  DAC_Channel: The selected DAC channel. 
    602            *          This parameter can be one of the following values:
    603            *            @arg DAC_Channel_1: DAC Channel1 selected
    604            *            @arg DAC_Channel_2: DAC Channel2 selected
    605            * @param  DAC_FLAG: specifies the flag to clear. 
    606            *          This parameter can be of the following value:
    607            *            @arg DAC_FLAG_DMAUDR: DMA underrun flag 
    608            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    609            *         acknowledgement for the first external trigger is received (first request).                           
    610            * @retval None
    611            */
    612          void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)
    613          {
    614            /* Check the parameters */
    615            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    616            assert_param(IS_DAC_FLAG(DAC_FLAG));
    617          
    618            /* Clear the selected DAC flags */
    619            DAC->SR = (DAC_FLAG << DAC_Channel);
    620          }
    621          
    622          /**
    623            * @brief  Checks whether the specified DAC interrupt has occurred or not.
    624            * @param  DAC_Channel: The selected DAC channel. 
    625            *          This parameter can be one of the following values:
    626            *            @arg DAC_Channel_1: DAC Channel1 selected
    627            *            @arg DAC_Channel_2: DAC Channel2 selected
    628            * @param  DAC_IT: specifies the DAC interrupt source to check. 
    629            *          This parameter can be the following values:
    630            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask
    631            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    632            *         acknowledgement for the first external trigger is received (first request).
    633            * @retval The new state of DAC_IT (SET or RESET).
    634            */
    635          ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)
    636          {
    637            ITStatus bitstatus = RESET;
    638            uint32_t enablestatus = 0;
    639            
    640            /* Check the parameters */
    641            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    642            assert_param(IS_DAC_IT(DAC_IT));
    643          
    644            /* Get the DAC_IT enable bit status */
    645            enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
    646            
    647            /* Check the status of the specified DAC interrupt */
    648            if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
    649            {
    650              /* DAC_IT is set */
    651              bitstatus = SET;
    652            }
    653            else
    654            {
    655              /* DAC_IT is reset */
    656              bitstatus = RESET;
    657            }
    658            /* Return the DAC_IT status */
    659            return  bitstatus;
    660          }
    661          
    662          /**
    663            * @brief  Clears the DAC channel's interrupt pending bits.
    664            * @param  DAC_Channel: The selected DAC channel. 
    665            *          This parameter can be one of the following values:
    666            *            @arg DAC_Channel_1: DAC Channel1 selected
    667            *            @arg DAC_Channel_2: DAC Channel2 selected
    668            * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.
    669            *          This parameter can be the following values:
    670            *            @arg DAC_IT_DMAUDR: DMA underrun interrupt mask                         
    671            * @note   The DMA underrun occurs when a second external trigger arrives before the 
    672            *         acknowledgement for the first external trigger is received (first request).                           
    673            * @retval None
    674            */
    675          void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)
    676          {
    677            /* Check the parameters */
    678            assert_param(IS_DAC_CHANNEL(DAC_Channel));
    679            assert_param(IS_DAC_IT(DAC_IT)); 
    680          
    681            /* Clear the selected DAC interrupt pending bits */
    682            DAC->SR = (DAC_IT << DAC_Channel);
    683          }
    684          
    685          /**
    686            * @}
    687            */
    688          
    689          /**
    690            * @}
    691            */
    692          
    693          /**
    694            * @}
    695            */
    696          
    697          /**
    698            * @}
    699            */
    700          
    701          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DAC_ClearFlag
       0   DAC_ClearITPendingBit
       0   DAC_Cmd
       0   DAC_DMACmd
       8   DAC_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   DAC_DualSoftwareTriggerCmd
       4   DAC_GetDataOutputValue
       0   DAC_GetFlagStatus
       0   DAC_GetITStatus
       0   DAC_ITConfig
       4   DAC_Init
       4   DAC_SetChannel1Data
       4   DAC_SetChannel2Data
       4   DAC_SetDualChannelData
       0   DAC_SoftwareTriggerCmd
       0   DAC_StructInit
       0   DAC_WaveGenerationCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
      10  DAC_ClearFlag
      10  DAC_ClearITPendingBit
      44  DAC_Cmd
      48  DAC_DMACmd
      24  DAC_DeInit
      34  DAC_DualSoftwareTriggerCmd
      30  DAC_GetDataOutputValue
      26  DAC_GetFlagStatus
      42  DAC_GetITStatus
      40  DAC_ITConfig
      46  DAC_Init
      28  DAC_SetChannel1Data
      28  DAC_SetChannel2Data
      40  DAC_SetDualChannelData
      48  DAC_SoftwareTriggerCmd
      18  DAC_StructInit
      40  DAC_WaveGenerationCmd

 
 568 bytes in section .text
 
 568 bytes of CODE memory

Errors: none
Warnings: none
