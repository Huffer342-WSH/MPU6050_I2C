###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        05/May/2015  09:12:38
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c
#    Command line =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c
#        -D USE_STDPERIPH_DRIVER -D USE_DMP -D MPL_LOG_NDEBUG=1 -D EMPL -D
#        MPU9250 -D EMPL_TARGET_STM32F4 -lcN
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\List\ -o
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4F -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 7.0_2\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\User\inc\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\User\src\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\Peripheral\inc\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\Peripheral\src\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\STM32F4xx_StdPeriph_Driver\src\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\DeviceSupport\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\DeviceSupport\inc\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\include\
#        -I C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\eMPL\
#        -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\driver\stm32l\
#        -I C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\mllite\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\mpl\ -I
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\..\core\eMPL-hal\ -Ol
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\CMSIS\Include\"
#    List file    =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\List\stm32f4xx_tim.lst
#    Object file  =  
#        C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\EWARM\Debug\Obj\stm32f4xx_tim.o
#
###############################################################################

C:\STM32_EWARM\STM32F4_MD6\Projects\eMD6\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    30-September-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Advanced-control timers (TIM1 and TIM8) specific features  
     13            *            - Interrupts, DMA and flags management
     14            *            - Clocks management
     15            *            - Synchronization management
     16            *            - Specific interface management
     17            *            - Specific remapping management      
     18            *              
     19            *  @verbatim
     20            *  
     21            *          ===================================================================
     22            *                                 How to use this driver
     23            *          ===================================================================
     24            *          This driver provides functions to configure and program the TIM 
     25            *          of all STM32F4xx devices.
     26            *          These functions are split in 9 groups: 
     27            *   
     28            *          1. TIM TimeBase management: this group includes all needed functions 
     29            *             to configure the TM Timebase unit:
     30            *                   - Set/Get Prescaler
     31            *                   - Set/Get Autoreload  
     32            *                   - Counter modes configuration
     33            *                   - Set Clock division  
     34            *                   - Select the One Pulse mode
     35            *                   - Update Request Configuration
     36            *                   - Update Disable Configuration
     37            *                   - Auto-Preload Configuration 
     38            *                   - Enable/Disable the counter     
     39            *                 
     40            *          2. TIM Output Compare management: this group includes all needed 
     41            *             functions to configure the Capture/Compare unit used in Output 
     42            *             compare mode: 
     43            *                   - Configure each channel, independently, in Output Compare mode
     44            *                   - Select the output compare modes
     45            *                   - Select the Polarities of each channel
     46            *                   - Set/Get the Capture/Compare register values
     47            *                   - Select the Output Compare Fast mode 
     48            *                   - Select the Output Compare Forced mode  
     49            *                   - Output Compare-Preload Configuration 
     50            *                   - Clear Output Compare Reference
     51            *                   - Select the OCREF Clear signal
     52            *                   - Enable/Disable the Capture/Compare Channels    
     53            *                   
     54            *          3. TIM Input Capture management: this group includes all needed 
     55            *             functions to configure the Capture/Compare unit used in 
     56            *             Input Capture mode:
     57            *                   - Configure each channel in input capture mode
     58            *                   - Configure Channel1/2 in PWM Input mode
     59            *                   - Set the Input Capture Prescaler
     60            *                   - Get the Capture/Compare values      
     61            *                   
     62            *          4. Advanced-control timers (TIM1 and TIM8) specific features
     63            *                   - Configures the Break input, dead time, Lock level, the OSSI,
     64            *                      the OSSR State and the AOE(automatic output enable)
     65            *                   - Enable/Disable the TIM peripheral Main Outputs
     66            *                   - Select the Commutation event
     67            *                   - Set/Reset the Capture Compare Preload Control bit
     68            *                              
     69            *          5. TIM interrupts, DMA and flags management
     70            *                   - Enable/Disable interrupt sources
     71            *                   - Get flags status
     72            *                   - Clear flags/ Pending bits
     73            *                   - Enable/Disable DMA requests 
     74            *                   - Configure DMA burst mode
     75            *                   - Select CaptureCompare DMA request  
     76            *              
     77            *          6. TIM clocks management: this group includes all needed functions 
     78            *             to configure the clock controller unit:
     79            *                   - Select internal/External clock
     80            *                   - Select the external clock mode: ETR(Mode1/Mode2), TIx or ITRx
     81            *         
     82            *          7. TIM synchronization management: this group includes all needed 
     83            *             functions to configure the Synchronization unit:
     84            *                   - Select Input Trigger  
     85            *                   - Select Output Trigger  
     86            *                   - Select Master Slave Mode 
     87            *                   - ETR Configuration when used as external trigger   
     88            *     
     89            *          8. TIM specific interface management, this group includes all 
     90            *             needed functions to use the specific TIM interface:
     91            *                   - Encoder Interface Configuration
     92            *                   - Select Hall Sensor   
     93            *         
     94            *          9. TIM specific remapping management includes the Remapping 
     95            *             configuration of specific timers               
     96            *   
     97            *  @endverbatim
     98            *    
     99            ******************************************************************************
    100            * @attention
    101            *
    102            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    103            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    104            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    105            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    106            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    107            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    108            *
    109            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    110            ******************************************************************************
    111            */
    112          
    113          /* Includes ------------------------------------------------------------------*/
    114          #include "stm32f4xx_tim.h"
    115          #include "stm32f4xx_rcc.h"
    116          
    117          /** @addtogroup STM32F4xx_StdPeriph_Driver
    118            * @{
    119            */
    120          
    121          /** @defgroup TIM 
    122            * @brief TIM driver modules
    123            * @{
    124            */
    125          
    126          /* Private typedef -----------------------------------------------------------*/
    127          /* Private define ------------------------------------------------------------*/
    128          
    129          /* ---------------------- TIM registers bit mask ------------------------ */
    130          #define SMCR_ETR_MASK      ((uint16_t)0x00FF) 
    131          #define CCMR_OFFSET        ((uint16_t)0x0018)
    132          #define CCER_CCE_SET       ((uint16_t)0x0001)  
    133          #define	CCER_CCNE_SET      ((uint16_t)0x0004) 
    134          #define CCMR_OC13M_MASK    ((uint16_t)0xFF8F)
    135          #define CCMR_OC24M_MASK    ((uint16_t)0x8FFF) 
    136          
    137          /* Private macro -------------------------------------------------------------*/
    138          /* Private variables ---------------------------------------------------------*/
    139          /* Private function prototypes -----------------------------------------------*/
    140          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    141                                 uint16_t TIM_ICFilter);
    142          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    143                                 uint16_t TIM_ICFilter);
    144          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    145                                 uint16_t TIM_ICFilter);
    146          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    147                                 uint16_t TIM_ICFilter);
    148          
    149          /* Private functions ---------------------------------------------------------*/
    150          
    151          /** @defgroup TIM_Private_Functions
    152            * @{
    153            */
    154          
    155          /** @defgroup TIM_Group1 TimeBase management functions
    156           *  @brief   TimeBase management functions 
    157           *
    158          @verbatim   
    159           ===============================================================================
    160                                 TimeBase management functions
    161           ===============================================================================  
    162            
    163                 ===================================================================      
    164                        TIM Driver: how to use it in Timing(Time base) Mode
    165                 =================================================================== 
    166                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    167                 
    168                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    169                              
    170                 2. Fill the TIM_TimeBaseInitStruct with the desired parameters.
    171                 
    172                 3. Call TIM_TimeBaseInit(TIMx, &TIM_TimeBaseInitStruct) to configure the Time Base unit
    173                    with the corresponding configuration
    174                    
    175                 4. Enable the NVIC if you need to generate the update interrupt. 
    176                    
    177                 5. Enable the corresponding interrupt using the function TIM_ITConfig(TIMx, TIM_IT_Update) 
    178                 
    179                 6. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    180                       
    181                 Note1: All other functions can be used separately to modify, if needed,
    182                    a specific feature of the Timer. 
    183          
    184          @endverbatim
    185            * @{
    186            */
    187            
    188          /**
    189            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    190            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    191            * @retval None
    192          
    193            */
    194          void TIM_DeInit(TIM_TypeDef* TIMx)
    195          {
    196            /* Check the parameters */
    197            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    198           
    199            if (TIMx == TIM1)
    200            {
    201              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    202              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
    203            } 
    204            else if (TIMx == TIM2) 
    205            {     
    206              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    207              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    208            }  
    209            else if (TIMx == TIM3)
    210            { 
    211              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    212              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    213            }  
    214            else if (TIMx == TIM4)
    215            { 
    216              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    217              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    218            }  
    219            else if (TIMx == TIM5)
    220            {      
    221              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    222              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
    223            }  
    224            else if (TIMx == TIM6)  
    225            {    
    226              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    227              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
    228            }  
    229            else if (TIMx == TIM7)
    230            {      
    231              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    232              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
    233            }  
    234            else if (TIMx == TIM8)
    235            {      
    236              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    237              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
    238            }  
    239            else if (TIMx == TIM9)
    240            {      
    241              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    242              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
    243             }  
    244            else if (TIMx == TIM10)
    245            {      
    246              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    247              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
    248            }  
    249            else if (TIMx == TIM11) 
    250            {     
    251              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    252              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
    253            }  
    254            else if (TIMx == TIM12)
    255            {      
    256              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
    257              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
    258            }  
    259            else if (TIMx == TIM13) 
    260            {       
    261              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
    262              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
    263            }  
    264            else
    265            { 
    266              if (TIMx == TIM14) 
    267              {     
    268                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
    269                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    270              }   
    271            }
    272          }
    273          
    274          /**
    275            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    276            *         the specified parameters in the TIM_TimeBaseInitStruct.
    277            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    278            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
    279            *         that contains the configuration information for the specified TIM peripheral.
    280            * @retval None
    281            */
    282          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    283          {
    284            uint16_t tmpcr1 = 0;
    285          
    286            /* Check the parameters */
    287            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    288            assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    289            assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    290          
    291            tmpcr1 = TIMx->CR1;  
    292          
    293            if((TIMx == TIM1) || (TIMx == TIM8)||
    294               (TIMx == TIM2) || (TIMx == TIM3)||
    295               (TIMx == TIM4) || (TIMx == TIM5)) 
    296            {
    297              /* Select the Counter Mode */
    298              tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    299              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
    300            }
    301           
    302            if((TIMx != TIM6) && (TIMx != TIM7))
    303            {
    304              /* Set the clock division */
    305              tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
    306              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
    307            }
    308          
    309            TIMx->CR1 = tmpcr1;
    310          
    311            /* Set the Autoreload value */
    312            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    313           
    314            /* Set the Prescaler value */
    315            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    316              
    317            if ((TIMx == TIM1) || (TIMx == TIM8))  
    318            {
    319              /* Set the Repetition Counter value */
    320              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
    321            }
    322          
    323            /* Generate an update event to reload the Prescaler 
    324               and the repetition counter(only for TIM1 and TIM8) value immediatly */
    325            TIMx->EGR = TIM_PSCReloadMode_Immediate;          
    326          }
    327          
    328          /**
    329            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    330            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    331            *         structure which will be initialized.
    332            * @retval None
    333            */
    334          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    335          {
    336            /* Set the default configuration */
    337            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
    338            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
    339            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    340            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    341            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
    342          }
    343          
    344          /**
    345            * @brief  Configures the TIMx Prescaler.
    346            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    347            * @param  Prescaler: specifies the Prescaler Register value
    348            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    349            *          This parameter can be one of the following values:
    350            *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
    351            *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
    352            * @retval None
    353            */
    354          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
    355          {
    356            /* Check the parameters */
    357            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    358            assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    359            /* Set the Prescaler value */
    360            TIMx->PSC = Prescaler;
    361            /* Set or reset the UG Bit */
    362            TIMx->EGR = TIM_PSCReloadMode;
    363          }
    364          
    365          /**
    366            * @brief  Specifies the TIMx Counter Mode to be used.
    367            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    368            * @param  TIM_CounterMode: specifies the Counter Mode to be used
    369            *          This parameter can be one of the following values:
    370            *            @arg TIM_CounterMode_Up: TIM Up Counting Mode
    371            *            @arg TIM_CounterMode_Down: TIM Down Counting Mode
    372            *            @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    373            *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    374            *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    375            * @retval None
    376            */
    377          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
    378          {
    379            uint16_t tmpcr1 = 0;
    380          
    381            /* Check the parameters */
    382            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    383            assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    384          
    385            tmpcr1 = TIMx->CR1;
    386          
    387            /* Reset the CMS and DIR Bits */
    388            tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
    389          
    390            /* Set the Counter Mode */
    391            tmpcr1 |= TIM_CounterMode;
    392          
    393            /* Write to TIMx CR1 register */
    394            TIMx->CR1 = tmpcr1;
    395          }
    396          
    397          /**
    398            * @brief  Sets the TIMx Counter Register value
    399            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    400            * @param  Counter: specifies the Counter register new value.
    401            * @retval None
    402            */
    403          void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
    404          {
    405            /* Check the parameters */
    406             assert_param(IS_TIM_ALL_PERIPH(TIMx));
    407          
    408            /* Set the Counter Register value */
    409            TIMx->CNT = Counter;
    410          }
    411          
    412          /**
    413            * @brief  Sets the TIMx Autoreload Register value
    414            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    415            * @param  Autoreload: specifies the Autoreload register new value.
    416            * @retval None
    417            */
    418          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
    419          {
    420            /* Check the parameters */
    421            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    422            
    423            /* Set the Autoreload Register value */
    424            TIMx->ARR = Autoreload;
    425          }
    426          
    427          /**
    428            * @brief  Gets the TIMx Counter value.
    429            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    430            * @retval Counter Register value
    431            */
    432          uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
    433          {
    434            /* Check the parameters */
    435            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    436          
    437            /* Get the Counter Register value */
    438            return TIMx->CNT;
    439          }
    440          
    441          /**
    442            * @brief  Gets the TIMx Prescaler value.
    443            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    444            * @retval Prescaler Register value.
    445            */
    446          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
    447          {
    448            /* Check the parameters */
    449            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    450          
    451            /* Get the Prescaler Register value */
    452            return TIMx->PSC;
    453          }
    454          
    455          /**
    456            * @brief  Enables or Disables the TIMx Update event.
    457            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    458            * @param  NewState: new state of the TIMx UDIS bit
    459            *          This parameter can be: ENABLE or DISABLE.
    460            * @retval None
    461            */
    462          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    463          {
    464            /* Check the parameters */
    465            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    466            assert_param(IS_FUNCTIONAL_STATE(NewState));
    467          
    468            if (NewState != DISABLE)
    469            {
    470              /* Set the Update Disable Bit */
    471              TIMx->CR1 |= TIM_CR1_UDIS;
    472            }
    473            else
    474            {
    475              /* Reset the Update Disable Bit */
    476              TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
    477            }
    478          }
    479          
    480          /**
    481            * @brief  Configures the TIMx Update Request Interrupt source.
    482            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    483            * @param  TIM_UpdateSource: specifies the Update source.
    484            *          This parameter can be one of the following values:
    485            *            @arg TIM_UpdateSource_Global: Source of update is the counter
    486            *                 overflow/underflow or the setting of UG bit, or an update
    487            *                 generation through the slave mode controller.
    488            *            @arg TIM_UpdateSource_Regular: Source of update is counter overflow/underflow.
    489            * @retval None
    490            */
    491          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
    492          {
    493            /* Check the parameters */
    494            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    495            assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
    496          
    497            if (TIM_UpdateSource != TIM_UpdateSource_Global)
    498            {
    499              /* Set the URS Bit */
    500              TIMx->CR1 |= TIM_CR1_URS;
    501            }
    502            else
    503            {
    504              /* Reset the URS Bit */
    505              TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
    506            }
    507          }
    508          
    509          /**
    510            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
    511            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    512            * @param  NewState: new state of the TIMx peripheral Preload register
    513            *          This parameter can be: ENABLE or DISABLE.
    514            * @retval None
    515            */
    516          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    517          {
    518            /* Check the parameters */
    519            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    520            assert_param(IS_FUNCTIONAL_STATE(NewState));
    521          
    522            if (NewState != DISABLE)
    523            {
    524              /* Set the ARR Preload Bit */
    525              TIMx->CR1 |= TIM_CR1_ARPE;
    526            }
    527            else
    528            {
    529              /* Reset the ARR Preload Bit */
    530              TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
    531            }
    532          }
    533          
    534          /**
    535            * @brief  Selects the TIMx's One Pulse Mode.
    536            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    537            * @param  TIM_OPMode: specifies the OPM Mode to be used.
    538            *          This parameter can be one of the following values:
    539            *            @arg TIM_OPMode_Single
    540            *            @arg TIM_OPMode_Repetitive
    541            * @retval None
    542            */
    543          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
    544          {
    545            /* Check the parameters */
    546            assert_param(IS_TIM_ALL_PERIPH(TIMx));
    547            assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
    548          
    549            /* Reset the OPM Bit */
    550            TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
    551          
    552            /* Configure the OPM Mode */
    553            TIMx->CR1 |= TIM_OPMode;
    554          }
    555          
    556          /**
    557            * @brief  Sets the TIMx Clock Division value.
    558            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    559            * @param  TIM_CKD: specifies the clock division value.
    560            *          This parameter can be one of the following value:
    561            *            @arg TIM_CKD_DIV1: TDTS = Tck_tim
    562            *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
    563            *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
    564            * @retval None
    565            */
    566          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
    567          {
    568            /* Check the parameters */
    569            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
    570            assert_param(IS_TIM_CKD_DIV(TIM_CKD));
    571          
    572            /* Reset the CKD Bits */
    573            TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
    574          
    575            /* Set the CKD value */
    576            TIMx->CR1 |= TIM_CKD;
    577          }
    578          
    579          /**
    580            * @brief  Enables or disables the specified TIM peripheral.
    581            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
    582            * @param  NewState: new state of the TIMx peripheral.
    583            *          This parameter can be: ENABLE or DISABLE.
    584            * @retval None
    585            */
    586          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    587          {
    588            /* Check the parameters */
    589            assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
    590            assert_param(IS_FUNCTIONAL_STATE(NewState));
    591            
    592            if (NewState != DISABLE)
    593            {
    594              /* Enable the TIM Counter */
    595              TIMx->CR1 |= TIM_CR1_CEN;
    596            }
    597            else
    598            {
    599              /* Disable the TIM Counter */
    600              TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
    601            }
    602          }
    603          /**
    604            * @}
    605            */
    606          
    607          /** @defgroup TIM_Group2 Output Compare management functions
    608           *  @brief    Output Compare management functions 
    609           *
    610          @verbatim   
    611           ===============================================================================
    612                                  Output Compare management functions
    613           ===============================================================================  
    614             
    615                 ===================================================================      
    616                        TIM Driver: how to use it in Output Compare Mode
    617                 =================================================================== 
    618                 To use the Timer in Output Compare mode, the following steps are mandatory:
    619                 
    620                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    621                 
    622                 2. Configure the TIM pins by configuring the corresponding GPIO pins
    623                 
    624                 2. Configure the Time base unit as described in the first part of this driver, 
    625                    if needed, else the Timer will run with the default configuration:
    626                    - Autoreload value = 0xFFFF
    627                    - Prescaler value = 0x0000
    628                    - Counter mode = Up counting
    629                    - Clock Division = TIM_CKD_DIV1
    630                    
    631                 3. Fill the TIM_OCInitStruct with the desired parameters including:
    632                    - The TIM Output Compare mode: TIM_OCMode
    633                    - TIM Output State: TIM_OutputState
    634                    - TIM Pulse value: TIM_Pulse
    635                    - TIM Output Compare Polarity : TIM_OCPolarity
    636                 
    637                 4. Call TIM_OCxInit(TIMx, &TIM_OCInitStruct) to configure the desired channel with the 
    638                    corresponding configuration
    639                 
    640                 5. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    641                 
    642                 Note1: All other functions can be used separately to modify, if needed,
    643                        a specific feature of the Timer. 
    644                    
    645                 Note2: In case of PWM mode, this function is mandatory:
    646                        TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE); 
    647                        
    648                 Note3: If the corresponding interrupt or DMA request are needed, the user should:
    649                          1. Enable the NVIC (or the DMA) to use the TIM interrupts (or DMA requests). 
    650                          2. Enable the corresponding interrupt (or DMA request) using the function 
    651                             TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx))   
    652          
    653          @endverbatim
    654            * @{
    655            */
    656          
    657          /**
    658            * @brief  Initializes the TIMx Channel1 according to the specified parameters in
    659            *         the TIM_OCInitStruct.
    660            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    661            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    662            *         the configuration information for the specified TIM peripheral.
    663            * @retval None
    664            */
    665          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    666          {
    667            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    668             
    669            /* Check the parameters */
    670            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
    671            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    672            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    673            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    674          
    675            /* Disable the Channel 1: Reset the CC1E Bit */
    676            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
    677            
    678            /* Get the TIMx CCER register value */
    679            tmpccer = TIMx->CCER;
    680            /* Get the TIMx CR2 register value */
    681            tmpcr2 =  TIMx->CR2;
    682            
    683            /* Get the TIMx CCMR1 register value */
    684            tmpccmrx = TIMx->CCMR1;
    685              
    686            /* Reset the Output Compare Mode Bits */
    687            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
    688            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
    689            /* Select the Output Compare Mode */
    690            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    691            
    692            /* Reset the Output Polarity level */
    693            tmpccer &= (uint16_t)~TIM_CCER_CC1P;
    694            /* Set the Output Compare Polarity */
    695            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    696            
    697            /* Set the Output State */
    698            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    699              
    700            if((TIMx == TIM1) || (TIMx == TIM8))
    701            {
    702              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    703              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    704              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    705              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    706              
    707              /* Reset the Output N Polarity level */
    708              tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
    709              /* Set the Output N Polarity */
    710              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    711              /* Reset the Output N State */
    712              tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
    713              
    714              /* Set the Output N State */
    715              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    716              /* Reset the Output Compare and Output Compare N IDLE State */
    717              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    718              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    719              /* Set the Output Idle state */
    720              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    721              /* Set the Output N Idle state */
    722              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
    723            }
    724            /* Write to TIMx CR2 */
    725            TIMx->CR2 = tmpcr2;
    726            
    727            /* Write to TIMx CCMR1 */
    728            TIMx->CCMR1 = tmpccmrx;
    729            
    730            /* Set the Capture Compare Register value */
    731            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    732            
    733            /* Write to TIMx CCER */
    734            TIMx->CCER = tmpccer;
    735          }
    736          
    737          /**
    738            * @brief  Initializes the TIMx Channel2 according to the specified parameters 
    739            *         in the TIM_OCInitStruct.
    740            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
    741            *         peripheral.
    742            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    743            *         the configuration information for the specified TIM peripheral.
    744            * @retval None
    745            */
    746          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    747          {
    748            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    749             
    750            /* Check the parameters */
    751            assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
    752            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    753            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    754            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    755          
    756            /* Disable the Channel 2: Reset the CC2E Bit */
    757            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
    758            
    759            /* Get the TIMx CCER register value */  
    760            tmpccer = TIMx->CCER;
    761            /* Get the TIMx CR2 register value */
    762            tmpcr2 =  TIMx->CR2;
    763            
    764            /* Get the TIMx CCMR1 register value */
    765            tmpccmrx = TIMx->CCMR1;
    766              
    767            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    768            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
    769            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
    770            
    771            /* Select the Output Compare Mode */
    772            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    773            
    774            /* Reset the Output Polarity level */
    775            tmpccer &= (uint16_t)~TIM_CCER_CC2P;
    776            /* Set the Output Compare Polarity */
    777            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    778            
    779            /* Set the Output State */
    780            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    781              
    782            if((TIMx == TIM1) || (TIMx == TIM8))
    783            {
    784              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    785              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    786              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    787              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    788              
    789              /* Reset the Output N Polarity level */
    790              tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
    791              /* Set the Output N Polarity */
    792              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    793              /* Reset the Output N State */
    794              tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
    795              
    796              /* Set the Output N State */
    797              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    798              /* Reset the Output Compare and Output Compare N IDLE State */
    799              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    800              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    801              /* Set the Output Idle state */
    802              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    803              /* Set the Output N Idle state */
    804              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
    805            }
    806            /* Write to TIMx CR2 */
    807            TIMx->CR2 = tmpcr2;
    808            
    809            /* Write to TIMx CCMR1 */
    810            TIMx->CCMR1 = tmpccmrx;
    811            
    812            /* Set the Capture Compare Register value */
    813            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    814            
    815            /* Write to TIMx CCER */
    816            TIMx->CCER = tmpccer;
    817          }
    818          
    819          /**
    820            * @brief  Initializes the TIMx Channel3 according to the specified parameters
    821            *         in the TIM_OCInitStruct.
    822            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    823            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    824            *         the configuration information for the specified TIM peripheral.
    825            * @retval None
    826            */
    827          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    828          {
    829            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    830             
    831            /* Check the parameters */
    832            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    833            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    834            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    835            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    836          
    837            /* Disable the Channel 3: Reset the CC2E Bit */
    838            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
    839            
    840            /* Get the TIMx CCER register value */
    841            tmpccer = TIMx->CCER;
    842            /* Get the TIMx CR2 register value */
    843            tmpcr2 =  TIMx->CR2;
    844            
    845            /* Get the TIMx CCMR2 register value */
    846            tmpccmrx = TIMx->CCMR2;
    847              
    848            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    849            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
    850            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
    851            /* Select the Output Compare Mode */
    852            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    853            
    854            /* Reset the Output Polarity level */
    855            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
    856            /* Set the Output Compare Polarity */
    857            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    858            
    859            /* Set the Output State */
    860            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    861              
    862            if((TIMx == TIM1) || (TIMx == TIM8))
    863            {
    864              assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    865              assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    866              assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    867              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    868              
    869              /* Reset the Output N Polarity level */
    870              tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
    871              /* Set the Output N Polarity */
    872              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    873              /* Reset the Output N State */
    874              tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
    875              
    876              /* Set the Output N State */
    877              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    878              /* Reset the Output Compare and Output Compare N IDLE State */
    879              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    880              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    881              /* Set the Output Idle state */
    882              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    883              /* Set the Output N Idle state */
    884              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
    885            }
    886            /* Write to TIMx CR2 */
    887            TIMx->CR2 = tmpcr2;
    888            
    889            /* Write to TIMx CCMR2 */
    890            TIMx->CCMR2 = tmpccmrx;
    891            
    892            /* Set the Capture Compare Register value */
    893            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    894            
    895            /* Write to TIMx CCER */
    896            TIMx->CCER = tmpccer;
    897          }
    898          
    899          /**
    900            * @brief  Initializes the TIMx Channel4 according to the specified parameters
    901            *         in the TIM_OCInitStruct.
    902            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    903            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    904            *         the configuration information for the specified TIM peripheral.
    905            * @retval None
    906            */
    907          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    908          {
    909            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    910             
    911            /* Check the parameters */
    912            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
    913            assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    914            assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    915            assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    916          
    917            /* Disable the Channel 4: Reset the CC4E Bit */
    918            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
    919            
    920            /* Get the TIMx CCER register value */
    921            tmpccer = TIMx->CCER;
    922            /* Get the TIMx CR2 register value */
    923            tmpcr2 =  TIMx->CR2;
    924            
    925            /* Get the TIMx CCMR2 register value */
    926            tmpccmrx = TIMx->CCMR2;
    927              
    928            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    929            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
    930            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
    931            
    932            /* Select the Output Compare Mode */
    933            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    934            
    935            /* Reset the Output Polarity level */
    936            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
    937            /* Set the Output Compare Polarity */
    938            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    939            
    940            /* Set the Output State */
    941            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    942            
    943            if((TIMx == TIM1) || (TIMx == TIM8))
    944            {
    945              assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    946              /* Reset the Output Compare IDLE State */
    947              tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
    948              /* Set the Output Idle state */
    949              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
    950            }
    951            /* Write to TIMx CR2 */
    952            TIMx->CR2 = tmpcr2;
    953            
    954            /* Write to TIMx CCMR2 */  
    955            TIMx->CCMR2 = tmpccmrx;
    956              
    957            /* Set the Capture Compare Register value */
    958            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    959            
    960            /* Write to TIMx CCER */
    961            TIMx->CCER = tmpccer;
    962          }
    963          
    964          /**
    965            * @brief  Fills each TIM_OCInitStruct member with its default value.
    966            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
    967            *         be initialized.
    968            * @retval None
    969            */
    970          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    971          {
    972            /* Set the default configuration */
    973            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    974            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
    975            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
    976            TIM_OCInitStruct->TIM_Pulse = 0x00000000;
    977            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    978            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
    979            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
    980            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
    981          }
    982          
    983          /**
    984            * @brief  Selects the TIM Output Compare Mode.
    985            * @note   This function disables the selected channel before changing the Output
    986            *         Compare Mode. If needed, user has to enable this channel using
    987            *         TIM_CCxCmd() and TIM_CCxNCmd() functions.
    988            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    989            * @param  TIM_Channel: specifies the TIM Channel
    990            *          This parameter can be one of the following values:
    991            *            @arg TIM_Channel_1: TIM Channel 1
    992            *            @arg TIM_Channel_2: TIM Channel 2
    993            *            @arg TIM_Channel_3: TIM Channel 3
    994            *            @arg TIM_Channel_4: TIM Channel 4
    995            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
    996            *           This parameter can be one of the following values:
    997            *            @arg TIM_OCMode_Timing
    998            *            @arg TIM_OCMode_Active
    999            *            @arg TIM_OCMode_Toggle
   1000            *            @arg TIM_OCMode_PWM1
   1001            *            @arg TIM_OCMode_PWM2
   1002            *            @arg TIM_ForcedAction_Active
   1003            *            @arg TIM_ForcedAction_InActive
   1004            * @retval None
   1005            */
   1006          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
   1007          {
   1008            uint32_t tmp = 0;
   1009            uint16_t tmp1 = 0;
   1010          
   1011            /* Check the parameters */
   1012            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1013            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1014            assert_param(IS_TIM_OCM(TIM_OCMode));
   1015          
   1016            tmp = (uint32_t) TIMx;
   1017            tmp += CCMR_OFFSET;
   1018          
   1019            tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
   1020          
   1021            /* Disable the Channel: Reset the CCxE Bit */
   1022            TIMx->CCER &= (uint16_t) ~tmp1;
   1023          
   1024            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   1025            {
   1026              tmp += (TIM_Channel>>1);
   1027          
   1028              /* Reset the OCxM bits in the CCMRx register */
   1029              *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
   1030             
   1031              /* Configure the OCxM bits in the CCMRx register */
   1032              *(__IO uint32_t *) tmp |= TIM_OCMode;
   1033            }
   1034            else
   1035            {
   1036              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
   1037          
   1038              /* Reset the OCxM bits in the CCMRx register */
   1039              *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
   1040              
   1041              /* Configure the OCxM bits in the CCMRx register */
   1042              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
   1043            }
   1044          }
   1045          
   1046          /**
   1047            * @brief  Sets the TIMx Capture Compare1 Register value
   1048            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1049            * @param  Compare1: specifies the Capture Compare1 register new value.
   1050            * @retval None
   1051            */
   1052          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
   1053          {
   1054            /* Check the parameters */
   1055            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1056          
   1057            /* Set the Capture Compare1 Register value */
   1058            TIMx->CCR1 = Compare1;
   1059          }
   1060          
   1061          /**
   1062            * @brief  Sets the TIMx Capture Compare2 Register value
   1063            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1064            *         peripheral.
   1065            * @param  Compare2: specifies the Capture Compare2 register new value.
   1066            * @retval None
   1067            */
   1068          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
   1069          {
   1070            /* Check the parameters */
   1071            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1072          
   1073            /* Set the Capture Compare2 Register value */
   1074            TIMx->CCR2 = Compare2;
   1075          }
   1076          
   1077          /**
   1078            * @brief  Sets the TIMx Capture Compare3 Register value
   1079            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1080            * @param  Compare3: specifies the Capture Compare3 register new value.
   1081            * @retval None
   1082            */
   1083          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
   1084          {
   1085            /* Check the parameters */
   1086            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1087          
   1088            /* Set the Capture Compare3 Register value */
   1089            TIMx->CCR3 = Compare3;
   1090          }
   1091          
   1092          /**
   1093            * @brief  Sets the TIMx Capture Compare4 Register value
   1094            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1095            * @param  Compare4: specifies the Capture Compare4 register new value.
   1096            * @retval None
   1097            */
   1098          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
   1099          {
   1100            /* Check the parameters */
   1101            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1102          
   1103            /* Set the Capture Compare4 Register value */
   1104            TIMx->CCR4 = Compare4;
   1105          }
   1106          
   1107          /**
   1108            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
   1109            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1110            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1111            *          This parameter can be one of the following values:
   1112            *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
   1113            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
   1114            * @retval None
   1115            */
   1116          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1117          {
   1118            uint16_t tmpccmr1 = 0;
   1119          
   1120            /* Check the parameters */
   1121            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1122            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1123            tmpccmr1 = TIMx->CCMR1;
   1124          
   1125            /* Reset the OC1M Bits */
   1126            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
   1127          
   1128            /* Configure The Forced output Mode */
   1129            tmpccmr1 |= TIM_ForcedAction;
   1130          
   1131            /* Write to TIMx CCMR1 register */
   1132            TIMx->CCMR1 = tmpccmr1;
   1133          }
   1134          
   1135          /**
   1136            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
   1137            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1138            *         peripheral.
   1139            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1140            *          This parameter can be one of the following values:
   1141            *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
   1142            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
   1143            * @retval None
   1144            */
   1145          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1146          {
   1147            uint16_t tmpccmr1 = 0;
   1148          
   1149            /* Check the parameters */
   1150            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1151            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1152            tmpccmr1 = TIMx->CCMR1;
   1153          
   1154            /* Reset the OC2M Bits */
   1155            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
   1156          
   1157            /* Configure The Forced output Mode */
   1158            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   1159          
   1160            /* Write to TIMx CCMR1 register */
   1161            TIMx->CCMR1 = tmpccmr1;
   1162          }
   1163          
   1164          /**
   1165            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1166            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1167            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1168            *          This parameter can be one of the following values:
   1169            *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1170            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1171            * @retval None
   1172            */
   1173          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1174          {
   1175            uint16_t tmpccmr2 = 0;
   1176          
   1177            /* Check the parameters */
   1178            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1179            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1180          
   1181            tmpccmr2 = TIMx->CCMR2;
   1182          
   1183            /* Reset the OC1M Bits */
   1184            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
   1185          
   1186            /* Configure The Forced output Mode */
   1187            tmpccmr2 |= TIM_ForcedAction;
   1188          
   1189            /* Write to TIMx CCMR2 register */
   1190            TIMx->CCMR2 = tmpccmr2;
   1191          }
   1192          
   1193          /**
   1194            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1195            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1196            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1197            *          This parameter can be one of the following values:
   1198            *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1199            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1200            * @retval None
   1201            */
   1202          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1203          {
   1204            uint16_t tmpccmr2 = 0;
   1205          
   1206            /* Check the parameters */
   1207            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1208            assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1209            tmpccmr2 = TIMx->CCMR2;
   1210          
   1211            /* Reset the OC2M Bits */
   1212            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
   1213          
   1214            /* Configure The Forced output Mode */
   1215            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   1216          
   1217            /* Write to TIMx CCMR2 register */
   1218            TIMx->CCMR2 = tmpccmr2;
   1219          }
   1220          
   1221          /**
   1222            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1223            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1224            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1225            *          This parameter can be one of the following values:
   1226            *            @arg TIM_OCPreload_Enable
   1227            *            @arg TIM_OCPreload_Disable
   1228            * @retval None
   1229            */
   1230          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1231          {
   1232            uint16_t tmpccmr1 = 0;
   1233          
   1234            /* Check the parameters */
   1235            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1236            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1237          
   1238            tmpccmr1 = TIMx->CCMR1;
   1239          
   1240            /* Reset the OC1PE Bit */
   1241            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
   1242          
   1243            /* Enable or Disable the Output Compare Preload feature */
   1244            tmpccmr1 |= TIM_OCPreload;
   1245          
   1246            /* Write to TIMx CCMR1 register */
   1247            TIMx->CCMR1 = tmpccmr1;
   1248          }
   1249          
   1250          /**
   1251            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1252            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1253            *         peripheral.
   1254            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1255            *          This parameter can be one of the following values:
   1256            *            @arg TIM_OCPreload_Enable
   1257            *            @arg TIM_OCPreload_Disable
   1258            * @retval None
   1259            */
   1260          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1261          {
   1262            uint16_t tmpccmr1 = 0;
   1263          
   1264            /* Check the parameters */
   1265            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1266            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1267          
   1268            tmpccmr1 = TIMx->CCMR1;
   1269          
   1270            /* Reset the OC2PE Bit */
   1271            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
   1272          
   1273            /* Enable or Disable the Output Compare Preload feature */
   1274            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   1275          
   1276            /* Write to TIMx CCMR1 register */
   1277            TIMx->CCMR1 = tmpccmr1;
   1278          }
   1279          
   1280          /**
   1281            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1282            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1283            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1284            *          This parameter can be one of the following values:
   1285            *            @arg TIM_OCPreload_Enable
   1286            *            @arg TIM_OCPreload_Disable
   1287            * @retval None
   1288            */
   1289          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1290          {
   1291            uint16_t tmpccmr2 = 0;
   1292          
   1293            /* Check the parameters */
   1294            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1295            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1296          
   1297            tmpccmr2 = TIMx->CCMR2;
   1298          
   1299            /* Reset the OC3PE Bit */
   1300            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
   1301          
   1302            /* Enable or Disable the Output Compare Preload feature */
   1303            tmpccmr2 |= TIM_OCPreload;
   1304          
   1305            /* Write to TIMx CCMR2 register */
   1306            TIMx->CCMR2 = tmpccmr2;
   1307          }
   1308          
   1309          /**
   1310            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1311            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1312            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1313            *          This parameter can be one of the following values:
   1314            *            @arg TIM_OCPreload_Enable
   1315            *            @arg TIM_OCPreload_Disable
   1316            * @retval None
   1317            */
   1318          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1319          {
   1320            uint16_t tmpccmr2 = 0;
   1321          
   1322            /* Check the parameters */
   1323            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1324            assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1325          
   1326            tmpccmr2 = TIMx->CCMR2;
   1327          
   1328            /* Reset the OC4PE Bit */
   1329            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
   1330          
   1331            /* Enable or Disable the Output Compare Preload feature */
   1332            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   1333          
   1334            /* Write to TIMx CCMR2 register */
   1335            TIMx->CCMR2 = tmpccmr2;
   1336          }
   1337          
   1338          /**
   1339            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1340            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1341            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1342            *          This parameter can be one of the following values:
   1343            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1344            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1345            * @retval None
   1346            */
   1347          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1348          {
   1349            uint16_t tmpccmr1 = 0;
   1350          
   1351            /* Check the parameters */
   1352            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1353            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1354          
   1355            /* Get the TIMx CCMR1 register value */
   1356            tmpccmr1 = TIMx->CCMR1;
   1357          
   1358            /* Reset the OC1FE Bit */
   1359            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
   1360          
   1361            /* Enable or Disable the Output Compare Fast Bit */
   1362            tmpccmr1 |= TIM_OCFast;
   1363          
   1364            /* Write to TIMx CCMR1 */
   1365            TIMx->CCMR1 = tmpccmr1;
   1366          }
   1367          
   1368          /**
   1369            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1370            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1371            *         peripheral.
   1372            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1373            *          This parameter can be one of the following values:
   1374            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1375            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1376            * @retval None
   1377            */
   1378          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1379          {
   1380            uint16_t tmpccmr1 = 0;
   1381          
   1382            /* Check the parameters */
   1383            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1384            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1385          
   1386            /* Get the TIMx CCMR1 register value */
   1387            tmpccmr1 = TIMx->CCMR1;
   1388          
   1389            /* Reset the OC2FE Bit */
   1390            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
   1391          
   1392            /* Enable or Disable the Output Compare Fast Bit */
   1393            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   1394          
   1395            /* Write to TIMx CCMR1 */
   1396            TIMx->CCMR1 = tmpccmr1;
   1397          }
   1398          
   1399          /**
   1400            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1401            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1402            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1403            *          This parameter can be one of the following values:
   1404            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1405            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1406            * @retval None
   1407            */
   1408          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1409          {
   1410            uint16_t tmpccmr2 = 0;
   1411            
   1412            /* Check the parameters */
   1413            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1414            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1415          
   1416            /* Get the TIMx CCMR2 register value */
   1417            tmpccmr2 = TIMx->CCMR2;
   1418          
   1419            /* Reset the OC3FE Bit */
   1420            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
   1421          
   1422            /* Enable or Disable the Output Compare Fast Bit */
   1423            tmpccmr2 |= TIM_OCFast;
   1424          
   1425            /* Write to TIMx CCMR2 */
   1426            TIMx->CCMR2 = tmpccmr2;
   1427          }
   1428          
   1429          /**
   1430            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1431            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1432            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1433            *          This parameter can be one of the following values:
   1434            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1435            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1436            * @retval None
   1437            */
   1438          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1439          {
   1440            uint16_t tmpccmr2 = 0;
   1441          
   1442            /* Check the parameters */
   1443            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1444            assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1445          
   1446            /* Get the TIMx CCMR2 register value */
   1447            tmpccmr2 = TIMx->CCMR2;
   1448          
   1449            /* Reset the OC4FE Bit */
   1450            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
   1451          
   1452            /* Enable or Disable the Output Compare Fast Bit */
   1453            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   1454          
   1455            /* Write to TIMx CCMR2 */
   1456            TIMx->CCMR2 = tmpccmr2;
   1457          }
   1458          
   1459          /**
   1460            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1461            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1462            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1463            *          This parameter can be one of the following values:
   1464            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1465            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1466            * @retval None
   1467            */
   1468          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1469          {
   1470            uint16_t tmpccmr1 = 0;
   1471          
   1472            /* Check the parameters */
   1473            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1474            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1475          
   1476            tmpccmr1 = TIMx->CCMR1;
   1477          
   1478            /* Reset the OC1CE Bit */
   1479            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
   1480          
   1481            /* Enable or Disable the Output Compare Clear Bit */
   1482            tmpccmr1 |= TIM_OCClear;
   1483          
   1484            /* Write to TIMx CCMR1 register */
   1485            TIMx->CCMR1 = tmpccmr1;
   1486          }
   1487          
   1488          /**
   1489            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1490            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1491            *         peripheral.
   1492            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1493            *          This parameter can be one of the following values:
   1494            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1495            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1496            * @retval None
   1497            */
   1498          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1499          {
   1500            uint16_t tmpccmr1 = 0;
   1501          
   1502            /* Check the parameters */
   1503            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1504            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1505          
   1506            tmpccmr1 = TIMx->CCMR1;
   1507          
   1508            /* Reset the OC2CE Bit */
   1509            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
   1510          
   1511            /* Enable or Disable the Output Compare Clear Bit */
   1512            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   1513          
   1514            /* Write to TIMx CCMR1 register */
   1515            TIMx->CCMR1 = tmpccmr1;
   1516          }
   1517          
   1518          /**
   1519            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1520            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1521            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1522            *          This parameter can be one of the following values:
   1523            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1524            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1525            * @retval None
   1526            */
   1527          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1528          {
   1529            uint16_t tmpccmr2 = 0;
   1530          
   1531            /* Check the parameters */
   1532            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1533            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1534          
   1535            tmpccmr2 = TIMx->CCMR2;
   1536          
   1537            /* Reset the OC3CE Bit */
   1538            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
   1539          
   1540            /* Enable or Disable the Output Compare Clear Bit */
   1541            tmpccmr2 |= TIM_OCClear;
   1542          
   1543            /* Write to TIMx CCMR2 register */
   1544            TIMx->CCMR2 = tmpccmr2;
   1545          }
   1546          
   1547          /**
   1548            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1549            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1550            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1551            *          This parameter can be one of the following values:
   1552            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1553            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1554            * @retval None
   1555            */
   1556          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1557          {
   1558            uint16_t tmpccmr2 = 0;
   1559          
   1560            /* Check the parameters */
   1561            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1562            assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1563          
   1564            tmpccmr2 = TIMx->CCMR2;
   1565          
   1566            /* Reset the OC4CE Bit */
   1567            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
   1568          
   1569            /* Enable or Disable the Output Compare Clear Bit */
   1570            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   1571          
   1572            /* Write to TIMx CCMR2 register */
   1573            TIMx->CCMR2 = tmpccmr2;
   1574          }
   1575          
   1576          /**
   1577            * @brief  Configures the TIMx channel 1 polarity.
   1578            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1579            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1580            *          This parameter can be one of the following values:
   1581            *            @arg TIM_OCPolarity_High: Output Compare active high
   1582            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1583            * @retval None
   1584            */
   1585          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1586          {
   1587            uint16_t tmpccer = 0;
   1588          
   1589            /* Check the parameters */
   1590            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1591            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1592          
   1593            tmpccer = TIMx->CCER;
   1594          
   1595            /* Set or Reset the CC1P Bit */
   1596            tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
   1597            tmpccer |= TIM_OCPolarity;
   1598          
   1599            /* Write to TIMx CCER register */
   1600            TIMx->CCER = tmpccer;
   1601          }
   1602          
   1603          /**
   1604            * @brief  Configures the TIMx Channel 1N polarity.
   1605            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1606            * @param  TIM_OCNPolarity: specifies the OC1N Polarity
   1607            *          This parameter can be one of the following values:
   1608            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1609            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1610            * @retval None
   1611            */
   1612          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1613          {
   1614            uint16_t tmpccer = 0;
   1615            /* Check the parameters */
   1616            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1617            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1618             
   1619            tmpccer = TIMx->CCER;
   1620          
   1621            /* Set or Reset the CC1NP Bit */
   1622            tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
   1623            tmpccer |= TIM_OCNPolarity;
   1624          
   1625            /* Write to TIMx CCER register */
   1626            TIMx->CCER = tmpccer;
   1627          }
   1628          
   1629          /**
   1630            * @brief  Configures the TIMx channel 2 polarity.
   1631            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1632            *         peripheral.
   1633            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1634            *          This parameter can be one of the following values:
   1635            *            @arg TIM_OCPolarity_High: Output Compare active high
   1636            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1637            * @retval None
   1638            */
   1639          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1640          {
   1641            uint16_t tmpccer = 0;
   1642          
   1643            /* Check the parameters */
   1644            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1645            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1646          
   1647            tmpccer = TIMx->CCER;
   1648          
   1649            /* Set or Reset the CC2P Bit */
   1650            tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
   1651            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   1652          
   1653            /* Write to TIMx CCER register */
   1654            TIMx->CCER = tmpccer;
   1655          }
   1656          
   1657          /**
   1658            * @brief  Configures the TIMx Channel 2N polarity.
   1659            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1660            * @param  TIM_OCNPolarity: specifies the OC2N Polarity
   1661            *          This parameter can be one of the following values:
   1662            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1663            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1664            * @retval None
   1665            */
   1666          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1667          {
   1668            uint16_t tmpccer = 0;
   1669          
   1670            /* Check the parameters */
   1671            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1672            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1673            
   1674            tmpccer = TIMx->CCER;
   1675          
   1676            /* Set or Reset the CC2NP Bit */
   1677            tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
   1678            tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
   1679          
   1680            /* Write to TIMx CCER register */
   1681            TIMx->CCER = tmpccer;
   1682          }
   1683          
   1684          /**
   1685            * @brief  Configures the TIMx channel 3 polarity.
   1686            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1687            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1688            *          This parameter can be one of the following values:
   1689            *            @arg TIM_OCPolarity_High: Output Compare active high
   1690            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1691            * @retval None
   1692            */
   1693          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1694          {
   1695            uint16_t tmpccer = 0;
   1696          
   1697            /* Check the parameters */
   1698            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1699            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1700          
   1701            tmpccer = TIMx->CCER;
   1702          
   1703            /* Set or Reset the CC3P Bit */
   1704            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
   1705            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   1706          
   1707            /* Write to TIMx CCER register */
   1708            TIMx->CCER = tmpccer;
   1709          }
   1710          
   1711          /**
   1712            * @brief  Configures the TIMx Channel 3N polarity.
   1713            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1714            * @param  TIM_OCNPolarity: specifies the OC3N Polarity
   1715            *          This parameter can be one of the following values:
   1716            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1717            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1718            * @retval None
   1719            */
   1720          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1721          {
   1722            uint16_t tmpccer = 0;
   1723           
   1724            /* Check the parameters */
   1725            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1726            assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1727              
   1728            tmpccer = TIMx->CCER;
   1729          
   1730            /* Set or Reset the CC3NP Bit */
   1731            tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
   1732            tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
   1733          
   1734            /* Write to TIMx CCER register */
   1735            TIMx->CCER = tmpccer;
   1736          }
   1737          
   1738          /**
   1739            * @brief  Configures the TIMx channel 4 polarity.
   1740            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1741            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1742            *          This parameter can be one of the following values:
   1743            *            @arg TIM_OCPolarity_High: Output Compare active high
   1744            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1745            * @retval None
   1746            */
   1747          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1748          {
   1749            uint16_t tmpccer = 0;
   1750          
   1751            /* Check the parameters */
   1752            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1753            assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1754          
   1755            tmpccer = TIMx->CCER;
   1756          
   1757            /* Set or Reset the CC4P Bit */
   1758            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
   1759            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   1760          
   1761            /* Write to TIMx CCER register */
   1762            TIMx->CCER = tmpccer;
   1763          }
   1764          
   1765          /**
   1766            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1767            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1768            * @param  TIM_Channel: specifies the TIM Channel
   1769            *          This parameter can be one of the following values:
   1770            *            @arg TIM_Channel_1: TIM Channel 1
   1771            *            @arg TIM_Channel_2: TIM Channel 2
   1772            *            @arg TIM_Channel_3: TIM Channel 3
   1773            *            @arg TIM_Channel_4: TIM Channel 4
   1774            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1775            *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1776            * @retval None
   1777            */
   1778          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1779          {
   1780            uint16_t tmp = 0;
   1781          
   1782            /* Check the parameters */
   1783            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   1784            assert_param(IS_TIM_CHANNEL(TIM_Channel));
   1785            assert_param(IS_TIM_CCX(TIM_CCx));
   1786          
   1787            tmp = CCER_CCE_SET << TIM_Channel;
   1788          
   1789            /* Reset the CCxE Bit */
   1790            TIMx->CCER &= (uint16_t)~ tmp;
   1791          
   1792            /* Set or reset the CCxE Bit */ 
   1793            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   1794          }
   1795          
   1796          /**
   1797            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1798            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1799            * @param  TIM_Channel: specifies the TIM Channel
   1800            *          This parameter can be one of the following values:
   1801            *            @arg TIM_Channel_1: TIM Channel 1
   1802            *            @arg TIM_Channel_2: TIM Channel 2
   1803            *            @arg TIM_Channel_3: TIM Channel 3
   1804            * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
   1805            *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   1806            * @retval None
   1807            */
   1808          void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
   1809          {
   1810            uint16_t tmp = 0;
   1811          
   1812            /* Check the parameters */
   1813            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   1814            assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   1815            assert_param(IS_TIM_CCXN(TIM_CCxN));
   1816          
   1817            tmp = CCER_CCNE_SET << TIM_Channel;
   1818          
   1819            /* Reset the CCxNE Bit */
   1820            TIMx->CCER &= (uint16_t) ~tmp;
   1821          
   1822            /* Set or reset the CCxNE Bit */ 
   1823            TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
   1824          }
   1825          /**
   1826            * @}
   1827            */
   1828          
   1829          /** @defgroup TIM_Group3 Input Capture management functions
   1830           *  @brief    Input Capture management functions 
   1831           *
   1832          @verbatim   
   1833           ===============================================================================
   1834                                Input Capture management functions
   1835           ===============================================================================  
   1836             
   1837                 ===================================================================      
   1838                        TIM Driver: how to use it in Input Capture Mode
   1839                 =================================================================== 
   1840                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1841                 
   1842                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
   1843                 
   1844                 2. Configure the TIM pins by configuring the corresponding GPIO pins
   1845                 
   1846                 2. Configure the Time base unit as described in the first part of this driver,
   1847                    if needed, else the Timer will run with the default configuration:
   1848                    - Autoreload value = 0xFFFF
   1849                    - Prescaler value = 0x0000
   1850                    - Counter mode = Up counting
   1851                    - Clock Division = TIM_CKD_DIV1
   1852                    
   1853                 3. Fill the TIM_ICInitStruct with the desired parameters including:
   1854                    - TIM Channel: TIM_Channel
   1855                    - TIM Input Capture polarity: TIM_ICPolarity
   1856                    - TIM Input Capture selection: TIM_ICSelection
   1857                    - TIM Input Capture Prescaler: TIM_ICPrescaler
   1858                    - TIM Input CApture filter value: TIM_ICFilter
   1859                 
   1860                 4. Call TIM_ICInit(TIMx, &TIM_ICInitStruct) to configure the desired channel with the 
   1861                    corresponding configuration and to measure only frequency or duty cycle of the input signal,
   1862                    or,
   1863                    Call TIM_PWMIConfig(TIMx, &TIM_ICInitStruct) to configure the desired channels with the 
   1864                    corresponding configuration and to measure the frequency and the duty cycle of the input signal
   1865                    
   1866                 5. Enable the NVIC or the DMA to read the measured frequency. 
   1867                    
   1868                 6. Enable the corresponding interrupt (or DMA request) to read the Captured value,
   1869                    using the function TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)) 
   1870                 
   1871                 7. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
   1872                 
   1873                 8. Use TIM_GetCapturex(TIMx); to read the captured value.
   1874                 
   1875                 Note1: All other functions can be used separately to modify, if needed,
   1876                        a specific feature of the Timer. 
   1877          
   1878          @endverbatim
   1879            * @{
   1880            */
   1881          
   1882          /**
   1883            * @brief  Initializes the TIM peripheral according to the specified parameters
   1884            *         in the TIM_ICInitStruct.
   1885            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1886            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1887            *         the configuration information for the specified TIM peripheral.
   1888            * @retval None
   1889            */
   1890          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1891          {
   1892            /* Check the parameters */
   1893            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   1894            assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
   1895            assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
   1896            assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
   1897            assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
   1898            
   1899            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1900            {
   1901              /* TI1 Configuration */
   1902              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1903                         TIM_ICInitStruct->TIM_ICSelection,
   1904                         TIM_ICInitStruct->TIM_ICFilter);
   1905              /* Set the Input Capture Prescaler value */
   1906              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1907            }
   1908            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   1909            {
   1910              /* TI2 Configuration */
   1911              assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1912              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1913                         TIM_ICInitStruct->TIM_ICSelection,
   1914                         TIM_ICInitStruct->TIM_ICFilter);
   1915              /* Set the Input Capture Prescaler value */
   1916              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1917            }
   1918            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   1919            {
   1920              /* TI3 Configuration */
   1921              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1922              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
   1923                         TIM_ICInitStruct->TIM_ICSelection,
   1924                         TIM_ICInitStruct->TIM_ICFilter);
   1925              /* Set the Input Capture Prescaler value */
   1926              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1927            }
   1928            else
   1929            {
   1930              /* TI4 Configuration */
   1931              assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   1932              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1933                         TIM_ICInitStruct->TIM_ICSelection,
   1934                         TIM_ICInitStruct->TIM_ICFilter);
   1935              /* Set the Input Capture Prescaler value */
   1936              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1937            }
   1938          }
   1939          
   1940          /**
   1941            * @brief  Fills each TIM_ICInitStruct member with its default value.
   1942            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
   1943            *         be initialized.
   1944            * @retval None
   1945            */
   1946          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
   1947          {
   1948            /* Set the default configuration */
   1949            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   1950            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   1951            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   1952            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   1953            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   1954          }
   1955          
   1956          /**
   1957            * @brief  Configures the TIM peripheral according to the specified parameters
   1958            *         in the TIM_ICInitStruct to measure an external PWM signal.
   1959            * @param  TIMx: where x can be  1, 2, 3, 4, 5,8, 9 or 12 to select the TIM 
   1960            *         peripheral.
   1961            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1962            *         the configuration information for the specified TIM peripheral.
   1963            * @retval None
   1964            */
   1965          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1966          {
   1967            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
   1968            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
   1969          
   1970            /* Check the parameters */
   1971            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   1972          
   1973            /* Select the Opposite Input Polarity */
   1974            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   1975            {
   1976              icoppositepolarity = TIM_ICPolarity_Falling;
   1977            }
   1978            else
   1979            {
   1980              icoppositepolarity = TIM_ICPolarity_Rising;
   1981            }
   1982            /* Select the Opposite Input */
   1983            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   1984            {
   1985              icoppositeselection = TIM_ICSelection_IndirectTI;
   1986            }
   1987            else
   1988            {
   1989              icoppositeselection = TIM_ICSelection_DirectTI;
   1990            }
   1991            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1992            {
   1993              /* TI1 Configuration */
   1994              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   1995                         TIM_ICInitStruct->TIM_ICFilter);
   1996              /* Set the Input Capture Prescaler value */
   1997              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1998              /* TI2 Configuration */
   1999              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   2000              /* Set the Input Capture Prescaler value */
   2001              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2002            }
   2003            else
   2004            { 
   2005              /* TI2 Configuration */
   2006              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2007                         TIM_ICInitStruct->TIM_ICFilter);
   2008              /* Set the Input Capture Prescaler value */
   2009              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2010              /* TI1 Configuration */
   2011              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   2012              /* Set the Input Capture Prescaler value */
   2013              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2014            }
   2015          }
   2016          
   2017          /**
   2018            * @brief  Gets the TIMx Input Capture 1 value.
   2019            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2020            * @retval Capture Compare 1 Register value.
   2021            */
   2022          uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   2023          {
   2024            /* Check the parameters */
   2025            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2026          
   2027            /* Get the Capture 1 Register value */
   2028            return TIMx->CCR1;
   2029          }
   2030          
   2031          /**
   2032            * @brief  Gets the TIMx Input Capture 2 value.
   2033            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2034            *         peripheral.
   2035            * @retval Capture Compare 2 Register value.
   2036            */
   2037          uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   2038          {
   2039            /* Check the parameters */
   2040            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2041          
   2042            /* Get the Capture 2 Register value */
   2043            return TIMx->CCR2;
   2044          }
   2045          
   2046          /**
   2047            * @brief  Gets the TIMx Input Capture 3 value.
   2048            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2049            * @retval Capture Compare 3 Register value.
   2050            */
   2051          uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   2052          {
   2053            /* Check the parameters */
   2054            assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
   2055          
   2056            /* Get the Capture 3 Register value */
   2057            return TIMx->CCR3;
   2058          }
   2059          
   2060          /**
   2061            * @brief  Gets the TIMx Input Capture 4 value.
   2062            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2063            * @retval Capture Compare 4 Register value.
   2064            */
   2065          uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   2066          {
   2067            /* Check the parameters */
   2068            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2069          
   2070            /* Get the Capture 4 Register value */
   2071            return TIMx->CCR4;
   2072          }
   2073          
   2074          /**
   2075            * @brief  Sets the TIMx Input Capture 1 prescaler.
   2076            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2077            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   2078            *          This parameter can be one of the following values:
   2079            *            @arg TIM_ICPSC_DIV1: no prescaler
   2080            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2081            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2082            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2083            * @retval None
   2084            */
   2085          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2086          {
   2087            /* Check the parameters */
   2088            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2089            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2090          
   2091            /* Reset the IC1PSC Bits */
   2092            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
   2093          
   2094            /* Set the IC1PSC value */
   2095            TIMx->CCMR1 |= TIM_ICPSC;
   2096          }
   2097          
   2098          /**
   2099            * @brief  Sets the TIMx Input Capture 2 prescaler.
   2100            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2101            *         peripheral.
   2102            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   2103            *          This parameter can be one of the following values:
   2104            *            @arg TIM_ICPSC_DIV1: no prescaler
   2105            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2106            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2107            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2108            * @retval None
   2109            */
   2110          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2111          {
   2112            /* Check the parameters */
   2113            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2114            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2115          
   2116            /* Reset the IC2PSC Bits */
   2117            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
   2118          
   2119            /* Set the IC2PSC value */
   2120            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   2121          }
   2122          
   2123          /**
   2124            * @brief  Sets the TIMx Input Capture 3 prescaler.
   2125            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2126            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   2127            *          This parameter can be one of the following values:
   2128            *            @arg TIM_ICPSC_DIV1: no prescaler
   2129            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2130            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2131            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2132            * @retval None
   2133            */
   2134          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2135          {
   2136            /* Check the parameters */
   2137            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2138            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2139          
   2140            /* Reset the IC3PSC Bits */
   2141            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
   2142          
   2143            /* Set the IC3PSC value */
   2144            TIMx->CCMR2 |= TIM_ICPSC;
   2145          }
   2146          
   2147          /**
   2148            * @brief  Sets the TIMx Input Capture 4 prescaler.
   2149            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2150            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   2151            *          This parameter can be one of the following values:
   2152            *            @arg TIM_ICPSC_DIV1: no prescaler
   2153            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2154            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2155            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2156            * @retval None
   2157            */
   2158          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2159          {  
   2160            /* Check the parameters */
   2161            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2162            assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2163          
   2164            /* Reset the IC4PSC Bits */
   2165            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
   2166          
   2167            /* Set the IC4PSC value */
   2168            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   2169          }
   2170          /**
   2171            * @}
   2172            */
   2173          
   2174          /** @defgroup TIM_Group4 Advanced-control timers (TIM1 and TIM8) specific features
   2175           *  @brief   Advanced-control timers (TIM1 and TIM8) specific features
   2176           *
   2177          @verbatim   
   2178           ===============================================================================
   2179                    Advanced-control timers (TIM1 and TIM8) specific features
   2180           ===============================================================================  
   2181            
   2182                 ===================================================================      
   2183                        TIM Driver: how to use the Break feature
   2184                 =================================================================== 
   2185                 After configuring the Timer channel(s) in the appropriate Output Compare mode: 
   2186                                   
   2187                 1. Fill the TIM_BDTRInitStruct with the desired parameters for the Timer
   2188                    Break Polarity, dead time, Lock level, the OSSI/OSSR State and the 
   2189                    AOE(automatic output enable).
   2190                         
   2191                 2. Call TIM_BDTRConfig(TIMx, &TIM_BDTRInitStruct) to configure the Timer
   2192                    
   2193                 3. Enable the Main Output using TIM_CtrlPWMOutputs(TIM1, ENABLE) 
   2194                    
   2195                 4. Once the break even occurs, the Timer's output signals are put in reset
   2196                    state or in a known state (according to the configuration made in
   2197                    TIM_BDTRConfig() function).
   2198          
   2199          @endverbatim
   2200            * @{
   2201            */
   2202          
   2203          /**
   2204            * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   2205            *         and the AOE(automatic output enable).
   2206            * @param  TIMx: where x can be  1 or 8 to select the TIM 
   2207            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
   2208            *         contains the BDTR Register configuration  information for the TIM peripheral.
   2209            * @retval None
   2210            */
   2211          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
   2212          {
   2213            /* Check the parameters */
   2214            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2215            assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
   2216            assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
   2217            assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
   2218            assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
   2219            assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
   2220            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
   2221          
   2222            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   2223               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   2224            TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
   2225                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
   2226                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
   2227                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   2228          }
   2229          
   2230          /**
   2231            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
   2232            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
   2233            *         will be initialized.
   2234            * @retval None
   2235            */
   2236          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
   2237          {
   2238            /* Set the default configuration */
   2239            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   2240            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   2241            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   2242            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   2243            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   2244            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   2245            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   2246          }
   2247          
   2248          /**
   2249            * @brief  Enables or disables the TIM peripheral Main Outputs.
   2250            * @param  TIMx: where x can be 1 or 8 to select the TIMx peripheral.
   2251            * @param  NewState: new state of the TIM peripheral Main Outputs.
   2252            *          This parameter can be: ENABLE or DISABLE.
   2253            * @retval None
   2254            */
   2255          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
   2256          {
   2257            /* Check the parameters */
   2258            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2259            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2260          
   2261            if (NewState != DISABLE)
   2262            {
   2263              /* Enable the TIM Main Output */
   2264              TIMx->BDTR |= TIM_BDTR_MOE;
   2265            }
   2266            else
   2267            {
   2268              /* Disable the TIM Main Output */
   2269              TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
   2270            }  
   2271          }
   2272          
   2273          /**
   2274            * @brief  Selects the TIM peripheral Commutation event.
   2275            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2276            * @param  NewState: new state of the Commutation event.
   2277            *          This parameter can be: ENABLE or DISABLE.
   2278            * @retval None
   2279            */
   2280          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   2281          {
   2282            /* Check the parameters */
   2283            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2284            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2285          
   2286            if (NewState != DISABLE)
   2287            {
   2288              /* Set the COM Bit */
   2289              TIMx->CR2 |= TIM_CR2_CCUS;
   2290            }
   2291            else
   2292            {
   2293              /* Reset the COM Bit */
   2294              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
   2295            }
   2296          }
   2297          
   2298          /**
   2299            * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
   2300            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2301            * @param  NewState: new state of the Capture Compare Preload Control bit
   2302            *          This parameter can be: ENABLE or DISABLE.
   2303            * @retval None
   2304            */
   2305          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   2306          { 
   2307            /* Check the parameters */
   2308            assert_param(IS_TIM_LIST4_PERIPH(TIMx));
   2309            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2310            if (NewState != DISABLE)
   2311            {
   2312              /* Set the CCPC Bit */
   2313              TIMx->CR2 |= TIM_CR2_CCPC;
   2314            }
   2315            else
   2316            {
   2317              /* Reset the CCPC Bit */
   2318              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
   2319            }
   2320          }
   2321          /**
   2322            * @}
   2323            */
   2324          
   2325          /** @defgroup TIM_Group5 Interrupts DMA and flags management functions
   2326           *  @brief    Interrupts, DMA and flags management functions 
   2327           *
   2328          @verbatim   
   2329           ===============================================================================
   2330                           Interrupts, DMA and flags management functions
   2331           ===============================================================================  
   2332          
   2333          @endverbatim
   2334            * @{
   2335            */
   2336          
   2337          /**
   2338            * @brief  Enables or disables the specified TIM interrupts.
   2339            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
   2340            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
   2341            *          This parameter can be any combination of the following values:
   2342            *            @arg TIM_IT_Update: TIM update Interrupt source
   2343            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2344            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2345            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2346            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2347            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2348            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2349            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2350            *  
   2351            * @note   For TIM6 and TIM7 only the parameter TIM_IT_Update can be used
   2352            * @note   For TIM9 and TIM12 only one of the following parameters can be used: TIM_IT_Update,
   2353            *          TIM_IT_CC1, TIM_IT_CC2 or TIM_IT_Trigger. 
   2354            * @note   For TIM10, TIM11, TIM13 and TIM14 only one of the following parameters can
   2355            *          be used: TIM_IT_Update or TIM_IT_CC1   
   2356            * @note   TIM_IT_COM and TIM_IT_Break can be used only with TIM1 and TIM8 
   2357            *        
   2358            * @param  NewState: new state of the TIM interrupts.
   2359            *          This parameter can be: ENABLE or DISABLE.
   2360            * @retval None
   2361            */
   2362          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
   2363          {  
   2364            /* Check the parameters */
   2365            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2366            assert_param(IS_TIM_IT(TIM_IT));
   2367            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2368            
   2369            if (NewState != DISABLE)
   2370            {
   2371              /* Enable the Interrupt sources */
   2372              TIMx->DIER |= TIM_IT;
   2373            }
   2374            else
   2375            {
   2376              /* Disable the Interrupt sources */
   2377              TIMx->DIER &= (uint16_t)~TIM_IT;
   2378            }
   2379          }
   2380          
   2381          /**
   2382            * @brief  Configures the TIMx event to be generate by software.
   2383            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2384            * @param  TIM_EventSource: specifies the event source.
   2385            *          This parameter can be one or more of the following values:	   
   2386            *            @arg TIM_EventSource_Update: Timer update Event source
   2387            *            @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   2388            *            @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   2389            *            @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   2390            *            @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
   2391            *            @arg TIM_EventSource_COM: Timer COM event source  
   2392            *            @arg TIM_EventSource_Trigger: Timer Trigger Event source
   2393            *            @arg TIM_EventSource_Break: Timer Break event source
   2394            * 
   2395            * @note   TIM6 and TIM7 can only generate an update event. 
   2396            * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
   2397            *        
   2398            * @retval None
   2399            */
   2400          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
   2401          { 
   2402            /* Check the parameters */
   2403            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2404            assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
   2405           
   2406            /* Set the event sources */
   2407            TIMx->EGR = TIM_EventSource;
   2408          }
   2409          
   2410          /**
   2411            * @brief  Checks whether the specified TIM flag is set or not.
   2412            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2413            * @param  TIM_FLAG: specifies the flag to check.
   2414            *          This parameter can be one of the following values:
   2415            *            @arg TIM_FLAG_Update: TIM update Flag
   2416            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2417            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2418            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2419            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2420            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2421            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2422            *            @arg TIM_FLAG_Break: TIM Break Flag
   2423            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2424            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2425            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2426            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2427            *
   2428            * @note   TIM6 and TIM7 can have only one update flag. 
   2429            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
   2430            *
   2431            * @retval The new state of TIM_FLAG (SET or RESET).
   2432            */
   2433          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2434          { 
   2435            ITStatus bitstatus = RESET;  
   2436            /* Check the parameters */
   2437            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2438            assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
   2439          
   2440            
   2441            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   2442            {
   2443              bitstatus = SET;
   2444            }
   2445            else
   2446            {
   2447              bitstatus = RESET;
   2448            }
   2449            return bitstatus;
   2450          }
   2451          
   2452          /**
   2453            * @brief  Clears the TIMx's pending flags.
   2454            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2455            * @param  TIM_FLAG: specifies the flag bit to clear.
   2456            *          This parameter can be any combination of the following values:
   2457            *            @arg TIM_FLAG_Update: TIM update Flag
   2458            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2459            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2460            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2461            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2462            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2463            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2464            *            @arg TIM_FLAG_Break: TIM Break Flag
   2465            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2466            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2467            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2468            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2469            *
   2470            * @note   TIM6 and TIM7 can have only one update flag. 
   2471            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.
   2472            *    
   2473            * @retval None
   2474            */
   2475          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2476          {  
   2477            /* Check the parameters */
   2478            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2479             
   2480            /* Clear the flags */
   2481            TIMx->SR = (uint16_t)~TIM_FLAG;
   2482          }
   2483          
   2484          /**
   2485            * @brief  Checks whether the TIM interrupt has occurred or not.
   2486            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2487            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2488            *          This parameter can be one of the following values:
   2489            *            @arg TIM_IT_Update: TIM update Interrupt source
   2490            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2491            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2492            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2493            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2494            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2495            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2496            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2497            *
   2498            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2499            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2500            *     
   2501            * @retval The new state of the TIM_IT(SET or RESET).
   2502            */
   2503          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2504          {
   2505            ITStatus bitstatus = RESET;  
   2506            uint16_t itstatus = 0x0, itenable = 0x0;
   2507            /* Check the parameters */
   2508            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2509            assert_param(IS_TIM_GET_IT(TIM_IT));
   2510             
   2511            itstatus = TIMx->SR & TIM_IT;
   2512            
   2513            itenable = TIMx->DIER & TIM_IT;
   2514            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   2515            {
   2516              bitstatus = SET;
   2517            }
   2518            else
   2519            {
   2520              bitstatus = RESET;
   2521            }
   2522            return bitstatus;
   2523          }
   2524          
   2525          /**
   2526            * @brief  Clears the TIMx's interrupt pending bits.
   2527            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2528            * @param  TIM_IT: specifies the pending bit to clear.
   2529            *          This parameter can be any combination of the following values:
   2530            *            @arg TIM_IT_Update: TIM1 update Interrupt source
   2531            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2532            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2533            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2534            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2535            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2536            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2537            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2538            *
   2539            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2540            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2541            *      
   2542            * @retval None
   2543            */
   2544          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2545          {
   2546            /* Check the parameters */
   2547            assert_param(IS_TIM_ALL_PERIPH(TIMx));
   2548          
   2549            /* Clear the IT pending Bit */
   2550            TIMx->SR = (uint16_t)~TIM_IT;
   2551          }
   2552          
   2553          /**
   2554            * @brief  Configures the TIMx's DMA interface.
   2555            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2556            * @param  TIM_DMABase: DMA Base address.
   2557            *          This parameter can be one of the following values:
   2558            *            @arg TIM_DMABase_CR1  
   2559            *            @arg TIM_DMABase_CR2
   2560            *            @arg TIM_DMABase_SMCR
   2561            *            @arg TIM_DMABase_DIER
   2562            *            @arg TIM1_DMABase_SR
   2563            *            @arg TIM_DMABase_EGR
   2564            *            @arg TIM_DMABase_CCMR1
   2565            *            @arg TIM_DMABase_CCMR2
   2566            *            @arg TIM_DMABase_CCER
   2567            *            @arg TIM_DMABase_CNT   
   2568            *            @arg TIM_DMABase_PSC   
   2569            *            @arg TIM_DMABase_ARR
   2570            *            @arg TIM_DMABase_RCR
   2571            *            @arg TIM_DMABase_CCR1
   2572            *            @arg TIM_DMABase_CCR2
   2573            *            @arg TIM_DMABase_CCR3  
   2574            *            @arg TIM_DMABase_CCR4
   2575            *            @arg TIM_DMABase_BDTR
   2576            *            @arg TIM_DMABase_DCR
   2577            * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
   2578            *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
   2579            * @retval None
   2580            */
   2581          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
   2582          {
   2583            /* Check the parameters */
   2584            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2585            assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
   2586            assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
   2587          
   2588            /* Set the DMA Base and the DMA Burst Length */
   2589            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   2590          }
   2591          
   2592          /**
   2593            * @brief  Enables or disables the TIMx's DMA Requests.
   2594            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2595            * @param  TIM_DMASource: specifies the DMA Request sources.
   2596            *          This parameter can be any combination of the following values:
   2597            *            @arg TIM_DMA_Update: TIM update Interrupt source
   2598            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   2599            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   2600            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   2601            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   2602            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   2603            *            @arg TIM_DMA_Trigger: TIM Trigger DMA source
   2604            * @param  NewState: new state of the DMA Request sources.
   2605            *          This parameter can be: ENABLE or DISABLE.
   2606            * @retval None
   2607            */
   2608          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
   2609          { 
   2610            /* Check the parameters */
   2611            assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
   2612            assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
   2613            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2614            
   2615            if (NewState != DISABLE)
   2616            {
   2617              /* Enable the DMA sources */
   2618              TIMx->DIER |= TIM_DMASource; 
   2619            }
   2620            else
   2621            {
   2622              /* Disable the DMA sources */
   2623              TIMx->DIER &= (uint16_t)~TIM_DMASource;
   2624            }
   2625          }
   2626          
   2627          /**
   2628            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   2629            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2630            * @param  NewState: new state of the Capture Compare DMA source
   2631            *          This parameter can be: ENABLE or DISABLE.
   2632            * @retval None
   2633            */
   2634          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   2635          {
   2636            /* Check the parameters */
   2637            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2638            assert_param(IS_FUNCTIONAL_STATE(NewState));
   2639          
   2640            if (NewState != DISABLE)
   2641            {
   2642              /* Set the CCDS Bit */
   2643              TIMx->CR2 |= TIM_CR2_CCDS;
   2644            }
   2645            else
   2646            {
   2647              /* Reset the CCDS Bit */
   2648              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
   2649            }
   2650          }
   2651          /**
   2652            * @}
   2653            */
   2654          
   2655          /** @defgroup TIM_Group6 Clocks management functions
   2656           *  @brief    Clocks management functions
   2657           *
   2658          @verbatim   
   2659           ===============================================================================
   2660                                   Clocks management functions
   2661           ===============================================================================  
   2662          
   2663          @endverbatim
   2664            * @{
   2665            */
   2666          
   2667          /**
   2668            * @brief  Configures the TIMx internal Clock
   2669            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2670            *         peripheral.
   2671            * @retval None
   2672            */
   2673          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   2674          {
   2675            /* Check the parameters */
   2676            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2677          
   2678            /* Disable slave mode to clock the prescaler directly with the internal clock */
   2679            TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
   2680          }
   2681          
   2682          /**
   2683            * @brief  Configures the TIMx Internal Trigger as External Clock
   2684            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2685            *         peripheral.
   2686            * @param  TIM_InputTriggerSource: Trigger source.
   2687            *          This parameter can be one of the following values:
   2688            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2689            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2690            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2691            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2692            * @retval None
   2693            */
   2694          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2695          {
   2696            /* Check the parameters */
   2697            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2698            assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2699          
   2700            /* Select the Internal Trigger */
   2701            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   2702          
   2703            /* Select the External clock mode1 */
   2704            TIMx->SMCR |= TIM_SlaveMode_External1;
   2705          }
   2706          
   2707          /**
   2708            * @brief  Configures the TIMx Trigger as External Clock
   2709            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2710            *         to select the TIM peripheral.
   2711            * @param  TIM_TIxExternalCLKSource: Trigger source.
   2712            *          This parameter can be one of the following values:
   2713            *            @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   2714            *            @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   2715            *            @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   2716            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   2717            *          This parameter can be one of the following values:
   2718            *            @arg TIM_ICPolarity_Rising
   2719            *            @arg TIM_ICPolarity_Falling
   2720            * @param  ICFilter: specifies the filter value.
   2721            *          This parameter must be a value between 0x0 and 0xF.
   2722            * @retval None
   2723            */
   2724          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   2725                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   2726          {
   2727            /* Check the parameters */
   2728            assert_param(IS_TIM_LIST1_PERIPH(TIMx));
   2729            assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   2730            assert_param(IS_TIM_IC_FILTER(ICFilter));
   2731          
   2732            /* Configure the Timer Input Clock Source */
   2733            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   2734            {
   2735              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2736            }
   2737            else
   2738            {
   2739              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2740            }
   2741            /* Select the Trigger source */
   2742            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   2743            /* Select the External clock mode1 */
   2744            TIMx->SMCR |= TIM_SlaveMode_External1;
   2745          }
   2746          
   2747          /**
   2748            * @brief  Configures the External clock Mode1
   2749            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2750            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2751            *          This parameter can be one of the following values:
   2752            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2753            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2754            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2755            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2756            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2757            *          This parameter can be one of the following values:
   2758            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2759            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2760            * @param  ExtTRGFilter: External Trigger Filter.
   2761            *          This parameter must be a value between 0x00 and 0x0F
   2762            * @retval None
   2763            */
   2764          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   2765                                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2766          {
   2767            uint16_t tmpsmcr = 0;
   2768          
   2769            /* Check the parameters */
   2770            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2771            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2772            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2773            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2774            /* Configure the ETR Clock source */
   2775            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2776            
   2777            /* Get the TIMx SMCR register value */
   2778            tmpsmcr = TIMx->SMCR;
   2779          
   2780            /* Reset the SMS Bits */
   2781            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   2782          
   2783            /* Select the External clock mode1 */
   2784            tmpsmcr |= TIM_SlaveMode_External1;
   2785          
   2786            /* Select the Trigger selection : ETRF */
   2787            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2788            tmpsmcr |= TIM_TS_ETRF;
   2789          
   2790            /* Write to TIMx SMCR */
   2791            TIMx->SMCR = tmpsmcr;
   2792          }
   2793          
   2794          /**
   2795            * @brief  Configures the External clock Mode2
   2796            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2797            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2798            *          This parameter can be one of the following values:
   2799            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2800            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2801            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2802            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2803            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2804            *          This parameter can be one of the following values:
   2805            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2806            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2807            * @param  ExtTRGFilter: External Trigger Filter.
   2808            *          This parameter must be a value between 0x00 and 0x0F
   2809            * @retval None
   2810            */
   2811          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   2812                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2813          {
   2814            /* Check the parameters */
   2815            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   2816            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2817            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2818            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2819          
   2820            /* Configure the ETR Clock source */
   2821            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2822          
   2823            /* Enable the External clock mode2 */
   2824            TIMx->SMCR |= TIM_SMCR_ECE;
   2825          }
   2826          /**
   2827            * @}
   2828            */
   2829          
   2830          /** @defgroup TIM_Group7 Synchronization management functions
   2831           *  @brief    Synchronization management functions 
   2832           *
   2833          @verbatim   
   2834           ===============================================================================
   2835                                 Synchronization management functions
   2836           ===============================================================================  
   2837                             
   2838                 ===================================================================      
   2839                        TIM Driver: how to use it in synchronization Mode
   2840                 =================================================================== 
   2841                 Case of two/several Timers
   2842                 **************************
   2843                 1. Configure the Master Timers using the following functions:
   2844                    - void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource); 
   2845                    - void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);  
   2846                 2. Configure the Slave Timers using the following functions: 
   2847                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2848                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2849                    
   2850                 Case of Timers and external trigger(ETR pin)
   2851                 ********************************************       
   2852                 1. Configure the External trigger using this function:
   2853                    - void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2854                                         uint16_t ExtTRGFilter);
   2855                 2. Configure the Slave Timers using the following functions: 
   2856                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2857                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2858          
   2859          @endverbatim
   2860            * @{
   2861            */
   2862          
   2863          /**
   2864            * @brief  Selects the Input Trigger source
   2865            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2866            *         to select the TIM peripheral.
   2867            * @param  TIM_InputTriggerSource: The Input Trigger source.
   2868            *          This parameter can be one of the following values:
   2869            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2870            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2871            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2872            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2873            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   2874            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   2875            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   2876            *            @arg TIM_TS_ETRF: External Trigger input
   2877            * @retval None
   2878            */
   2879          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2880          {
   2881            uint16_t tmpsmcr = 0;
   2882          
   2883            /* Check the parameters */
   2884            assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
   2885            assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2886          
   2887            /* Get the TIMx SMCR register value */
   2888            tmpsmcr = TIMx->SMCR;
   2889          
   2890            /* Reset the TS Bits */
   2891            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2892          
   2893            /* Set the Input Trigger source */
   2894            tmpsmcr |= TIM_InputTriggerSource;
   2895          
   2896            /* Write to TIMx SMCR */
   2897            TIMx->SMCR = tmpsmcr;
   2898          }
   2899          
   2900          /**
   2901            * @brief  Selects the TIMx Trigger Output Mode.
   2902            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2903            *     
   2904            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2905            *   This parameter can be one of the following values:
   2906            *
   2907            *  - For all TIMx
   2908            *            @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output(TRGO)
   2909            *            @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output(TRGO)
   2910            *            @arg TIM_TRGOSource_Update: The update event is selected as the trigger output(TRGO)
   2911            *
   2912            *  - For all TIMx except TIM6 and TIM7
   2913            *            @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2914            *                                     is to be set, as soon as a capture or compare match occurs(TRGO)
   2915            *            @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output(TRGO)
   2916            *            @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output(TRGO)
   2917            *            @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output(TRGO)
   2918            *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output(TRGO)
   2919            *
   2920            * @retval None
   2921            */
   2922          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2923          {
   2924            /* Check the parameters */
   2925            assert_param(IS_TIM_LIST5_PERIPH(TIMx));
   2926            assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2927          
   2928            /* Reset the MMS Bits */
   2929            TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
   2930            /* Select the TRGO source */
   2931            TIMx->CR2 |=  TIM_TRGOSource;
   2932          }
   2933          
   2934          /**
   2935            * @brief  Selects the TIMx Slave Mode.
   2936            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2937            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2938            *          This parameter can be one of the following values:
   2939            *            @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal(TRGI) reinitialize 
   2940            *                                      the counter and triggers an update of the registers
   2941            *            @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high
   2942            *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI
   2943            *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter
   2944            * @retval None
   2945            */
   2946          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2947          {
   2948            /* Check the parameters */
   2949            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2950            assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2951          
   2952            /* Reset the SMS Bits */
   2953            TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
   2954          
   2955            /* Select the Slave Mode */
   2956            TIMx->SMCR |= TIM_SlaveMode;
   2957          }
   2958          
   2959          /**
   2960            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2961            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2962            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2963            *          This parameter can be one of the following values:
   2964            *            @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2965            *                                             and its slaves (through TRGO)
   2966            *            @arg TIM_MasterSlaveMode_Disable: No action
   2967            * @retval None
   2968            */
   2969          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2970          {
   2971            /* Check the parameters */
   2972            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   2973            assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2974          
   2975            /* Reset the MSM Bit */
   2976            TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
   2977            
   2978            /* Set or Reset the MSM Bit */
   2979            TIMx->SMCR |= TIM_MasterSlaveMode;
   2980          }
   2981          
   2982          /**
   2983            * @brief  Configures the TIMx External Trigger (ETR).
   2984            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2985            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2986            *          This parameter can be one of the following values:
   2987            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2988            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2989            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2990            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2991            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2992            *          This parameter can be one of the following values:
   2993            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2994            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2995            * @param  ExtTRGFilter: External Trigger Filter.
   2996            *          This parameter must be a value between 0x00 and 0x0F
   2997            * @retval None
   2998            */
   2999          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   3000                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   3001          {
   3002            uint16_t tmpsmcr = 0;
   3003          
   3004            /* Check the parameters */
   3005            assert_param(IS_TIM_LIST3_PERIPH(TIMx));
   3006            assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   3007            assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   3008            assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
   3009          
   3010            tmpsmcr = TIMx->SMCR;
   3011          
   3012            /* Reset the ETR Bits */
   3013            tmpsmcr &= SMCR_ETR_MASK;
   3014          
   3015            /* Set the Prescaler, the Filter value and the Polarity */
   3016            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   3017          
   3018            /* Write to TIMx SMCR */
   3019            TIMx->SMCR = tmpsmcr;
   3020          }
   3021          /**
   3022            * @}
   3023            */
   3024          
   3025          /** @defgroup TIM_Group8 Specific interface management functions
   3026           *  @brief    Specific interface management functions 
   3027           *
   3028          @verbatim   
   3029           ===============================================================================
   3030                              Specific interface management functions
   3031           ===============================================================================  
   3032          
   3033          @endverbatim
   3034            * @{
   3035            */
   3036          
   3037          /**
   3038            * @brief  Configures the TIMx Encoder Interface.
   3039            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3040            *         peripheral.
   3041            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   3042            *          This parameter can be one of the following values:
   3043            *            @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   3044            *            @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   3045            *            @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   3046            *                                       on the level of the other input.
   3047            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   3048            *          This parameter can be one of the following values:
   3049            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3050            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3051            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   3052            *          This parameter can be one of the following values:
   3053            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3054            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3055            * @retval None
   3056            */
   3057          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   3058                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   3059          {
   3060            uint16_t tmpsmcr = 0;
   3061            uint16_t tmpccmr1 = 0;
   3062            uint16_t tmpccer = 0;
   3063              
   3064            /* Check the parameters */
   3065            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   3066            assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   3067            assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   3068            assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   3069          
   3070            /* Get the TIMx SMCR register value */
   3071            tmpsmcr = TIMx->SMCR;
   3072          
   3073            /* Get the TIMx CCMR1 register value */
   3074            tmpccmr1 = TIMx->CCMR1;
   3075          
   3076            /* Get the TIMx CCER register value */
   3077            tmpccer = TIMx->CCER;
   3078          
   3079            /* Set the encoder Mode */
   3080            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   3081            tmpsmcr |= TIM_EncoderMode;
   3082          
   3083            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   3084            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
   3085            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   3086          
   3087            /* Set the TI1 and the TI2 Polarities */
   3088            tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
   3089            tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   3090          
   3091            /* Write to TIMx SMCR */
   3092            TIMx->SMCR = tmpsmcr;
   3093          
   3094            /* Write to TIMx CCMR1 */
   3095            TIMx->CCMR1 = tmpccmr1;
   3096          
   3097            /* Write to TIMx CCER */
   3098            TIMx->CCER = tmpccer;
   3099          }
   3100          
   3101          /**
   3102            * @brief  Enables or disables the TIMx's Hall sensor interface.
   3103            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3104            *         peripheral.
   3105            * @param  NewState: new state of the TIMx Hall sensor interface.
   3106            *          This parameter can be: ENABLE or DISABLE.
   3107            * @retval None
   3108            */
   3109          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   3110          {
   3111            /* Check the parameters */
   3112            assert_param(IS_TIM_LIST2_PERIPH(TIMx));
   3113            assert_param(IS_FUNCTIONAL_STATE(NewState));
   3114          
   3115            if (NewState != DISABLE)
   3116            {
   3117              /* Set the TI1S Bit */
   3118              TIMx->CR2 |= TIM_CR2_TI1S;
   3119            }
   3120            else
   3121            {
   3122              /* Reset the TI1S Bit */
   3123              TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
   3124            }
   3125          }
   3126          /**
   3127            * @}
   3128            */
   3129          
   3130          /** @defgroup TIM_Group9 Specific remapping management function
   3131           *  @brief   Specific remapping management function
   3132           *
   3133          @verbatim   
   3134           ===============================================================================
   3135                               Specific remapping management function
   3136           ===============================================================================  
   3137          
   3138          @endverbatim
   3139            * @{
   3140            */
   3141          
   3142          /**
   3143            * @brief  Configures the TIM2, TIM5 and TIM11 Remapping input capabilities.
   3144            * @param  TIMx: where x can be 2, 5 or 11 to select the TIM peripheral.
   3145            * @param  TIM_Remap: specifies the TIM input remapping source.
   3146            *          This parameter can be one of the following values:
   3147            *            @arg TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)
   3148            *            @arg TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trogger output.
   3149            *            @arg TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF. 
   3150            *            @arg TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF. 
   3151            *            @arg TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)
   3152            *            @arg TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.
   3153            *            @arg TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.
   3154            *            @arg TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.
   3155            *            @arg TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default) 
   3156            *            @arg TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
   3157            *                                 (HSE divided by a programmable prescaler)  
   3158            * @retval None
   3159            */
   3160          void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
   3161          {
   3162           /* Check the parameters */
   3163            assert_param(IS_TIM_LIST6_PERIPH(TIMx));
   3164            assert_param(IS_TIM_REMAP(TIM_Remap));
   3165          
   3166            /* Set the Timer remapping configuration */
   3167            TIMx->OR =  TIM_Remap;
   3168          }
   3169          /**
   3170            * @}
   3171            */
   3172          
   3173          /**
   3174            * @brief  Configure the TI1 as Input.
   3175            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   3176            *         to select the TIM peripheral.
   3177            * @param  TIM_ICPolarity : The Input Polarity.
   3178            *          This parameter can be one of the following values:
   3179            *            @arg TIM_ICPolarity_Rising
   3180            *            @arg TIM_ICPolarity_Falling
   3181            *            @arg TIM_ICPolarity_BothEdge  
   3182            * @param  TIM_ICSelection: specifies the input to be used.
   3183            *          This parameter can be one of the following values:
   3184            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   3185            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   3186            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   3187            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3188            *          This parameter must be a value between 0x00 and 0x0F.
   3189            * @retval None
   3190            */
   3191          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3192                                 uint16_t TIM_ICFilter)
   3193          {
   3194            uint16_t tmpccmr1 = 0, tmpccer = 0;
   3195          
   3196            /* Disable the Channel 1: Reset the CC1E Bit */
   3197            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
   3198            tmpccmr1 = TIMx->CCMR1;
   3199            tmpccer = TIMx->CCER;
   3200          
   3201            /* Select the Input and set the filter */
   3202            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
   3203            tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3204          
   3205            /* Select the Polarity and set the CC1E Bit */
   3206            tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   3207            tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   3208          
   3209            /* Write to TIMx CCMR1 and CCER registers */
   3210            TIMx->CCMR1 = tmpccmr1;
   3211            TIMx->CCER = tmpccer;
   3212          }
   3213          
   3214          /**
   3215            * @brief  Configure the TI2 as Input.
   3216            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3217            *         peripheral.
   3218            * @param  TIM_ICPolarity : The Input Polarity.
   3219            *          This parameter can be one of the following values:
   3220            *            @arg TIM_ICPolarity_Rising
   3221            *            @arg TIM_ICPolarity_Falling
   3222            *            @arg TIM_ICPolarity_BothEdge   
   3223            * @param  TIM_ICSelection: specifies the input to be used.
   3224            *          This parameter can be one of the following values:
   3225            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   3226            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   3227            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   3228            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3229            *          This parameter must be a value between 0x00 and 0x0F.
   3230            * @retval None
   3231            */
   3232          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3233                                 uint16_t TIM_ICFilter)
   3234          {
   3235            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   3236          
   3237            /* Disable the Channel 2: Reset the CC2E Bit */
   3238            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
   3239            tmpccmr1 = TIMx->CCMR1;
   3240            tmpccer = TIMx->CCER;
   3241            tmp = (uint16_t)(TIM_ICPolarity << 4);
   3242          
   3243            /* Select the Input and set the filter */
   3244            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3245            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   3246            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   3247          
   3248            /* Select the Polarity and set the CC2E Bit */
   3249            tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   3250            tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   3251          
   3252            /* Write to TIMx CCMR1 and CCER registers */
   3253            TIMx->CCMR1 = tmpccmr1 ;
   3254            TIMx->CCER = tmpccer;
   3255          }
   3256          
   3257          /**
   3258            * @brief  Configure the TI3 as Input.
   3259            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3260            * @param  TIM_ICPolarity : The Input Polarity.
   3261            *          This parameter can be one of the following values:
   3262            *            @arg TIM_ICPolarity_Rising
   3263            *            @arg TIM_ICPolarity_Falling
   3264            *            @arg TIM_ICPolarity_BothEdge         
   3265            * @param  TIM_ICSelection: specifies the input to be used.
   3266            *          This parameter can be one of the following values:
   3267            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   3268            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   3269            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   3270            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3271            *          This parameter must be a value between 0x00 and 0x0F.
   3272            * @retval None
   3273            */
   3274          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3275                                 uint16_t TIM_ICFilter)
   3276          {
   3277            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3278          
   3279            /* Disable the Channel 3: Reset the CC3E Bit */
   3280            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
   3281            tmpccmr2 = TIMx->CCMR2;
   3282            tmpccer = TIMx->CCER;
   3283            tmp = (uint16_t)(TIM_ICPolarity << 8);
   3284          
   3285            /* Select the Input and set the filter */
   3286            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
   3287            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3288          
   3289            /* Select the Polarity and set the CC3E Bit */
   3290            tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   3291            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   3292          
   3293            /* Write to TIMx CCMR2 and CCER registers */
   3294            TIMx->CCMR2 = tmpccmr2;
   3295            TIMx->CCER = tmpccer;
   3296          }
   3297          
   3298          /**
   3299            * @brief  Configure the TI4 as Input.
   3300            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3301            * @param  TIM_ICPolarity : The Input Polarity.
   3302            *          This parameter can be one of the following values:
   3303            *            @arg TIM_ICPolarity_Rising
   3304            *            @arg TIM_ICPolarity_Falling
   3305            *            @arg TIM_ICPolarity_BothEdge     
   3306            * @param  TIM_ICSelection: specifies the input to be used.
   3307            *          This parameter can be one of the following values:
   3308            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   3309            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   3310            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   3311            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3312            *          This parameter must be a value between 0x00 and 0x0F.
   3313            * @retval None
   3314            */
   3315          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3316                                 uint16_t TIM_ICFilter)
   3317          {
   3318            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3319          
   3320            /* Disable the Channel 4: Reset the CC4E Bit */
   3321            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
   3322            tmpccmr2 = TIMx->CCMR2;
   3323            tmpccer = TIMx->CCER;
   3324            tmp = (uint16_t)(TIM_ICPolarity << 12);
   3325          
   3326            /* Select the Input and set the filter */
   3327            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3328            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   3329            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   3330          
   3331            /* Select the Polarity and set the CC4E Bit */
   3332            tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   3333            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   3334          
   3335            /* Write to TIMx CCMR2 and CCER registers */
   3336            TIMx->CCMR2 = tmpccmr2;
   3337            TIMx->CCER = tmpccer ;
   3338          }
   3339          
   3340          /**
   3341            * @}
   3342            */
   3343          
   3344          /**
   3345            * @}
   3346            */
   3347          
   3348          /**
   3349            * @}
   3350            */
   3351          
   3352          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   TI1_Config
      12   TI2_Config
      12   TI3_Config
      12   TI4_Config
       0   TIM_ARRPreloadConfig
       0   TIM_BDTRConfig
       0   TIM_BDTRStructInit
       0   TIM_CCPreloadControl
       4   TIM_CCxCmd
       4   TIM_CCxNCmd
       0   TIM_ClearFlag
       0   TIM_ClearITPendingBit
       0   TIM_ClearOC1Ref
       0   TIM_ClearOC2Ref
       0   TIM_ClearOC3Ref
       0   TIM_ClearOC4Ref
       0   TIM_Cmd
       0   TIM_CounterModeConfig
       0   TIM_CtrlPWMOutputs
       0   TIM_DMACmd
       0   TIM_DMAConfig
       8   TIM_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       8   TIM_ETRClockMode1Config
         8   -> TIM_ETRConfig
       8   TIM_ETRClockMode2Config
         8   -> TIM_ETRConfig
       4   TIM_ETRConfig
      16   TIM_EncoderInterfaceConfig
       0   TIM_ForcedOC1Config
       0   TIM_ForcedOC2Config
       0   TIM_ForcedOC3Config
       0   TIM_ForcedOC4Config
       0   TIM_GenerateEvent
       0   TIM_GetCapture1
       0   TIM_GetCapture2
       0   TIM_GetCapture3
       0   TIM_GetCapture4
       0   TIM_GetCounter
       0   TIM_GetFlagStatus
       0   TIM_GetITStatus
       0   TIM_GetPrescaler
      16   TIM_ICInit
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TI3_Config
        16   -> TI4_Config
        16   -> TIM_SetIC1Prescaler
        16   -> TIM_SetIC2Prescaler
        16   -> TIM_SetIC3Prescaler
        16   -> TIM_SetIC4Prescaler
       0   TIM_ICStructInit
       0   TIM_ITConfig
       8   TIM_ITRxExternalClockConfig
         8   -> TIM_SelectInputTrigger
       0   TIM_InternalClockConfig
       0   TIM_OC1FastConfig
       8   TIM_OC1Init
       0   TIM_OC1NPolarityConfig
       0   TIM_OC1PolarityConfig
       0   TIM_OC1PreloadConfig
       0   TIM_OC2FastConfig
       8   TIM_OC2Init
       0   TIM_OC2NPolarityConfig
       0   TIM_OC2PolarityConfig
       0   TIM_OC2PreloadConfig
       0   TIM_OC3FastConfig
       8   TIM_OC3Init
       0   TIM_OC3NPolarityConfig
       0   TIM_OC3PolarityConfig
       0   TIM_OC3PreloadConfig
       0   TIM_OC4FastConfig
       8   TIM_OC4Init
       0   TIM_OC4PolarityConfig
       0   TIM_OC4PreloadConfig
       0   TIM_OCStructInit
      24   TIM_PWMIConfig
        24   -> TI1_Config
        24   -> TI2_Config
        24   -> TIM_SetIC1Prescaler
        24   -> TIM_SetIC2Prescaler
       0   TIM_PrescalerConfig
       0   TIM_RemapConfig
       0   TIM_SelectCCDMA
       0   TIM_SelectCOM
       0   TIM_SelectHallSensor
       0   TIM_SelectInputTrigger
       0   TIM_SelectMasterSlaveMode
       8   TIM_SelectOCxM
       0   TIM_SelectOnePulseMode
       0   TIM_SelectOutputTrigger
       0   TIM_SelectSlaveMode
       0   TIM_SetAutoreload
       0   TIM_SetClockDivision
       0   TIM_SetCompare1
       0   TIM_SetCompare2
       0   TIM_SetCompare3
       0   TIM_SetCompare4
       0   TIM_SetCounter
       0   TIM_SetIC1Prescaler
       0   TIM_SetIC2Prescaler
       0   TIM_SetIC3Prescaler
       0   TIM_SetIC4Prescaler
      16   TIM_TIxExternalClockConfig
        16   -> TI1_Config
        16   -> TI2_Config
        16   -> TIM_SelectInputTrigger
       0   TIM_TimeBaseInit
       0   TIM_TimeBaseStructInit
       0   TIM_UpdateDisableConfig
       0   TIM_UpdateRequestConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      52  TI1_Config
      58  TI2_Config
      56  TI3_Config
      58  TI4_Config
      28  TIM_ARRPreloadConfig
      32  TIM_BDTRConfig
      30  TIM_BDTRStructInit
      28  TIM_CCPreloadControl
      32  TIM_CCxCmd
      32  TIM_CCxNCmd
       8  TIM_ClearFlag
       8  TIM_ClearITPendingBit
      16  TIM_ClearOC1Ref
      16  TIM_ClearOC2Ref
      16  TIM_ClearOC3Ref
      16  TIM_ClearOC4Ref
      28  TIM_Cmd
      16  TIM_CounterModeConfig
      34  TIM_CtrlPWMOutputs
      24  TIM_DMACmd
       8  TIM_DMAConfig
     376  TIM_DeInit
      44  TIM_ETRClockMode1Config
      26  TIM_ETRClockMode2Config
      22  TIM_ETRConfig
      56  TIM_EncoderInterfaceConfig
      16  TIM_ForcedOC1Config
      18  TIM_ForcedOC2Config
      16  TIM_ForcedOC3Config
      18  TIM_ForcedOC4Config
       4  TIM_GenerateEvent
       4  TIM_GetCapture1
       4  TIM_GetCapture2
       4  TIM_GetCapture3
       4  TIM_GetCapture4
       4  TIM_GetCounter
      20  TIM_GetFlagStatus
      40  TIM_GetITStatus
       4  TIM_GetPrescaler
     112  TIM_ICInit
      22  TIM_ICStructInit
      24  TIM_ITConfig
      22  TIM_ITRxExternalClockConfig
      12  TIM_InternalClockConfig
      16  TIM_OC1FastConfig
     120  TIM_OC1Init
      16  TIM_OC1NPolarityConfig
      16  TIM_OC1PolarityConfig
      16  TIM_OC1PreloadConfig
      18  TIM_OC2FastConfig
     134  TIM_OC2Init
      18  TIM_OC2NPolarityConfig
      18  TIM_OC2PolarityConfig
      18  TIM_OC2PreloadConfig
      16  TIM_OC3FastConfig
     132  TIM_OC3Init
      18  TIM_OC3NPolarityConfig
      18  TIM_OC3PolarityConfig
      16  TIM_OC3PreloadConfig
      18  TIM_OC4FastConfig
      98  TIM_OC4Init
      18  TIM_OC4PolarityConfig
      18  TIM_OC4PreloadConfig
      34  TIM_OCStructInit
     132  TIM_PWMIConfig
       6  TIM_PrescalerConfig
       6  TIM_RemapConfig
      28  TIM_SelectCCDMA
      28  TIM_SelectCOM
      28  TIM_SelectHallSensor
      16  TIM_SelectInputTrigger
      18  TIM_SelectMasterSlaveMode
      96  TIM_SelectOCxM
      18  TIM_SelectOnePulseMode
      18  TIM_SelectOutputTrigger
      18  TIM_SelectSlaveMode
       4  TIM_SetAutoreload
      18  TIM_SetClockDivision
       4  TIM_SetCompare1
       4  TIM_SetCompare2
       4  TIM_SetCompare3
       4  TIM_SetCompare4
       4  TIM_SetCounter
      18  TIM_SetIC1Prescaler
      20  TIM_SetIC2Prescaler
      18  TIM_SetIC3Prescaler
      20  TIM_SetIC4Prescaler
      60  TIM_TIxExternalClockConfig
     104  TIM_TimeBaseInit
      24  TIM_TimeBaseStructInit
      28  TIM_UpdateDisableConfig
      28  TIM_UpdateRequestConfig

 
 3 070 bytes in section .text
 
 3 070 bytes of CODE memory

Errors: none
Warnings: none
